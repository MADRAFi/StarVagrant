mads 2.0.8 build 1 (2 Nov 17)
  1103 					opt l+
    81
    82 205F				RCDATA 'assets/Nvdi8.fnt' CHARSET_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('assets/Nvdi8.fnt')
    17 205F				org main.CHARSET_ADDRESS
    19 4000-43FF> 00 00 00 00 + 	ins 'assets/Nvdi8.fnt'
Source: starvagrant.a65
    83 4400				RCASM 'dlist_menu.asm' DISPLAY_LIST_ADDRESS_MENU 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 4400				org RESORIGIN
     4 = 0075			len = .sizeof(_DISPLAY_LIST_ADDRESS_MENU)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_MENU+len >= $bc20
    11 205F-20F4> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5F +  MWA #MAIN.DISPLAY_LIST_ADDRESS_MENU ECX
    13 2072 A9 75 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: dlist_menu.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
    13 = 5B00			FREE_BOTTOM = $5b00;
    15 = 5B00			STRINGS_ADDRESS = FREE_BOTTOM;
    16 = 5C00			LOCATIONS_ADDRESS = STRINGS_ADDRESS + $100;
    17 = 5E00			ITEMS_ADDRESS = LOCATIONS_ADDRESS + $200;
    18 = 5F00			DISPLAY_LIST_ADDRESS_MENU = ITEMS_ADDRESS + $100;
    19 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE = DISPLAY_LIST_ADDRESS_MENU + $100;
    21 = 6100			VIDEO_RAM_ADDRESS = DISPLAY_LIST_ADDRESS_CONSOLE + $100;
    24 = 7000			GFX_ADDRESS = $7000;
    29 = 8A00			RMT_PLAYER_ADDRESS = $8a00;
    30 = 9200			RMT_MODULE_ADDRESS = RMT_PLAYER_ADDRESS + $800;
    32 = 4000			CHARSET_ADDRESS = $4000;
    36 = 0028			TXTCOL = 40; // numer of columns in txt mode
    41 = 0031			KEY_OPTION1 = '1';
    42 = 0032			KEY_OPTION2 = '2';
    43 = 0033			KEY_OPTION3 = '3';
    44 = 0034			KEY_OPTION4 = '4';
    45 = 0062			KEY_BACK = 'b';
    46 = 0071			KEY_QUIT = 'q';
    47 = 006E			KEY_NEW = 'n';
    51 = 0000			MENU_TITLE = 0;
    52 = 0001			MENU_MAIN = 1;
    53 = 0002			MENU_NAV = 2;
    54 = 0003			MENU_TRADE = 3;
    55 = 0004			MENU_MAINT = 4;
    53 5F00			dl_start
    54 5F00 F0			    dta DL_DLI + DL_BLANK8                            ; // 8 blank line
    55 5F01 4E 00 70		    dta DL_MODE_160x192G4 + DL_LMS, a(GFX_ADDRESS)      ; // gfx line + graphics memory start
    56 5F04 0E 0E 0E 0E 0E 0E +     :99 dta DL_MODE_160x192G4                           ; // x graphics line
    57 5F67 F0			    dta DL_DLI + DL_BLANK8                                       ; // 8 blank lines
    58 5F68 42 00 61		    dta DL_MODE_40x24T2 + DL_LMS, a(VIDEO_RAM_ADDRESS)  ; // mode 0 line + text memory start
    59 5F6B 02 02 02 02 02	    :5 dta DL_MODE_40x24T2                              ; // 5x mode 0 line
    60 5F70 F0			    dta DL_DLI + DL_BLANK8                                       ; // 8 blank line
    61 5F71 12			    dta DL_MODE_40x24T2 + DL_HSCROLL                    ; //  mode 0 line
    62 5F72 41 00 5F		    dta DL_JVB, a(dl_start)                             ; // jump to beginning
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    84 20F5				RCASM 'dlist_console.asm' DISPLAY_LIST_ADDRESS_CONSOLE 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 20F5				org RESORIGIN
     4 = 001F			len = .sizeof(_DISPLAY_LIST_ADDRESS_CONSOLE)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_CONSOLE+len >= $bc20
    11 205F-209E> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 60 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_CONSOLE ECX
    13 2072 A9 1F 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: dlist_console.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
    13 = 5B00			FREE_BOTTOM = $5b00;
    15 = 5B00			STRINGS_ADDRESS = FREE_BOTTOM;
    16 = 5C00			LOCATIONS_ADDRESS = STRINGS_ADDRESS + $100;
    17 = 5E00			ITEMS_ADDRESS = LOCATIONS_ADDRESS + $200;
    18 = 5F00			DISPLAY_LIST_ADDRESS_MENU = ITEMS_ADDRESS + $100;
    19 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE = DISPLAY_LIST_ADDRESS_MENU + $100;
    21 = 6100			VIDEO_RAM_ADDRESS = DISPLAY_LIST_ADDRESS_CONSOLE + $100;
    24 = 7000			GFX_ADDRESS = $7000;
    29 = 8A00			RMT_PLAYER_ADDRESS = $8a00;
    30 = 9200			RMT_MODULE_ADDRESS = RMT_PLAYER_ADDRESS + $800;
    32 = 4000			CHARSET_ADDRESS = $4000;
    36 = 0028			TXTCOL = 40; // numer of columns in txt mode
    41 = 0031			KEY_OPTION1 = '1';
    42 = 0032			KEY_OPTION2 = '2';
    43 = 0033			KEY_OPTION3 = '3';
    44 = 0034			KEY_OPTION4 = '4';
    45 = 0062			KEY_BACK = 'b';
    46 = 0071			KEY_QUIT = 'q';
    47 = 006E			KEY_NEW = 'n';
    51 = 0000			MENU_TITLE = 0;
    52 = 0001			MENU_MAIN = 1;
    53 = 0002			MENU_NAV = 2;
    54 = 0003			MENU_TRADE = 3;
    55 = 0004			MENU_MAINT = 4;
    37 6000			dl_start
    38 6000 F0			    dta DL_DLI + DL_BLANK8                              ; // 8 blank line
    39 6001 42 00 61		    dta DL_MODE_40x24T2 + DL_LMS, a(VIDEO_RAM_ADDRESS)  ; // mode 0 line + text memory start
    40 6004 02 02 02 02 02 02 +     :22 dta DL_MODE_40x24T2                             ; // 5x mode 0 line
    41 601A 12			    dta DL_MODE_40x24T2 + DL_HSCROLL                    ; //  mode 0 line
    42 601B 70			    dta DL_BLANK8                                       ; // 8 blank lines
    43 601C 41 00 60		    dta DL_JVB, a(dl_start)                             ; // jump to beginning
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    85 209F				RCASM 'strings.asm' STRINGS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 209F				org RESORIGIN
     4 = 007A			len = .sizeof(_STRINGS_ADDRESS)
     6 				mcpy	ift main.STRINGS_ADDRESS+len >= $bc20
    11 205F-20F9> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5B +  MWA #MAIN.STRINGS_ADDRESS ECX
    13 2072 A9 7A 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: strings.asm
     1 5B00			strings_list
     2 5B00 0E 5B		    dta a(txt_0)
     3 5B02 28 5B		    dta a(txt_1)
     4 5B04 33 5B		    dta a(txt_2)
     5 5B06 3A 5B		    dta a(txt_3)
     6 5B08 49 5B		    dta a(txt_4)
     7 5B0A 5B 5B		    dta a(txt_5)
     8 5B0C 71 5B		    dta a(txt_6)
    10 5B0E			strings
    12 5B0E			txt_0
    13 5B0E 20 76 2E 30 2E 31 +     dta c' v.0.1 (c) 2019 MADRAFi. ',0
    14 5B28			txt_1
    15 5B28 5B 4E 5D 65 77 20 +     dta c'[N]ew Game',0
    16 5B33			txt_2
    17 5B33 5B 51 5D 75 69 74 +     dta c'[Q]uit',0
    18 5B3A			txt_3
    19 5B3A 5B 31 5D 20 4E 61 +     dta c'[1] Navigation',0
    20 5B49			txt_4
    21 5B49 5B 32 5D 20 54 72 +     dta c'[2] Trade Console',0
    22 5B5B			txt_5
    23 5B5B 5B 33 5D 20 52 65 +     dta c'[3] Repair/Refuel Pad',0
    24 5B71			txt_6
    25 5B71 5B 42 5D 20 42 61 +     dta c'[B] Back',0
    28 				 .print "STRINGS SIZE: ", *-strings_list
    28 				STRINGS SIZE: $007A
    29 				 .print "STRINGS : ", strings_list, "..", *
    29 				STRINGS : $5B00..$5B7A
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    86 20FA				RCASM 'locations.asm' LOCATIONS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 20FA				org RESORIGIN
     4 = 010D			len = .sizeof(_LOCATIONS_ADDRESS)
     6 				mcpy	ift main.LOCATIONS_ADDRESS+len >= $bc20
    11 205F-218C> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5C +  MWA #MAIN.LOCATIONS_ADDRESS ECX
    13 2072 A9 0D 85 82 A9 01 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: locations.asm
     1 5C00			locations_list
     2 5C00 1E 5C		    dta a(loc_0)
     3 5C02 2A 5C		    dta a(loc_1)
     4 5C04 33 5C		    dta a(loc_2)
     5 5C06 3F 5C		    dta a(loc_3)
     6 5C08 48 5C		    dta a(loc_4)
     7 5C0A 4F 5C		    dta a(loc_5)
     8 5C0C 67 5C		    dta a(loc_6)
     9 5C0E 7D 5C		    dta a(loc_7)
    10 5C10 96 5C		    dta a(loc_8)
    11 5C12 9F 5C		    dta a(loc_9)
    12 5C14 A9 5C		    dta a(loc_10)
    13 5C16 C1 5C		    dta a(loc_11)
    14 5C18 D5 5C		    dta a(loc_12)
    15 5C1A EC 5C		    dta a(loc_13)
    16 5C1C 02 5D		    dta a(loc_14)
    18 5C1E			locations
    19 5C1E			loc_0
    20 5C1E 50 6F 72 74 20 4F +     dta c'Port Olisar',0
    21 5C2A			loc_1
    22 5C2A 47 72 69 6D 20 48 +     dta c'Grim Hex',0
    23 5C33			loc_2
    24 5C33 43 6F 76 61 6C 65 +     dta c'Covalex Hub',0
    25 5C3F			loc_3
    26 5C3F 4C 6F 72 76 69 6C +     dta c'Lorville',0
    27 5C48			loc_4
    28 5C48 4C 65 76 73 6B 69 +     dta c'Levski',0
    29 5C4F			loc_5
    30 5C4F 41 72 63 43 6F 72 +     dta c'ArcCorp Mining Area 157',0
    31 5C67			loc_6
    32 5C67 42 65 6E 73 6F 6E +     dta c'Benson Mining Outpost',0
    33 5C7D			loc_7
    34 5C7D 44 65 61 6B 69 6E +     dta c'Deakins Research Outpost',0
    35 5C96			loc_8
    36 5C96 4A 75 6D 70 74 6F +     dta c'Jumptown',0
    37 5C9F			loc_9
    38 5C9F 4B 75 64 72 65 20 +     dta c'Kudre Ore',0
    39 5CA9			loc_10
    40 5CA9 41 72 63 43 6F 72 +     dta c'ArcCorp Mining Area 141',0
    41 5CC1			loc_11
    42 5CC1 48 61 72 76 65 73 +     dta c'Harvest Hydroponics',0
    43 5CD5			loc_12
    44 5CD5 53 68 75 62 69 6E +     dta c'Shubin Mining Facility',0
    45 5CEC			loc_13
    46 5CEC 54 65 72 72 61 20 +     dta c'Terra Mills HydroFarm',0
    47 5D02			loc_14
    48 5D02 52 26 52 20 43 52 +     dta c'R&R CRU-L1',0
    50 				 .print "LOCATIONS SIZE: ", *-locations_list
    50 				LOCATIONS SIZE: $010D
    51 				 .print "LOCATIONS : ", locations_list, "..", *
    51 				LOCATIONS : $5C00..$5D0D
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    87 218D				RCASM 'items.asm' ITEMS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 218D				org RESORIGIN
     4 = 00F4			len = .sizeof(_ITEMS_ADDRESS)
     6 				mcpy	ift main.ITEMS_ADDRESS+len >= $bc20
    11 205F-2173> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5E +  MWA #MAIN.ITEMS_ADDRESS ECX
    13 2072 A9 F4 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: items.asm
     1 5E00			items_list
     2 5E00 2E 5E		    dta a(item_0)
     3 5E02 37 5E		    dta a(item_1)
     4 5E04 46 5E		    dta a(item_2)
     5 5E06 4F 5E		    dta a(item_3)
     6 5E08 58 5E		    dta a(item_4)
     7 5E0A 5E 5E		    dta a(item_5)
     8 5E0C 67 5E		    dta a(item_6)
     9 5E0E 70 5E		    dta a(item_7)
    10 5E10 78 5E		    dta a(item_8)
    11 5E12 80 5E		    dta a(item_9)
    12 5E14 89 5E		    dta a(item_10)
    13 5E16 8E 5E		    dta a(item_11)
    14 5E18 97 5E		    dta a(item_12)
    15 5E1A 9E 5E		    dta a(item_13)
    16 5E1C A7 5E		    dta a(item_14)
    17 5E1E B4 5E		    dta a(item_15)
    18 5E20 C3 5E		    dta a(item_16)
    19 5E22 CA 5E		    dta a(item_17)
    20 5E24 D0 5E		    dta a(item_18)
    21 5E26 D6 5E		    dta a(item_19)
    22 5E28 DF 5E		    dta a(item_20)
    23 5E2A E8 5E		    dta a(item_21)
    24 5E2C EE 5E		    dta a(item_22)
    26 5E2E			items
    27 5E2E			item_0
    28 5E2E 41 67 72 69 63 69 +     dta c'Agricium',0
    29 5E37			item_1
    30 5E37 41 67 72 69 63 75 +     dta c'Agricult. Sup.',0
    31 5E46			item_2
    32 5E46 41 6C 75 6D 69 6E +     dta c'Aluminum',0
    33 5E4F			item_3
    34 5E4F 41 73 74 61 74 69 +     dta c'Astatine',0
    35 5E58			item_4
    36 5E58 42 65 72 79 6C 00	    dta c'Beryl',0
    37 5E5E			item_5
    38 5E5E 43 68 6C 6F 72 69 +     dta c'Chlorine',0
    39 5E67			item_6
    40 5E67 43 6F 72 75 6E 64 +     dta c'Corundum',0
    41 5E70			item_7
    42 5E70 44 69 61 6D 6F 6E +     dta c'Diamond',0
    43 5E78			item_8
    44 5E78 53 70 69 72 69 74 +     dta c'Spirits',0
    45 5E80			item_9
    46 5E80 46 6C 75 6F 72 69 +     dta c'Fluorine',0
    47 5E89			item_10
    48 5E89 47 6F 6C 64 00	    dta c'Gold',0
    49 5E8E			item_11
    50 5E8E 48 79 64 72 6F 67 +     dta c'Hydrogen',0
    51 5E97			item_12
    52 5E97 49 6F 64 69 6E 65 +     dta c'Iodine',0
    53 5E9E			item_13
    54 5E9E 4C 61 72 61 6E 69 +     dta c'Laranite',0
    55 5EA7			item_14
    56 5EA7 4D 65 64 69 63 61 +     dta c'Medical Sup.',0
    57 5EB4			item_15
    58 5EB4 50 72 6F 63 65 73 +     dta c'Processed Food',0
    59 5EC3			item_16
    60 5EC3 51 75 61 72 74 7A +     dta c'Quartz',0
    61 5ECA			item_17
    62 5ECA 53 63 72 61 70 00	    dta c'Scrap',0
    63 5ED0			item_18
    64 5ED0 53 74 69 6D 73 00	    dta c'Stims',0
    65 5ED6			item_19
    66 5ED6 54 69 74 61 6E 69 +     dta c'Titanium',0
    67 5EDF			item_20
    68 5EDF 54 75 6E 67 73 74 +     dta c'Tungsten',0
    69 5EE8			item_21
    70 5EE8 57 61 73 74 65 00	    dta c'Waste',0
    71 5EEE			item_22
    72 5EEE 57 69 64 6F 77 00	    dta c'Widow',0
    74 				 .print "ITEMS SIZE: ", *-items_list
    74 				ITEMS SIZE: $00F4
    75 				 .print "ITEMS : ", items_list, "..", *
    75 				ITEMS : $5E00..$5EF4
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    88 2174				RMTPLAY 'assets/titlemusic.feat' RMT_PLAYER_ADDRESS 1 0 0 0 0 0 0 0
Macro: RESOURCE.RMTPLAY [Source: res6502.asm]
     2 = 0001			STEREOMODE	= 1
     3 = 8A00			PLAYER		= main.RMT_PLAYER_ADDRESS
Source: rmt_player.asm
    25 = 0008			TRACKS		equ 8
    37 2174				org $e0
    38 00E0			p_tis
    39 00E0			p_instrstable	org *+2
    40 00E2			p_trackslbstable	org *+2
    41 00E4			p_trackshbstable	org *+2
    42 00E6			p_song			org *+2
    43 00E8			ns				org *+2
    44 00EA			nr				org *+2
    45 00EC			nt				org *+2
    46 00EE			reg1			org *+1
    47 00EF			reg2			org *+1
    48 00F0			reg3			org *+1
    49 00F1			tmp				org *+1
    54 00F2				org PLAYER-$400+$40
    58 8640			track_variables
    59 8640			trackn_db	org *+TRACKS
    60 8648			trackn_hb	org *+TRACKS
    61 8650			trackn_idx	org *+TRACKS
    62 8658			trackn_pause	org *+TRACKS
    63 8660			trackn_note	org *+TRACKS
    64 8668			trackn_volume	org *+TRACKS
    65 8670			trackn_distor 	org *+TRACKS
    66 8678			trackn_shiftfrq	org *+TRACKS
    74 8680			trackn_instrx2	org *+TRACKS
    75 8688			trackn_instrdb	org *+TRACKS
    76 8690			trackn_instrhb	org *+TRACKS
    77 8698			trackn_instridx	org *+TRACKS
    78 86A0			trackn_instrlen	org *+TRACKS
    79 86A8			trackn_instrlop	org *+TRACKS
    80 86B0			trackn_instrreachend	org *+TRACKS
    81 86B8			trackn_volumeslidedepth org *+TRACKS
    82 86C0			trackn_volumeslidevalue org *+TRACKS
    84 86C8			trackn_volumemin		org *+TRACKS
    86 = 0000			FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
    96 86D0			trackn_tabletypespeed org *+TRACKS
   100 86D8			trackn_tablenote	org *+TRACKS
   101 86E0			trackn_tablea		org *+TRACKS
   102 86E8			trackn_tableend		org *+TRACKS
   104 86F0			trackn_tablelop		org *+TRACKS
   106 86F8			trackn_tablespeeda	org *+TRACKS
   116 8700			trackn_audf	org *+TRACKS
   117 8708			trackn_audc	org *+TRACKS
   121 8710			v_aspeed		org *+1
   122 8711			track_endvariables
   123 8711					org PLAYER-$100-$140-$40+2
   124 = 000C			INSTRPAR	equ 12
   125 8782			tabbeganddistor
   126 8782-8791> 80 00		 dta frqtabpure-frqtab,$00
   127 8784 80 20		 dta frqtabpure-frqtab,$20
   128 8786 80 40		 dta frqtabpure-frqtab,$40
   129 8788 00 C0		 dta frqtabbass1-frqtab,$c0
   130 878A 80 80		 dta frqtabpure-frqtab,$80
   131 878C 80 A0		 dta frqtabpure-frqtab,$a0
   132 878E 00 C0		 dta frqtabbass1-frqtab,$c0
   133 8790 40 C0		 dta frqtabbass2-frqtab,$c0
   146 8792					org PLAYER-$100-$140
   154 87C0					org PLAYER-$100-$100
   155 8800			frqtab
   157 8800			frqtabbass1
   158 8800-88BF> BF B6 AA A1 + 	dta $BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
   159 8810 98 8F 89 80 7A 71 + 	dta $98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
   160 8820 3C 38 35 32 2F 2D + 	dta $3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
   161 8830 17 16 14 13 12 11 + 	dta $17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
   162 8840			frqtabbass2
   163 8840 FF F1 E4 D8 CA C0 + 	dta $FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
   164 8850 66 61 5A 55 52 4B + 	dta $66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
   165 8860 28 25 24 21 1F 1E + 	dta $28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
   166 8870 0F 0E 0D 0C 0B 0A + 	dta $0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
   167 8880			frqtabpure
   168 8880 F3 E6 D9 CC C1 B5 + 	dta $F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
   169 8890 60 5B 55 51 4C 48 + 	dta $60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
   170 88A0 25 23 21 1F 1D 1C + 	dta $25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
   171 88B0 0E 0D 0C 0B 0A 09 + 	dta $0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
   179 88C0					org PLAYER-$0100
   180 8900			volumetab
   181 8900-8D80> 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   182 8910 00 00 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
   183 8920 00 00 00 00 01 01 + 	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
   184 8930 00 00 00 01 01 01 + 	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
   185 8940 00 00 01 01 01 01 + 	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
   186 8950 00 00 01 01 01 02 + 	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
   187 8960 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
   188 8970 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
   189 8980 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
   190 8990 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
   191 89A0 00 01 01 02 03 03 + 	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
   192 89B0 00 01 01 02 03 04 + 	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
   193 89C0 00 01 02 02 03 04 + 	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
   194 89D0 00 01 02 03 03 04 + 	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
   195 89E0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
   196 89F0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
   197 8A00				org PLAYER
   201 8A00			RASTERMUSICTRACKER
   202 8A00 4C D5 8B			jmp rmt_play
   204 8A03 4C 0F 8A			jmp rmt_init
   205 8A06 4C F9 8B			jmp rmt_p3
   206 8A09 4C 56 8A			jmp rmt_silence
   207 8A0C 4C 16 8D			jmp SetPokey
   211 8A0F			rmt_init
   212 8A0F 86 E8			stx ns
   213 8A11 84 E9			sty ns+1
   215 8A13 48				pha
   225 8A14 A0 D1			ldy #track_endvariables-track_variables
   226 8A16 A9 00			lda #0
   227 8A18 99 3F 86		ri0	sta track_variables-1,y
   228 8A1B 88				dey
   229 8A1C D0 FA			bne ri0
   231 8A1E A0 04			ldy #4
   232 8A20 B1 E8			lda (ns),y
   233 8A22 8D ED 8B			sta v_maxtracklen
   234 8A25 C8				iny
   236 8A26 B1 E8			lda (ns),y
   237 8A28 8D C5 8A			sta v_speed
   245 8A2B A9 03			lda #FEAT_INSTRSPEED
   246 8A2D 8D 14 8D			sta v_ainstrspeed
   248 8A30 A0 08			ldy #8
   249 8A32 B1 E8		ri1	lda (ns),y
   250 8A34 99 D8 00			sta p_tis-8,y
   251 8A37 C8				iny
   252 8A38 C0 10			cpy #8+8
   253 8A3A D0 F6			bne ri1
   255 8A3C 68				pla
   256 8A3D 48				pha
   258 8A3E 0A				asl @
   259 8A3F 0A				asl @
   260 8A40 0A				asl @
   261 8A41 18				clc
   262 8A42 65 E6			adc p_song
   263 8A44 85 E6			sta p_song
   264 8A46 68				pla
   265 8A47 08				php
   266 8A48 29 E0			and #$e0
   267 8A4A 0A				asl @
   268 8A4B 2A				rol @
   269 8A4C 2A				rol @
   270 8A4D 2A				rol @
   284 8A4E 28				plp
   285 8A4F 65 E7			adc p_song+1
   286 8A51 85 E7			sta p_song+1
   288 8A53 20 74 8A			jsr GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   289 8A56			rmt_silence
   291 8A56 A9 00			lda #0
   292 8A58 8D 08 D2			sta $d208
   293 8A5B 8D 18 D2			sta $d218
   294 8A5E A0 03			ldy #3
   295 8A60 8C 0F D2			sty $d20f
   296 8A63 8C 1F D2			sty $d21f
   297 8A66 A0 08			ldy #8
   298 8A68 99 00 D2		si1	sta $d200,y
   299 8A6B 99 10 D2			sta $d210,y
   300 8A6E 88				dey
   301 8A6F 10 F7			bpl si1
   315 8A71 A9 03			lda #FEAT_INSTRSPEED
   317 8A73 60				rts
   318 8A74			GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   319 8A74			GetSongLine
   320 8A74 A2 00			ldx #0
   321 8A76 8E EB 8B			stx v_abeat
   322 8A79			nn0
   323 8A79 8A			nn1	txa
   324 8A7A A8				tay
   325 8A7B B1 E6			lda (p_song),y
   326 8A7D C9 FE			cmp #$fe
   327 8A7F B0 2D			bcs nn2
   328 8A81 A8				tay
   329 8A82 B1 E2			lda (p_trackslbstable),y
   330 8A84 9D 40 86			sta trackn_db,x
   331 8A87 B1 E4			lda (p_trackshbstable),y
   332 8A89 9D 48 86		nn1a sta trackn_hb,x
   333 8A8C A9 00			lda #0
   334 8A8E 9D 50 86			sta trackn_idx,x
   335 8A91 A9 01			lda #1
   336 8A93 9D 58 86		nn1a2 sta trackn_pause,x
   337 8A96 A9 80			lda #$80
   338 8A98 9D 80 86			sta trackn_instrx2,x
   339 8A9B E8				inx
   340 8A9C E0 08		xtracks01	cpx #TRACKS
   341 8A9E D0 D9			bne nn1
   342 8AA0 A5 E6			lda p_song
   343 8AA2 18				clc
   344 8AA3 69 08		xtracks02	adc #TRACKS
   345 8AA5 85 E6			sta p_song
   346 8AA7 90 1B			bcc GetTrackLine
   347 8AA9 E6 E7			inc p_song+1
   348 8AAB			nn1b
   349 8AAB 4C C4 8A			jmp GetTrackLine
   350 8AAE			nn2
   351 8AAE F0 04			beq nn3
   352 8AB0			nn2a
   353 8AB0 A9 00			lda #0
   354 8AB2 F0 DF			beq nn1a2
   355 8AB4			nn3
   356 8AB4 A0 02			ldy #2
   357 8AB6 B1 E6			lda (p_song),y
   358 8AB8 AA				tax
   359 8AB9 C8				iny
   360 8ABA B1 E6			lda (p_song),y
   361 8ABC 85 E7			sta p_song+1
   362 8ABE 86 E6			stx p_song
   363 8AC0 A2 00			ldx #0
   364 8AC2 F0 B5			beq nn0
   365 8AC4			GetTrackLine
   366 8AC4			oo0
   367 8AC4			oo0a
   369 8AC4 A9 FF			lda #$ff
   370 = 8AC5			v_speed equ *-1
   371 8AC6 8D 1F 8B			sta v_bspeed
   373 8AC9 A2 FF			ldx #-1
   374 8ACB			oo1
   375 8ACB E8				inx
   376 8ACC DE 58 86			dec trackn_pause,x
   377 8ACF D0 49			bne oo1x
   378 8AD1			oo1b
   379 8AD1 BD 40 86			lda trackn_db,x
   380 8AD4 85 E8			sta ns
   381 8AD6 BD 48 86			lda trackn_hb,x
   382 8AD9 85 E9			sta ns+1
   383 8ADB			oo1i
   384 8ADB BC 50 86			ldy trackn_idx,x
   385 8ADE FE 50 86			inc trackn_idx,x
   386 8AE1 B1 E8			lda (ns),y
   387 8AE3 85 EE			sta reg1
   388 8AE5 29 3F			and #$3f
   389 8AE7 C9 3D			cmp #61
   390 8AE9 F0 0E			beq oo1a
   391 8AEB B0 3C			bcs oo2
   392 8AED 9D 60 86			sta trackn_note,x
   396 8AF0 C8				iny
   397 8AF1 B1 E8			lda (ns),y
   398 8AF3 4A				lsr @
   399 8AF4 29 7E			and #$3f*2
   400 8AF6 9D 80 86			sta trackn_instrx2,x
   401 8AF9			oo1a
   402 8AF9 A9 01			lda #1
   403 8AFB 9D 58 86			sta trackn_pause,x
   404 8AFE BC 50 86			ldy trackn_idx,x
   405 8B01 FE 50 86			inc trackn_idx,x
   406 8B04 B1 E8			lda (ns),y
   407 8B06 4A				lsr @
   408 8B07 66 EE			ror reg1
   409 8B09 4A				lsr @
   410 8B0A 66 EE			ror reg1
   411 8B0C A5 EE			lda reg1
   413 8B0E 38				sec
   414 8B0F E9 00			sbc #$00
   415 = 8B10			RMTGLOBALVOLUMEFADE equ *-1
   416 8B11 B0 02			bcs voig
   417 8B13 A9 00			lda #0
   418 8B15			voig
   420 8B15 29 F0			and #$f0
   421 8B17 9D 68 86			sta trackn_volume,x
   422 8B1A			oo1x
   423 8B1A E0 07		xtracks03sub1	cpx #TRACKS-1
   424 8B1C D0 AD			bne oo1
   426 8B1E A9 FF			lda #$ff
   427 = 8B1F			v_bspeed equ *-1
   428 8B20 8D C5 8A			sta v_speed
   432 8B23 8D 10 87			sta v_aspeed
   433 8B26 4C 6E 8B			jmp InitOfNewSetInstrumentsOnly
   434 8B29			oo2
   435 8B29 C9 3F			cmp #63
   436 8B2B F0 1B			beq oo63
   437 8B2D A5 EE			lda reg1
   438 8B2F 29 C0			and #$c0
   439 8B31 F0 09			beq oo62_b
   440 8B33 0A				asl @
   441 8B34 2A				rol @
   442 8B35 2A				rol @
   443 8B36 9D 58 86			sta trackn_pause,x
   444 8B39 4C 1A 8B			jmp oo1x
   445 8B3C			oo62_b
   446 8B3C C8				iny
   447 8B3D B1 E8			lda (ns),y
   448 8B3F 9D 58 86			sta trackn_pause,x
   449 8B42 FE 50 86			inc trackn_idx,x
   450 8B45 4C 1A 8B			jmp oo1x
   451 8B48			oo63
   452 8B48 A5 EE			lda reg1
   454 8B4A 30 0C			bmi oo63_1X
   455 8B4C C8				iny
   456 8B4D B1 E8			lda (ns),y
   457 8B4F 8D 1F 8B			sta v_bspeed
   458 8B52 FE 50 86			inc trackn_idx,x
   459 8B55 4C DB 8A			jmp oo1i
   460 8B58			oo63_1X
   462 8B58 C9 FF			cmp #255
   463 8B5A F0 09			beq oo63_11
   464 8B5C C8				iny
   465 8B5D B1 E8			lda (ns),y
   466 8B5F 9D 50 86			sta trackn_idx,x
   467 8B62 4C DB 8A			jmp oo1i
   468 8B65			oo63_11
   469 8B65 4C 74 8A			jmp GetSongLine
   470 8B68 4C F9 8B		p2xrmtp3	jmp rmt_p3
   471 8B6B CA			p2x0 dex
   472 8B6C 30 FA			 bmi p2xrmtp3
   473 8B6E			InitOfNewSetInstrumentsOnly
   474 8B6E BC 80 86		p2x1 ldy trackn_instrx2,x
   475 8B71 30 F8			bmi p2x0
   488 8B73			SetUpInstrumentY2
   489 8B73 B1 E0			lda (p_instrstable),y
   490 8B75 9D 88 86			sta trackn_instrdb,x
   491 8B78 85 EC			sta nt
   492 8B7A C8				iny
   493 8B7B B1 E0			lda (p_instrstable),y
   494 8B7D 9D 90 86			sta trackn_instrhb,x
   495 8B80 85 ED			sta nt+1
   504 8B82 A0 01			ldy #1
   506 8B84 B1 EC			lda (nt),y
   507 8B86 9D F0 86			sta trackn_tablelop,x
   508 8B89 C8				iny
   512 8B8A B1 EC			lda (nt),y
   513 8B8C 9D A0 86			sta trackn_instrlen,x
   514 8B8F C8				iny
   515 8B90 B1 EC			lda (nt),y
   516 8B92 9D A8 86			sta trackn_instrlop,x
   517 8B95 C8				iny
   518 8B96 B1 EC			lda (nt),y
   519 8B98 9D D0 86			sta trackn_tabletypespeed,x
   521 8B9B 29 3F			and #$3f
   523 8B9D 9D F8 86			sta trackn_tablespeeda,x
   535 8BA0 A0 06			ldy #6
   537 8BA2 B1 EC			lda (nt),y
   538 8BA4 9D B8 86			sta trackn_volumeslidedepth,x
   540 8BA7 C8				iny
   541 8BA8 B1 EC			lda (nt),y
   542 8BAA 9D C8 86			sta trackn_volumemin,x
   567 8BAD A9 80			lda #128
   568 8BAF 9D C0 86			sta trackn_volumeslidevalue,x
   569 8BB2 9D 80 86			sta trackn_instrx2,x
   570 8BB5 0A				asl @
   571 8BB6 9D B0 86			sta trackn_instrreachend,x
   572 8BB9 9D 78 86			sta trackn_shiftfrq,x
   573 8BBC A8				tay
   574 8BBD B1 EC			lda (nt),y
   575 8BBF 9D E8 86			sta trackn_tableend,x
   576 8BC2 69 00			adc #0
   577 8BC4 9D 98 86			sta trackn_instridx,x
   578 8BC7 A9 0C			lda #INSTRPAR
   579 8BC9 9D E0 86			sta trackn_tablea,x
   580 8BCC A8				tay
   581 8BCD B1 EC			lda (nt),y
   582 8BCF 9D D8 86			sta trackn_tablenote,x
   583 8BD2			xata_rtshere
   587 8BD2 4C 6B 8B			jmp p2x0
   589 8BD5			rmt_play
   590 8BD5			rmt_p0
   591 8BD5 20 16 8D			jsr SetPokey
   592 8BD8			rmt_p1
   594 8BD8 CE 14 8D			dec v_ainstrspeed
   595 8BDB D0 1C			bne rmt_p3
   602 8BDD A9 03			lda #FEAT_INSTRSPEED
   603 8BDF 8D 14 8D			sta v_ainstrspeed
   605 8BE2			rmt_p2
   606 8BE2 CE 10 87			dec v_aspeed
   607 8BE5 D0 12			bne rmt_p3
   608 8BE7 EE EB 8B			inc v_abeat
   609 8BEA A9 FF			lda #$ff
   610 = 8BEB			v_abeat equ *-1
   611 8BEC C9 FF			cmp #$ff
   612 = 8BED			v_maxtracklen equ *-1
   613 8BEE F0 03			beq p2o3
   614 8BF0 4C C4 8A			jmp GetTrackLine
   615 8BF3			p2o3
   616 8BF3 4C 74 8A			jmp GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   617 8BF6 4C FD 8C		go_ppnext	jmp ppnext
   618 8BF9			rmt_p3
   619 8BF9 A9 88			lda #>frqtab
   620 8BFB 85 EB			sta nr+1
   621 8BFD A2 07		xtracks05sub1	ldx #TRACKS-1
   622 8BFF			pp1
   623 8BFF BD 90 86			lda trackn_instrhb,x
   624 8C02 F0 F2			beq go_ppnext
   625 8C04 85 E9			sta ns+1
   626 8C06 BD 88 86			lda trackn_instrdb,x
   627 8C09 85 E8			sta ns
   628 8C0B BC 98 86			ldy trackn_instridx,x
   629 8C0E B1 E8			lda (ns),y
   630 8C10 85 EE			sta reg1
   631 8C12 C8				iny
   632 8C13 B1 E8			lda (ns),y
   633 8C15 85 EF			sta reg2
   634 8C17 C8				iny
   635 8C18 B1 E8			lda (ns),y
   636 8C1A 85 F0			sta reg3
   637 8C1C C8				iny
   638 8C1D 98				tya
   639 8C1E DD A0 86			cmp trackn_instrlen,x
   640 8C21 90 0A			bcc pp2
   641 8C23 F0 08			beq pp2
   642 8C25 A9 80			lda #$80
   643 8C27 9D B0 86			sta trackn_instrreachend,x
   644 8C2A			pp1b
   645 8C2A BD A8 86			lda trackn_instrlop,x
   646 8C2D 9D 98 86		pp2	sta trackn_instridx,x
   647 8C30 A5 EE			lda reg1
   649 8C32 E0 04			cpx #4
   650 8C34 90 04			bcc pp2s
   651 8C36 4A				lsr @
   652 8C37 4A				lsr @
   653 8C38 4A				lsr @
   654 8C39 4A				lsr @
   655 8C3A			pp2s
   657 8C3A 29 0F			and #$0f
   658 8C3C 1D 68 86			ora trackn_volume,x
   659 8C3F A8				tay
   660 8C40 B9 00 89			lda volumetab,y
   661 8C43 85 F1			sta tmp
   662 8C45 A5 EF			lda reg2
   663 8C47 29 0E			and #$0e
   664 8C49 A8				tay
   665 8C4A B9 82 87			lda tabbeganddistor,y
   666 8C4D 85 EA			sta nr
   667 8C4F A5 F1			lda tmp
   668 8C51 19 83 87			ora tabbeganddistor+1,y
   669 8C54 9D 08 87			sta trackn_audc,x
   670 8C57			InstrumentsEffects
   696 8C57 BC E8 86			ldy trackn_tableend,x
   697 8C5A C0 0D			cpy #INSTRPAR+1
   698 8C5C 90 33			bcc ei3
   699 8C5E BD F8 86			lda trackn_tablespeeda,x
   700 8C61 10 28			bpl ei2f
   701 8C63			ei2c
   702 8C63 98				tya
   703 8C64 DD E0 86			cmp trackn_tablea,x
   704 8C67 D0 08			bne ei2c2
   706 8C69 BD F0 86			lda trackn_tablelop,x
   710 8C6C 9D E0 86			sta trackn_tablea,x
   711 8C6F D0 03			bne ei2a
   712 8C71			ei2c2
   713 8C71 FE E0 86			inc trackn_tablea,x
   714 8C74			ei2a
   715 8C74 BD 88 86			lda trackn_instrdb,x
   716 8C77 85 EC			sta nt
   717 8C79 BD 90 86			lda trackn_instrhb,x
   718 8C7C 85 ED			sta nt+1
   719 8C7E BC E0 86			ldy trackn_tablea,x
   720 8C81 B1 EC			lda (nt),y
   728 8C83 9D D8 86			sta trackn_tablenote,x
   729 8C86 BD D0 86			lda trackn_tabletypespeed,x
   731 8C89 29 3F			and #$3f
   733 8C8B			ei2f
   734 8C8B 38				sec
   735 8C8C E9 01			sbc #1
   736 8C8E 9D F8 86			sta trackn_tablespeeda,x
   737 8C91			ei3
   738 8C91 BD B0 86			lda trackn_instrreachend,x
   739 8C94 10 1F			bpl ei4
   740 8C96 BD 68 86			lda trackn_volume,x
   741 8C99 F0 1A			beq ei4
   743 8C9B DD C8 86			cmp trackn_volumemin,x
   744 8C9E F0 15			beq ei4
   745 8CA0 90 13			bcc ei4
   747 8CA2 A8				tay
   748 8CA3 BD C0 86			lda trackn_volumeslidevalue,x
   749 8CA6 18				clc
   750 8CA7 7D B8 86			adc trackn_volumeslidedepth,x
   751 8CAA 9D C0 86			sta trackn_volumeslidevalue,x
   752 8CAD 90 06			bcc ei4
   753 8CAF 98				tya
   754 8CB0 E9 10			sbc #16
   755 8CB2 9D 68 86			sta trackn_volume,x
   756 8CB5			ei4
   762 8CB5 A5 EF			lda reg2
   766 8CB7 29 70			and #$70
   768 8CB9 F0 05			beq cmd0
   808 8CBB			cmd1
   810 8CBB A5 F0			lda reg3
   811 8CBD 4C FA 8C			jmp cmd0c
   813 8CC0			cmd2
   820 8CC0			cmd3
   828 8CC0			cmd4
   837 8CC0			cmd5
   880 8CC0			cmd6
   892 8CC0			cmd7
   912 8CC0			cmd0
   913 8CC0 BD 60 86			lda trackn_note,x
   914 8CC3 18				clc
   915 8CC4 65 F0			adc reg3
   916 8CC6			cmd0a
   918 8CC6 BC D0 86			ldy trackn_tabletypespeed,x
   919 8CC9 30 19			bmi cmd0b
   921 8CCB 18				clc
   922 8CCC 7D D8 86			adc trackn_tablenote,x
   923 8CCF C9 3D			cmp #61
   924 8CD1 90 07			bcc cmd0a1
   925 8CD3 A9 00			lda #0
   926 8CD5 9D 08 87			sta trackn_audc,x
   927 8CD8 A9 3F			lda #63
   928 8CDA			cmd0a1
   932 8CDA A8				tay
   933 8CDB B1 EA			lda (nr),y
   934 8CDD 18				clc
   935 8CDE 7D 78 86			adc trackn_shiftfrq,x
   941 8CE1 4C FA 8C			jmp cmd0c
   942 8CE4			cmd0b
   943 8CE4 C9 3D			cmp #61
   944 8CE6 90 07			bcc cmd0b1
   945 8CE8 A9 00			lda #0
   946 8CEA 9D 08 87			sta trackn_audc,x
   947 8CED A9 3F			lda #63
   948 8CEF			cmd0b1
   949 8CEF A8				tay
   950 8CF0 BD 78 86			lda trackn_shiftfrq,x
   951 8CF3 18				clc
   952 8CF4 7D D8 86			adc trackn_tablenote,x
   953 8CF7 18				clc
   954 8CF8 71 EA			adc (nr),y
   960 8CFA			cmd0c
   961 8CFA 9D 00 87			sta trackn_audf,x
   962 8CFD			pp9
   998 8CFD			ppnext
   999 8CFD CA				dex
  1000 8CFE 30 03			bmi rmt_p4
  1001 8D00 4C FF 8B			jmp pp1
  1002 8D03			rmt_p4
  1010 8D03 A2 00			ldx #0
  1012 8D05			qq1
  1013 8D05 8E 79 8D			stx v_audctl
  1119 8D08			qq5
  1120 8D08 8E 79 8D			stx v_audctl
  1129 8D0B A2 00			ldx #0
  1131 8D0D 8E 17 8D			stx v_audctl2
  1237 8D10			qs5
  1238 8D10 8E 17 8D			stx v_audctl2
  1240 8D13			rmt_p5
  1242 8D13 A9 FF			lda #$ff
  1243 = 8D14			v_ainstrspeed equ *-1
  1247 8D15 60				rts
  1248 8D16			SetPokey
  1250 8D16 A0 FF			ldy #$ff
  1251 = 8D17			v_audctl2 equ *-1
  1252 8D18 AD 04 87			lda trackn_audf+0+4
  1253 8D1B AE 00 87			ldx trackn_audf+0
  1254 8D1E 8D 10 D2		xstastx01	sta $d210
  1255 8D21 8E 00 D2			stx $d200
  1256 8D24 AD 0C 87			lda trackn_audc+0+4
  1257 8D27 AE 08 87			ldx trackn_audc+0
  1258 8D2A 8D 11 D2		xstastx02	sta $d211
  1259 8D2D 8E 01 D2			stx $d201
  1260 8D30 AD 05 87			lda trackn_audf+1+4
  1261 8D33 AE 01 87			ldx trackn_audf+1
  1262 8D36 8D 12 D2		xstastx03	sta $d212
  1263 8D39 8E 02 D2			stx $d202
  1264 8D3C AD 0D 87			lda trackn_audc+1+4
  1265 8D3F AE 09 87			ldx trackn_audc+1
  1266 8D42 8D 13 D2		xstastx04	sta $d213
  1267 8D45 8E 03 D2			stx $d203
  1268 8D48 AD 06 87			lda trackn_audf+2+4
  1269 8D4B AE 02 87			ldx trackn_audf+2
  1270 8D4E 8D 14 D2		xstastx05	sta $d214
  1271 8D51 8E 04 D2			stx $d204
  1272 8D54 AD 0E 87			lda trackn_audc+2+4
  1273 8D57 AE 0A 87			ldx trackn_audc+2
  1274 8D5A 8D 15 D2		xstastx06	sta $d215
  1275 8D5D 8E 05 D2			stx $d205
  1276 8D60 AD 07 87			lda trackn_audf+3+4
  1277 8D63 AE 03 87			ldx trackn_audf+3
  1278 8D66 8D 16 D2		xstastx07	sta $d216
  1279 8D69 8E 06 D2			stx $d206
  1280 8D6C AD 0F 87			lda trackn_audc+3+4
  1281 8D6F AE 0B 87			ldx trackn_audc+3
  1282 8D72 8D 17 D2		xstastx08	sta $d217
  1283 8D75 8E 07 D2			stx $d207
  1284 8D78 A9 FF			lda #$ff
  1285 = 8D79			v_audctl equ *-1
  1286 8D7A 8C 18 D2		xstysta01	sty $d218
  1287 8D7D 8D 08 D2			sta $d208
  1356 8D80 60				rts
  1357 8D81			RMTPLAYEREND
Source: titlemusic.feat
     2 = 0000			FEAT_SFX		equ 0
     3 = 0001			FEAT_GLOBALVOLUMEFADE	equ 1		;RMTGLOBALVOLUMEFADE variable
     4 = 0000			FEAT_NOSTARTINGSONGLINE	equ 0
     5 = 0003			FEAT_INSTRSPEED		equ 3
     6 = 0000			FEAT_CONSTANTSPEED		equ 0		;(22 times)
     7 = 0001			FEAT_COMMAND1		equ 1		;(60 times)
     8 = 0000			FEAT_COMMAND2		equ 0		;(0 times)
     9 = 0000			FEAT_COMMAND3		equ 0		;(0 times)
    10 = 0000			FEAT_COMMAND4		equ 0		;(0 times)
    11 = 0000			FEAT_COMMAND5		equ 0		;(0 times)
    12 = 0000			FEAT_COMMAND6		equ 0		;(0 times)
    13 = 0000			FEAT_COMMAND7SETNOTE		equ 0		;(0 times)
    14 = 0000			FEAT_COMMAND7VOLUMEONLY		equ 0		;(0 times)
    15 = 0000			FEAT_PORTAMENTO		equ 0		;(0 times)
    16 = 0000			FEAT_FILTER		equ 0		;(0 times)
    17 = 0000			FEAT_FILTERG0L		equ 0		;(0 times)
    18 = 0000			FEAT_FILTERG1L		equ 0		;(0 times)
    19 = 0000			FEAT_FILTERG0R		equ 0		;(0 times)
    20 = 0000			FEAT_FILTERG1R		equ 0		;(0 times)
    21 = 0000			FEAT_BASS16		equ 0		;(0 times)
    22 = 0000			FEAT_BASS16G1L		equ 0		;(0 times)
    23 = 0000			FEAT_BASS16G3L		equ 0		;(0 times)
    24 = 0000			FEAT_BASS16G1R		equ 0		;(0 times)
    25 = 0000			FEAT_BASS16G3R		equ 0		;(0 times)
    26 = 0000			FEAT_VOLUMEONLYG0L		equ 0		;(0 times)
    27 = 0000			FEAT_VOLUMEONLYG2L		equ 0		;(0 times)
    28 = 0000			FEAT_VOLUMEONLYG3L		equ 0		;(0 times)
    29 = 0000			FEAT_VOLUMEONLYG0R		equ 0		;(0 times)
    30 = 0000			FEAT_VOLUMEONLYG2R		equ 0		;(0 times)
    31 = 0000			FEAT_VOLUMEONLYG3R		equ 0		;(0 times)
    32 = 0001			FEAT_TABLETYPE		equ 1		;(4 times)
    33 = 0000			FEAT_TABLEMODE		equ 0		;(0 times)
    34 = 0001			FEAT_TABLEGO		equ 1		;(4 times)
    35 = 0000			FEAT_AUDCTLMANUALSET		equ 0		;(0 times)
    36 = 0001			FEAT_VOLUMEMIN		equ 1		;(2 times)
    37 = 0000			FEAT_EFFECTVIBRATO		equ 0		;(0 times)
    38 = 0000			FEAT_EFFECTFSHIFT		equ 0		;(0 times)
    13 					.echo 'RMTPLAYER: ',track_variables,'..',RMTPLAYEREND
    13 				RMTPLAYER: $8640..$8D81
Source: starvagrant.a65
    89 8D81				RMT 'assets/titlemusic.rmt' RMT_MODULE_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RMT [Source: res6502.asm]
     2 = 1784			len = .filesize('assets/titlemusic.rmt')
    26 8D81				org main.RMT_MODULE_ADDRESS
     2 9200				.get [$100] 'assets/titlemusic.rmt',0,6				// wczytujemy plik do bufora MADS'a
     6 = 9200			new_add = MAIN.RMT_MODULE_ADDRESS						// nowy adres dla modulu RMT
     8 = 4000			old_add	= .wget[$102]					// stary adres modulu RMT
    10 = 177E			length	= .wget[$104] - old_add + 1			// dlugosc pliku RMT bez naglowka DOS'u
    12 = 5200			ofset	= new_add-old_add
    14 9200				.get [old_add-6] 'assets/titlemusic.rmt'
    16  [3FFC] 00			.put[old_add-4] = .lo(new_add)			// poprawiamy nag³ówek DOS'a
    17  [3FFD] 92			.put[old_add-3] = .hi(new_add)			// tak aby zawieral informacje o nowym
    19  [3FFE] 7D			.put[old_add-2] = .lo(new_add + length - 1)	// adresie modulu RMT
    20  [3FFF] A9			.put[old_add-1] = .hi(new_add + length - 1)
    22 = 0034			type	= .get[old_add+3]
    24 = 4010			pinst	= .get[old_add+8] + .get[old_add+9]<<8
    25 = 4030			pltrc	= .get[old_add+10] + .get[old_add+11]<<8
    26 = 4069			phtrc	= .get[old_add+12] + .get[old_add+13]<<8
    27 = 56CA			ptlst	= .get[old_add+14] + .get[old_add+15]<<8
    29  [4008] 10			.put[old_add+8] = .lo(pinst+ofset)
    30  [4009] 92			.put[old_add+9] = .hi(pinst+ofset)
    32  [400A] 30			.put[old_add+10] = .lo(pltrc+ofset)
    33  [400B] 92			.put[old_add+11] = .hi(pltrc+ofset)
    35  [400C] 69			.put[old_add+12] = .lo(phtrc+ofset)
    36  [400D] 92			.put[old_add+13] = .hi(phtrc+ofset)
    38  [400E] CA			.put[old_add+14] = .lo(ptlst+ofset)
    39  [400F] A8			.put[old_add+15] = .hi(ptlst+ofset)
    43 = 40A2				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4010] A2			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4011] 92			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 40CA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4012] CA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4013] 92			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4107				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4014] 07			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4015] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4138				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4016] 38			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4017] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 414E				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4018] 4E			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4019] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 416D				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401A] 6D			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401B] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 418C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401C] 8C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401D] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 41DA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401E] DA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401F] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4228				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4020] 28			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4021] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 427B				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4022] 7B			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4023] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 428E				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4024] 8E			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4025] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 42DA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4026] DA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4027] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 42FB				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4028] FB			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4029] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 431C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402A] 1C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402B] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 436A				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402C] 6A			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402D] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 43B8				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402E] B8			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402F] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    52 = 440C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4030] 0C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4069] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4412				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4031] 12			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406A] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4425				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4032] 25			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406B] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 445B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4033] 5B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406C] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 44B3				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4034] B3			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406D] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 450E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4035] 0E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406E] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4570				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4036] 70			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406F] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 45D1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4037] D1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4070] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 460A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4038] 0A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4071] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4678				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4039] 78			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4072] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 46E1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403A] E1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4073] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4746				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403B] 46			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4074] 99			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 47C8				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403C] C8			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4075] 99			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4846				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403D] 46			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4076] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 48B2				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403E] B2			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4077] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 48D4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403F] D4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4078] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 490C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4040] 0C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4079] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4973				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4041] 73			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407A] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 49D4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4042] D4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407B] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4A26				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4043] 26			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407C] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4A87				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4044] 87			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407D] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4AEE				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4045] EE			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407E] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4B40				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4046] 40			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407F] 9D			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4BAC				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4047] AC			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4080] 9D			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4C10				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4048] 10			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4081] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4C8C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4049] 8C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4082] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4CEE				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404A] EE			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4083] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D2C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404B] 2C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4084] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D7E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404C] 7E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4085] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D83				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404D] 83			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4086] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D87				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404E] 87			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4087] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D99				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404F] 99			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4088] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4E15				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4050] 15			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4089] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4E7E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4051] 7E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408A] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4EFA				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4052] FA			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408B] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4F6A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4053] 6A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408C] A1			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4FDB				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4054] DB			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408D] A1			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5052				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4055] 52			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408E] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 50C9				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4056] C9			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408F] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 50CD				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4057] CD			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4090] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 510B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4058] 0B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4091] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5110				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4059] 10			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4092] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 518C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405A] 8C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4093] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5205				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405B] 05			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4094] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 525E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405C] 5E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4095] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 52AF				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405D] AF			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4096] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5306				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405E] 06			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4097] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5357				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405F] 57			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4098] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 53B1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4060] B1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4099] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 540B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4061] 0B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409A] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5484				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4062] 84			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409B] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 54DF				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4063] DF			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409C] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5523				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4064] 23			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409D] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5585				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4065] 85			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409E] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 55E4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4066] E4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409F] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 562A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4067] 2A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [40A0] A8			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 566F				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4068] 6F			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [40A1] A8			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    66 = 0004				skip=4
    70 = 5776				?TMP = .GET[PTLST+#*SKIP+2] + .GET[PTLST+#*SKIP+3]<<8
    70  [577C] 76			.PUT[PTLST+#*SKIP+2] = .LO(?TMP+OFSET)
    70  [577D] A9			.PUT[PTLST+#*SKIP+3] = .HI(?TMP+OFSET)
    29 A97E			_end
Source: starvagrant.a65
    90 A97E				RCDATA 'assets/StarVagrand-3.dat' GFX_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0FA4			len = .filesize('assets/StarVagrand-3.dat')
    17 A97E				org main.GFX_ADDRESS
    19 7000-7FA3> 00 00 00 00 + 	ins 'assets/StarVagrand-3.dat'
Source: starvagrant.a65
    91 				.endl
    92
    93 				; -----------------------------------------------------------
    94
    95 7FA4				org CODEORIGIN
    96
    97 2000				STATICDATA
Macro: STATICDATA [Source: starvagrant.a65]
     1 2000-37C3> 03 4C 3A 20 + .by  $03 $4C $3A $20 $00 $19 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23
     2 2018 23 23 23 23 23 23 + .by  $23 $23 $23 $23 $23 $23 $23 $00  $04 $20 $55 $45 $43 $00 $0C $20  $5B $42 $75 $79 $5D $20 $53 $65
     3 2030 6C 6C 20 00 28 2D + .by  $6C $6C $20 $00 $28 $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
     4 2048 2D 2D 2D 2D 2D 2D + .by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $00 $28 $2F
     5 2060 44 65 6C 69 76 65 + .by  $44 $65 $6C $69 $76 $65 $72 $79  $5F $4C $6F $63 $61 $74 $69 $6F  $6E $73 $20 $7C $20 $2E $2E $2F
     6 2078 41 76 61 69 6C 61 + .by  $41 $76 $61 $69 $6C $61 $62 $6C  $65 $5F $49 $74 $65 $6D $73 $00  $28 $5B $20 $43 $75 $74 $74 $6C
     7 2090 65 73 20 42 6C 61 + .by  $65 $73 $20 $42 $6C $61 $63 $6B  $20 $5D $20 $20 $20 $7C $20 $63  $6F $6D $6D $6F $64 $69 $74 $79
     8 20A8 20 20 20 20 70 72 + .by  $20 $20 $20 $20 $70 $72 $69 $63  $65 $00 $28 $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
     9 20C0 2D 2D 2D 2D 2D 2D + .by  $2D $2D $2D $2D $2D $2D $2D $2B  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
    10 20D8 2D 2D 2D 00 0C 54 + .by  $2D $2D $2D $00 $0C $54 $6F $74  $61 $6C $20 $43 $61 $72 $67 $6F  $20 $00 $04 $34 $36 $20 $7C $00
    11 20F0 0C 45 6D 70 74 79 + .by  $0C $45 $6D $70 $74 $79 $20 $43  $61 $72 $67 $6F $20 $00 $0D $5B  $43 $61 $6E $63 $65 $6C $5D $20
    12 2108 5B 4F 4B 5D 00	.by  $5B $4F $4B $5D $00
Source: starvagrant.a65
    98
    99 210D			START
   100 210D BA				tsx
   101 210E 8E 54 2D			stx MAIN.@halt+1
   102
   103 					.ifdef fmulinit
   104 					fmulinit
   105 					eif
   106
   107 					ift DATAORIGIN+VARINITSIZE > $BFFF
   108 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   109 					els
   110 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   110 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   110 2111 A9 C4 85 86 A9 37 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   110 2119 A9 03 85 8A A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   110 2121 A9 00 85 82		 MVA #0 @FILL.PTR2
   110 2125 20 D4 2F		 JSR @FILL
   111 					eif
   112
   113 2128 A2 0F			ldx #$0f
   114 212A BD 40 03 9D 57 2D + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   115
   116 2133 A2 00 86 8E			mvx #$00 bp					; lo BP = 0, X = 0 !!!
   117
   118 2137				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: starvagrant.a65]
Source: starvagrant.a65
   119
   120 2137			.local	MAIN						; PROCEDURE
   121
   122 					ift l_0114-*>3
   123 2137 4C 97 2C			jmp l_0114
   124 					eif
   125
   126 				; -----------------------------------------------------------
   127
   128 213A			.local	SYSTEM						; UNIT
   129
   130 213A			.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER
   131
   132 				; -----------------------------------------------------------
   133
   134 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   135 				; as Pointer
   136 213A B5 98 85 86			mva :STACKORIGIN,x A
   137 213E B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   138 2142 CA				dex						; sub bx, 1
   139
   140
   141 				; ---------------------  ASM Block 004  ---------------------
   142
   143 2143 A0 00			ldy #0
   144 2145 B1 86 8D 54 30		mva (edx),y Result
   145
   146
   147 214A			@exit
   148
   149 				; -----------------------------------------------------------
   150
   151 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   152 				; as Pointer
   153
   154 214A E8				inx						; add bx, 1
   155 214B AD 54 30 95 98		mva RESULT :STACKORIGIN,x
   156
   157 					.ifdef @new
   158 					@FreeMem #@VarData #@VarDataSize
   159 					eif
   160
   161 				; -----------------------------------------------------------
   162
   163 = 0086			A	= edx
   164 = 3054			RESULT	= DATAORIGIN+$000A
   165
   166 = 3054			@VarData	= RESULT
   167 = 0001			@VarDataSize	= 1
   168
   169 2150 60				rts						; ret
   170 				.endl
   171
   172 2151			.local	DPEEK						; FUNCTION | ASSEMBLER | REGISTER
   173
   174 				; -----------------------------------------------------------
   175
   176 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   177 				; as Pointer
   178 2151 B5 98 85 86			mva :STACKORIGIN,x A
   179 2155 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   180 2159 CA				dex						; sub bx, 1
   181
   182
   183 				; ---------------------  ASM Block 005  ---------------------
   184
   185 215A A0 00			ldy #0
   186 215C B1 86 8D 55 30		mva (edx),y Result
   187 2161 C8				iny
   188 2162 B1 86 8D 56 30		mva (edx),y Result+1
   189
   190
   191 2167			@exit
   192
   193 				; -----------------------------------------------------------
   194
   195 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   196 				; as Pointer
   197
   198 2167 E8				inx						; add bx, 1
   199 2168 AD 55 30 95 98		mva RESULT :STACKORIGIN,x
   200 216D AD 56 30 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   201
   202 					.ifdef @new
   203 					@FreeMem #@VarData #@VarDataSize
   204 					eif
   205
   206 				; -----------------------------------------------------------
   207
   208 = 0086			A	= edx
   209 = 3055			RESULT	= DATAORIGIN+$000B
   210
   211 = 3055			@VarData	= RESULT
   212 = 0002			@VarDataSize	= 2
   213
   214 2172 60				rts						; ret
   215 				.endl
   216
   217 2173			.local	STR						; PROCEDURE | ASSEMBLER
   218
   219 				; -----------------------------------------------------------
   220
   221 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   222 				; as Pointer
   223 2173 B5 98 8D 5B 30		mva :STACKORIGIN,x S
   224 2178 B5 A8 8D 5C 30		mva :STACKORIGIN+STACKWIDTH,x S+1
   225 217D CA				dex						; sub bx, 1
   226
   227 				; -----------------------------------------------------------
   228
   229 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
   230 				; as Pointer
   231 217E B5 98 8D 57 30		mva :STACKORIGIN,x A
   232 2183 B5 A8 8D 58 30		mva :STACKORIGIN+STACKWIDTH,x A+1
   233 2188 B5 B8 8D 59 30		mva :STACKORIGIN+STACKWIDTH*2,x A+2
   234 218D B5 C8 8D 5A 30		mva :STACKORIGIN+STACKWIDTH*3,x A+3
   235 2192 CA				dex						; sub bx, 1
   236
   237
   238 				; ---------------------  ASM Block 020  ---------------------
   239
   240 2193 8A 48			txa:pha
   241
   242 2195 E8				inx
   243
   244 					@ValueToStr #@printINT
   244 				 LDY> @PRINTINT\ LDA< @PRINTINT\ JSR @VALUETOSTR
   244 2196 A0 2E		 LDY> @PRINTINT
   244 2198 A9 6B		 LDA< @PRINTINT
   244 219A 20 F9 2E		 JSR @VALUETOSTR
   245
   246 					@move #@buf s #16	; !!! koniecznie przez wskaznik
   246 				 MWA #@BUF @MOVE.PTR1\ MWA S @MOVE.PTR2\ MWA #16 @MOVE.PTR3\ JSR @MOVE
   246 219D A9 00 85 86 A9 04 +  MWA #@BUF @MOVE.PTR1
   246 21A5 AD 5B 30 85 8A AD +  MWA S @MOVE.PTR2
   246 21AF A9 10 85 82 A9 00 +  MWA #16 @MOVE.PTR3
   246 21B7 20 7F 2F		 JSR @MOVE
   247
   248 21BA 68 AA			pla:tax
   249
   250
   251 				; -----------------------------------------------------------
   252
   253 = 3057			A	= DATAORIGIN+$000D
   254 = 305B			S	= DATAORIGIN+$0011
   255
   256 = 3057			@VarData	= A
   257 = 0006			@VarDataSize	= 6
   258
   259
   260 21BC			@exit
   261 					.ifdef @new
   262 					@FreeMem #@VarData #@VarDataSize
   263 					eif
   264 21BC 60				rts						; ret
   265 				.endl
   266
   267 21BD			.local	FILLCHAR_014E					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   268
   269 				; -----------------------------------------------------------
   270
   271 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   272 				; as Pointer
   273 21BD B5 98 85 82			mva :STACKORIGIN,x VALUE
   274 21C1 CA				dex						; sub bx, 1
   275
   276 				; -----------------------------------------------------------
   277
   278 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   279 				; as Pointer
   280 21C2 B5 98 85 8A			mva :STACKORIGIN,x COUNT
   281 21C6 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   282 21CA CA				dex						; sub bx, 1
   283
   284 				; -----------------------------------------------------------
   285
   286 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   287 				; as Pointer
   288 21CB B5 98 85 86			mva :STACKORIGIN,x A
   289 21CF B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   290 21D3 CA				dex						; sub bx, 1
   291
   292
   293 				; ---------------------  ASM Block 024  ---------------------
   294
   295 21D4 20 D4 2F			jsr @fill
   296
   297
   298 				; -----------------------------------------------------------
   299
   300 = 0086			A	= edx
   301 = 008A			COUNT	= ecx
   302 = 0082			VALUE	= eax
   303
   304 21D7			@exit
   305 					.ifdef @new
   306 					@FreeMem #@VarData #@VarDataSize
   307 					eif
   308 21D7 60				rts						; ret
   309 				.endl
   310
   311 21D8			.local	SPACE						; FUNCTION | ASSEMBLER
   312
   313 				; -----------------------------------------------------------
   314
   315 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   316 				; as Pointer
   317 21D8 B5 98 8D 5D 30		mva :STACKORIGIN,x B
   318 21DD CA				dex						; sub bx, 1
   319
   320
   321 				; ---------------------  ASM Block 034  ---------------------
   322
   323 21DE A0 00			ldy #0
   324 21E0 A9 20			lda #' '
   325 21E2 99 00 04 C8 D0 FA		sta:rne @buf,y+
   326
   327 21E8 AD 5D 30 8D 00 04		mva b @buf
   328
   329 21EE A9 00 8D 5E 30 A9 + 	mwa #@buf Result
   330
   331
   332 21F8			@exit
   333
   334 				; -----------------------------------------------------------
   335
   336 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   337 				; as Pointer
   338
   339 21F8 E8				inx						; add bx, 1
   340 21F9 AD 5E 30 95 98		mva RESULT :STACKORIGIN,x
   341 21FE AD 5F 30 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   342
   343 					.ifdef @new
   344 					@FreeMem #@VarData #@VarDataSize
   345 					eif
   346
   347 				; -----------------------------------------------------------
   348
   349 = 305D			B	= DATAORIGIN+$0013
   350 = 305E			RESULT	= DATAORIGIN+$0014
   351
   352 = 305D			@VarData	= B
   353 = 0003			@VarDataSize	= 3
   354
   355 2203 60				rts						; ret
   356 				.endl
   357
   358 2204			.local	CONCAT_0173					; FUNCTION | ASSEMBLER | OVERLOAD
   359
   360 				; -----------------------------------------------------------
   361
   362 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   363 				; as Pointer
   364 2204 B5 98 8D A4 22		mva :STACKORIGIN,x B
   365 2209 B5 A8 8D A5 22		mva :STACKORIGIN+STACKWIDTH,x B+1
   366 220E CA				dex						; sub bx, 1
   367 					@move B #adr.B #256
   367 				 MWA B @MOVE.PTR1\ MWA #ADR.B @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   367 220F AD A4 22 85 86 AD +  MWA B @MOVE.PTR1
   367 2219 A9 60 85 8A A9 31 +  MWA #ADR.B @MOVE.PTR2
   367 2221 A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
   367 2229 20 7F 2F		 JSR @MOVE
   368 222C A9 60 8D A4 22 A9 + 	mwa #adr.B B
   369
   370 				; -----------------------------------------------------------
   371
   372 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   373 				; as Pointer
   374 2236 B5 98 8D A2 22		mva :STACKORIGIN,x A
   375 223B B5 A8 8D A3 22		mva :STACKORIGIN+STACKWIDTH,x A+1
   376 2240 CA				dex						; sub bx, 1
   377 					@move A #adr.A #256
   377 				 MWA A @MOVE.PTR1\ MWA #ADR.A @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   377 2241 AD A2 22 85 86 AD +  MWA A @MOVE.PTR1
   377 224B A9 60 85 8A A9 30 +  MWA #ADR.A @MOVE.PTR2
   377 2253 A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
   377 225B 20 7F 2F		 JSR @MOVE
   378 225E A9 60 8D A2 22 A9 + 	mwa #adr.A A
   379
   380
   381 				; ---------------------  ASM Block 043  ---------------------
   382
   383 2268 A9 00 8D 00 04		mva #0 @buf
   384 					@addString #adr.a
   384 				 LDY> ADR.A\ LDA< ADR.A\ JSR @ADDSTRING
   384 226D A0 30		 LDY> ADR.A
   384 226F A9 60		 LDA< ADR.A
   384 2271 20 1D 30		 JSR @ADDSTRING
   385 					@addString #adr.b
   385 				 LDY> ADR.B\ LDA< ADR.B\ JSR @ADDSTRING
   385 2274 A0 31		 LDY> ADR.B
   385 2276 A9 60		 LDA< ADR.B
   385 2278 20 1D 30		 JSR @ADDSTRING
   386 					@move #@buf #adr.Result #256
   386 				 MWA #@BUF @MOVE.PTR1\ MWA #ADR.RESULT @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   386 227B A9 00 85 86 A9 04 +  MWA #@BUF @MOVE.PTR1
   386 2283 A9 60 85 8A A9 32 +  MWA #ADR.RESULT @MOVE.PTR2
   386 228B A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
   386 2293 20 7F 2F		 JSR @MOVE
   387
   388
   389 2296			@exit
   390
   391 				; -----------------------------------------------------------
   392
   393 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   394 				; as Pointer
   395
   396 2296 E8				inx						; add bx, 1
   397 2297 AD A6 22 95 98		mva RESULT :STACKORIGIN,x
   398 229C AD A7 22 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   399
   400 					.ifdef @new
   401 					@FreeMem #@VarData #@VarDataSize
   402 					eif
   403
   404 				; -----------------------------------------------------------
   405
   406 = 3060			adr.A	= DATAORIGIN+$0016
   407 22A1			.var A	= adr.A .word
   408 = 3160			adr.B	= DATAORIGIN+$0116
   409 22A1			.var B	= adr.B .word
   410 = 3260			adr.RESULT	= DATAORIGIN+$0216
   411 22A1			.var RESULT	= adr.RESULT .word
   412
   413 = 22A2			@VarData	= A
   414 = 0300			@VarDataSize	= 768
   415
   416 22A1 60				rts						; ret
   417 = 22A2 60 30		A
   417 = 22A4 60 31		B
   417 = 22A6 60 32		RESULT
   417 				.endl
   418
   419 				; -----------------------------------------------------------
   420
   421 = 0648			M_PI_2	= $0648
   422 = 0192			D_PI_2	= $0192
   423 = 0004			D_PI_180	= $0004
   424 = 0000			MGTIA	= $0000
   425 = 0080			MVBXE	= $0080
   426 = 0010			WINDOW	= $0010
   427 = 0020			NARROW	= $0020
   428 = 0000			VBXE_XDLADR	= $0000
   429 = 0100			VBXE_BCBADR	= $0100
   430 = 1000			VBXE_MAPADR	= $1000
   431 = 5000			VBXE_OVRADR	= $5000
   432 = B000			VBXE_WINDOW	= $B000
   433 = 0000			IDLI	= $0000
   434 = 0001			IVBL	= $0001
   435 = 00FE			CH_DELCHR	= $00FE
   436 = 009B			CH_ENTER	= $009B
   437 = 001B			CH_ESC	= $001B
   438 = 001C			CH_CURS_UP	= $001C
   439 = 001D			CH_CURS_DOWN	= $001D
   440 = 001E			CH_CURS_LEFT	= $001E
   441 = 001F			CH_CURS_RIGHT	= $001F
   442 = 007F			CH_TAB	= $007F
   443 = 009B			CH_EOL	= $009B
   444 = 007D			CH_CLR	= $007D
   445 = 00FD			CH_BELL	= $00FD
   446 = 007E			CH_DEL	= $007E
   447 = 009C			CH_DELLINE	= $009C
   448 = 009D			CH_INSLINE	= $009D
   449 = 0000			COLOR_BLACK	= $0000
   450 = 000E			COLOR_WHITE	= $000E
   451 = 0032			COLOR_RED	= $0032
   452 = 0096			COLOR_CYAN	= $0096
   453 = 0068			COLOR_VIOLET	= $0068
   454 = 00C4			COLOR_GREEN	= $00C4
   455 = 0074			COLOR_BLUE	= $0074
   456 = 00EE			COLOR_YELLOW	= $00EE
   457 = 004A			COLOR_ORANGE	= $004A
   458 = 00E4			COLOR_BROWN	= $00E4
   459 = 003C			COLOR_LIGHTRED	= $003C
   460 = 0004			COLOR_GRAY1	= $0004
   461 = 0006			COLOR_GRAY2	= $0006
   462 = 000A			COLOR_GRAY3	= $000A
   463 = 00CC			COLOR_LIGHTGREEN	= $00CC
   464 = 007C			COLOR_LIGHTBLUE	= $007C
   465 = 0004			FMOPENREAD	= $0004
   466 = 0008			FMOPENWRITE	= $0008
   467 = 0009			FMOPENAPPEND	= $0009
   468 = 000C			FMOPENREADWRITE	= $000C
   469 = 304A			SCREENWIDTH	= DATAORIGIN+$0000
   470 = 304C			SCREENHEIGHT	= DATAORIGIN+$0002
   471 = 304E			FILEMODE	= DATAORIGIN+$0004
   472 = 304F			SCREENMODE	= DATAORIGIN+$0005
   473 = 3050			IORESULT	= DATAORIGIN+$0006
   474 = 3051			EOLN	= DATAORIGIN+$0007
   475 = 3052			RNDSEED	= DATAORIGIN+$0008
   476
   477 				.endl							; UNIT SYSTEM
   478
   479 				; -----------------------------------------------------------
   480
   481 22A8			.local	ATARI						; UNIT
   482
   483 				; -----------------------------------------------------------
   484
   485 = 0012			RTCLOK	= $0012
   486 = 004D			ATRACT	= $004D
   487 = 0052			LMARGIN	= $0052
   488 = 0053			RMARGIN	= $0053
   489 = 0054			ROWCRS	= $0054
   490 = 0055			COLCRS	= $0055
   491 = 0057			DINDEX	= $0057
   492 = 0058			SAVMSC	= $0058
   493 = 0200			VDSLST	= $0200
   494 = 0230			SDLSTL	= $0230
   495 = 0290			TXTROW	= $0290
   496 = 0291			TXTCOL	= $0291
   497 = 0293			TINDEX	= $0293
   498 = 0294			TXTMSC	= $0294
   499 = 022F			SDMCTL	= $022F
   500 = 026F			GPRIOR	= $026F
   501 = 02F0			CRSINH	= $02F0
   502 = 02F3			CHACT	= $02F3
   503 = 02F4			CHBAS	= $02F4
   504 = 02FC			CH	= $02FC
   505 = 02C0			PCOLR0	= $02C0
   506 = 02C1			PCOLR1	= $02C1
   507 = 02C2			PCOLR2	= $02C2
   508 = 02C3			PCOLR3	= $02C3
   509 = 02C4			COLOR0	= $02C4
   510 = 02C5			COLOR1	= $02C5
   511 = 02C6			COLOR2	= $02C6
   512 = 02C7			COLOR3	= $02C7
   513 = 02C8			COLOR4	= $02C8
   514 = D000			HPOSP0	= $D000
   515 = D001			HPOSP1	= $D001
   516 = D002			HPOSP2	= $D002
   517 = D003			HPOSP3	= $D003
   518 = D004			HPOSM0	= $D004
   519 = D005			HPOSM1	= $D005
   520 = D006			HPOSM2	= $D006
   521 = D007			HPOSM3	= $D007
   522 = D008			SIZEP0	= $D008
   523 = D009			SIZEP1	= $D009
   524 = D00A			SIZEP2	= $D00A
   525 = D00B			SIZEP3	= $D00B
   526 = D00C			SIZEM	= $D00C
   527 = D00D			GRAFP0	= $D00D
   528 = D00E			GRAFP1	= $D00E
   529 = D00F			GRAFP2	= $D00F
   530 = D010			GRAFP3	= $D010
   531 = D011			GRAFM	= $D011
   532 = D004			P0PF	= $D004
   533 = D014			PAL	= $D014
   534 = D012			COLPM0	= $D012
   535 = D013			COLPM1	= $D013
   536 = D014			COLPM2	= $D014
   537 = D015			COLPM3	= $D015
   538 = D016			COLPF0	= $D016
   539 = D017			COLPF1	= $D017
   540 = D018			COLPF2	= $D018
   541 = D019			COLPF3	= $D019
   542 = D01A			COLBK	= $D01A
   543 = D01B			PRIOR	= $D01B
   544 = D01D			GRACTL	= $D01D
   545 = D01E			HITCLR	= $D01E
   546 = D200			AUDF1	= $D200
   547 = D201			AUDC1	= $D201
   548 = D202			AUDF2	= $D202
   549 = D203			AUDC2	= $D203
   550 = D204			AUDF3	= $D204
   551 = D205			AUDC3	= $D205
   552 = D206			AUDF4	= $D206
   553 = D207			AUDC4	= $D207
   554 = D208			AUDCTL	= $D208
   555 = D20F			SKSTAT	= $D20F
   556 = D301			PORTB	= $D301
   557 = D400			DMACTL	= $D400
   558 = D401			CHACTL	= $D401
   559 = D402			DLISTL	= $D402
   560 = D404			HSCROL	= $D404
   561 = D405			VSCROL	= $D405
   562 = D407			PMBASE	= $D407
   563 = D409			CHBASE	= $D409
   564 = D40A			WSYNC	= $D40A
   565 = D40B			VCOUNT	= $D40B
   566 = D40C			PENH	= $D40C
   567 = D40D			PENV	= $D40D
   568 = D40E			NMIEN	= $D40E
   569
   570 				.endl							; UNIT ATARI
   571
   572 				; -----------------------------------------------------------
   573
   574 22A8			.local	CRT						; UNIT
   575
   576 22A8			.local	CURSOROFF					; PROCEDURE
   577
   578 					ift l_0185-*>3
   579 					jmp l_0185
   580 					eif
   581
   582 				; IfThenEpilog
   583 22A8			l_0185
   584
   585 				; optimize OK (CRT), line = 116
   586
   587 22A8 A9 01 8D F0 02		mva #$01 ATARI.CRSINH
   588
   589 				; -----------------------------------------------------------
   590
   591 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   592 				; as Value $0000001F (31)
   593
   594 22AD E8				inx						; add bx, 1
   595 22AE A9 1F 95 98			mva #$1F :STACKORIGIN,x
   596
   597 22B2 20 10 2E			@printCHAR
   598 22B5 CA				dex						; sub bx, 1
   599
   600 				; -----------------------------------------------------------
   601
   602 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   603 				; as Value $0000001E (30)
   604
   605 22B6 E8				inx						; add bx, 1
   606 22B7 A9 1E 95 98			mva #$1E :STACKORIGIN,x
   607
   608 22BB 20 10 2E			@printCHAR
   609 22BE CA				dex						; sub bx, 1
   610
   611 22BF			@exit
   612 					.ifdef @new
   613 					@FreeMem #@VarData #@VarDataSize
   614 					eif
   615 22BF 60				rts						; ret
   616 				.endl
   617
   618 22C0			.local	CURSORON					; PROCEDURE
   619
   620 					ift l_019C-*>3
   621 					jmp l_019C
   622 					eif
   623
   624 				; IfThenEpilog
   625 22C0			l_019C
   626
   627 				; optimize OK (CRT), line = 129
   628
   629 22C0 A9 00 8D F0 02		mva #$00 ATARI.CRSINH
   630
   631 				; -----------------------------------------------------------
   632
   633 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   634 				; as Value $0000001F (31)
   635
   636 22C5 E8				inx						; add bx, 1
   637 22C6 A9 1F 95 98			mva #$1F :STACKORIGIN,x
   638
   639 22CA 20 10 2E			@printCHAR
   640 22CD CA				dex						; sub bx, 1
   641
   642 				; -----------------------------------------------------------
   643
   644 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   645 				; as Value $0000001E (30)
   646
   647 22CE E8				inx						; add bx, 1
   648 22CF A9 1E 95 98			mva #$1E :STACKORIGIN,x
   649
   650 22D3 20 10 2E			@printCHAR
   651 22D6 CA				dex						; sub bx, 1
   652
   653 22D7			@exit
   654 					.ifdef @new
   655 					@FreeMem #@VarData #@VarDataSize
   656 					eif
   657 22D7 60				rts						; ret
   658 				.endl
   659
   660 22D8			.local	READKEY						; FUNCTION | ASSEMBLER
   661
   662
   663 				; ---------------------  ASM Block 046  ---------------------
   664
   665 22D8 8A 48			txa:pha
   666
   667 22DA 20 27 2F			@GetKey
   668
   669 22DD 8D 61 33			sta Result
   670
   671 22E0 68 AA			pla:tax
   672
   673
   674 22E2			@exit
   675
   676 				; -----------------------------------------------------------
   677
   678 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   679 				; as Pointer
   680
   681 22E2 E8				inx						; add bx, 1
   682 22E3 AD 61 33 95 98		mva RESULT :STACKORIGIN,x
   683
   684 					.ifdef @new
   685 					@FreeMem #@VarData #@VarDataSize
   686 					eif
   687
   688 				; -----------------------------------------------------------
   689
   690 = 3361			RESULT	= DATAORIGIN+$0317
   691
   692 = 3361			@VarData	= RESULT
   693 = 0001			@VarDataSize	= 1
   694
   695 22E8 60				rts						; ret
   696 				.endl
   697
   698 22E9			.local	TEXTBACKGROUND					; PROCEDURE | ASSEMBLER
   699
   700 				; -----------------------------------------------------------
   701
   702 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   703 				; as Pointer
   704 22E9 B5 98 8D 62 33		mva :STACKORIGIN,x A
   705 22EE CA				dex						; sub bx, 1
   706
   707
   708 				; ---------------------  ASM Block 047  ---------------------
   709
   710 22EF AD 62 33 8D C6 02 + 	mwa a colpf2s
   711
   712
   713 				; -----------------------------------------------------------
   714
   715 = 3362			A	= DATAORIGIN+$0318
   716
   717 = 3362			@VarData	= A
   718 = 0001			@VarDataSize	= 1
   719
   720
   721 22FB			@exit
   722 					.ifdef @new
   723 					@FreeMem #@VarData #@VarDataSize
   724 					eif
   725 22FB 60				rts						; ret
   726 				.endl
   727
   728 22FC			.local	TEXTCOLOR					; PROCEDURE | ASSEMBLER
   729
   730 				; -----------------------------------------------------------
   731
   732 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   733 				; as Pointer
   734 22FC B5 98 8D 63 33		mva :STACKORIGIN,x A
   735 2301 CA				dex						; sub bx, 1
   736
   737
   738 				; ---------------------  ASM Block 048  ---------------------
   739
   740 2302 AD 63 33 8D C5 02		mva a colpf1s
   741
   742
   743 				; -----------------------------------------------------------
   744
   745 = 3363			A	= DATAORIGIN+$0319
   746
   747 = 3363			@VarData	= A
   748 = 0001			@VarDataSize	= 1
   749
   750
   751 2308			@exit
   752 					.ifdef @new
   753 					@FreeMem #@VarData #@VarDataSize
   754 					eif
   755 2308 60				rts						; ret
   756 				.endl
   757
   758 2309			.local	DELAY						; PROCEDURE | ASSEMBLER
   759
   760 				; -----------------------------------------------------------
   761
   762 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   763 				; as Pointer
   764 2309 B5 98 8D 64 33		mva :STACKORIGIN,x COUNT
   765 230E B5 A8 8D 65 33		mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   766 2313 CA				dex						; sub bx, 1
   767
   768
   769 				; ---------------------  ASM Block 049  ---------------------
   770
   771 2314 8A 48			txa:pha
   772
   773 2316 A2 00			ldx #0
   774 2318 A0 00			ldy #0
   775
   776 231A CC 64 33		loop	cpy count
   777 231D D0 05			bne @+
   778 231F EC 65 33			cpx count+1
   779 2322 F0 46			beq stop
   780
   781 2324 AD 0B D4 CD 0B D4 + @	:8 lda:cmp:req vcount
   782
   783 2364 C8				iny
   784 2365 D0 01			sne
   785 2367 E8				inx
   786
   787 2368 D0 B0			bne loop
   788
   789 236A 68 AA		stop	pla:tax
   790
   791
   792 				; -----------------------------------------------------------
   793
   794 = 3364			COUNT	= DATAORIGIN+$031A
   795
   796 = 3364			@VarData	= COUNT
   797 = 0002			@VarDataSize	= 2
   798
   799
   800 236C			@exit
   801 					.ifdef @new
   802 					@FreeMem #@VarData #@VarDataSize
   803 					eif
   804 236C 60				rts						; ret
   805 				.endl
   806
   807 236D			.local	KEYPRESSED					; FUNCTION | ASSEMBLER
   808
   809
   810 				; ---------------------  ASM Block 050  ---------------------
   811
   812 236D A0 00			ldy #$00	; false
   813 236F AD FC 02			lda kbcodes
   814 2372 C9 FF			cmp #$ff
   815 2374 F0 01			beq skp
   816 2376 C8				iny		; true
   817
   818 				;	sty kbcodes
   819
   820 2377 8C 66 33		skp	sty Result
   821
   822
   823 237A			@exit
   824
   825 				; -----------------------------------------------------------
   826
   827 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   828 				; as Pointer
   829
   830 237A E8				inx						; add bx, 1
   831 237B AD 66 33 95 98		mva RESULT :STACKORIGIN,x
   832
   833 					.ifdef @new
   834 					@FreeMem #@VarData #@VarDataSize
   835 					eif
   836
   837 				; -----------------------------------------------------------
   838
   839 = 3366			RESULT	= DATAORIGIN+$031C
   840
   841 = 3366			@VarData	= RESULT
   842 = 0001			@VarDataSize	= 1
   843
   844 2380 60				rts						; ret
   845 				.endl
   846
   847 2381			.local	GOTOXY						; PROCEDURE | ASSEMBLER
   848
   849 				; -----------------------------------------------------------
   850
   851 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   852 				; as Pointer
   853 2381 B5 98 8D 68 33		mva :STACKORIGIN,x Y
   854 2386 CA				dex						; sub bx, 1
   855
   856 				; -----------------------------------------------------------
   857
   858 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   859 				; as Pointer
   860 2387 B5 98 8D 67 33		mva :STACKORIGIN,x X
   861 238C CA				dex						; sub bx, 1
   862
   863
   864 				; ---------------------  ASM Block 051  ---------------------
   865
   866 238D AC 67 33			ldy x
   867 2390 F0 03			beq @+
   868 2392 88				dey
   869 2393 84 55			sty colcrs
   870
   871 2395 AC 68 33		@	ldy y
   872 2398 F0 03			beq @+
   873 239A 88				dey
   874 239B 84 54			sty rowcrs
   875 239D			@
   876
   877
   878 				; -----------------------------------------------------------
   879
   880 = 3367			X	= DATAORIGIN+$031D
   881 = 3368			Y	= DATAORIGIN+$031E
   882
   883 = 3367			@VarData	= X
   884 = 0002			@VarDataSize	= 2
   885
   886
   887 239D			@exit
   888 					.ifdef @new
   889 					@FreeMem #@VarData #@VarDataSize
   890 					eif
   891 239D 60				rts						; ret
   892 				.endl
   893
   894 239E			.local	WHEREY						; FUNCTION | ASSEMBLER
   895
   896
   897 				; ---------------------  ASM Block 053  ---------------------
   898
   899
   900 239E A4 54			ldy rowcrs
   901 23A0 C8				iny
   902 23A1 8C 69 33			sty Result
   903
   904
   905 23A4			@exit
   906
   907 				; -----------------------------------------------------------
   908
   909 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   910 				; as Pointer
   911
   912 23A4 E8				inx						; add bx, 1
   913 23A5 AD 69 33 95 98		mva RESULT :STACKORIGIN,x
   914
   915 					.ifdef @new
   916 					@FreeMem #@VarData #@VarDataSize
   917 					eif
   918
   919 				; -----------------------------------------------------------
   920
   921 = 3369			RESULT	= DATAORIGIN+$031F
   922
   923 = 3369			@VarData	= RESULT
   924 = 0001			@VarDataSize	= 1
   925
   926 23AA 60				rts						; ret
   927 				.endl
   928
   929 				; -----------------------------------------------------------
   930
   931 = 3360			TEXTATTR	= DATAORIGIN+$0316
   932 = D01F			CONSOL	= $D01F
   933 = 0000			CN_START_SELECT_OPTION	= $0000
   934 = 0001			CN_SELECT_OPTION	= $0001
   935 = 0002			CN_START_OPTION	= $0002
   936 = 0003			CN_OPTION	= $0003
   937 = 0004			CN_START_SELECT	= $0004
   938 = 0005			CN_SELECT	= $0005
   939 = 0006			CN_START	= $0006
   940 = 0007			CN_NONE	= $0007
   941 = 0000			BW40	= $0000
   942 = 0001			CO40	= $0001
   943 = 0002			BW80	= $0002
   944 = 0003			CO80	= $0003
   945 = 0007			MONO	= $0007
   946 = 0001			C40	= $0001
   947 = 0003			C80	= $0003
   948 = 0000			BLACK	= $0000
   949 = 0001			BLUE	= $0001
   950 = 0002			GREEN	= $0002
   951 = 0003			CYAN	= $0003
   952 = 0004			RED	= $0004
   953 = 0005			MAGENTA	= $0005
   954 = 0006			BROWN	= $0006
   955 = 0007			LIGHTGRAY	= $0007
   956 = 0008			DARKGRAY	= $0008
   957 = 0009			LIGHTBLUE	= $0009
   958 = 000A			LIGHTGREEN	= $000A
   959 = 000B			LIGHTCYAN	= $000B
   960 = 000C			LIGHTRED	= $000C
   961 = 000D			LIGHTMAGENTA	= $000D
   962 = 000E			YELLOW	= $000E
   963 = 000F			WHITE	= $000F
   964 = 0080			BLINK	= $0080
   965
   966 				.endl							; UNIT CRT
   967
   968 				; -----------------------------------------------------------
   969
   970 23AB			.local	RMT						; UNIT
   971
   972 				; -----------------------------------------------------------
   973
   974
   975 				.endl							; UNIT RMT
   976
   977 				; -----------------------------------------------------------
   978
   979 23AB			.local	B_UTILS						; UNIT
   980
   981 23AB			.local	WRITERIGHTALIGNED				; PROCEDURE
   982
   983 				; -----------------------------------------------------------
   984
   985 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   986 				; as Pointer
   987 23AB B5 98 8D 1D 24		mva :STACKORIGIN,x S
   988 23B0 B5 A8 8D 1E 24		mva :STACKORIGIN+STACKWIDTH,x S+1
   989 23B5 CA				dex						; sub bx, 1
   990 					@move S #adr.S #33
   990 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #33 @MOVE.PTR3\ JSR @MOVE
   990 23B6 AD 1D 24 85 86 AD +  MWA S @MOVE.PTR1
   990 23C0 A9 7B 85 8A A9 33 +  MWA #ADR.S @MOVE.PTR2
   990 23C8 A9 21 85 82 A9 00 +  MWA #33 @MOVE.PTR3
   990 23D0 20 7F 2F		 JSR @MOVE
   991 23D3 A9 7B 8D 1D 24 A9 + 	mwa #adr.S S
   992
   993 				; -----------------------------------------------------------
   994
   995 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   996 				; as Pointer
   997 23DD B5 98 8D 7A 33		mva :STACKORIGIN,x W
   998 23E2 CA				dex						; sub bx, 1
   999
  1000 					ift l_01ED-*>3
  1001 					jmp l_01ED
  1002 					eif
  1003
  1004 				; IfThenEpilog
  1005 23E3			l_01ED
  1006
  1007 				; optimize OK (B_UTILS), line = 70
  1008
  1009 23E3 AD 1D 24 85 90 AD + 	mwa S :bp2
  1010 23ED A0 00			ldy #0
  1011 23EF AD 7A 33			lda W
  1012 23F2 38 F1 90			sub (:bp2),y
  1013 23F5 8D 9C 33			sta LEN
  1014
  1015 				; -----------------------------------------------------------
  1016
  1017 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1018 				; as Pointer
  1019
  1020 23F8 E8				inx						; add bx, 1
  1021 23F9 AD 9C 33 95 98		mva LEN :STACKORIGIN,x
  1022
  1023 23FE 20 D8 21			jsr SYSTEM.SPACE				; call Entry
  1024
  1025
  1026 2401 B5 98			lda :STACKORIGIN,x
  1027 2403 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1028 2405 20 23 2E			jsr @printSTRING
  1029 2408 CA				dex						; sub bx, 1
  1030
  1031 				; -----------------------------------------------------------
  1032
  1033 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1034 				; as Pointer
  1035
  1036 2409 E8				inx						; add bx, 1
  1037 240A AD 1D 24 95 98		mva S :STACKORIGIN,x
  1038 240F AD 1E 24 95 A8		mva S+1 :STACKORIGIN+STACKWIDTH,x
  1039
  1040 2414 B5 98			lda :STACKORIGIN,x
  1041 2416 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1042 2418 20 23 2E			jsr @printSTRING
  1043 241B CA				dex						; sub bx, 1
  1044
  1045 				; -----------------------------------------------------------
  1046
  1047 = 337A			W	= DATAORIGIN+$0330
  1048 = 337B			adr.S	= DATAORIGIN+$0331
  1049 241C			.var S	= adr.S .word
  1050 = 339C			LEN	= DATAORIGIN+$0352
  1051
  1052 = 337A			@VarData	= W
  1053 = 0023			@VarDataSize	= 35
  1054
  1055
  1056 241C			@exit
  1057 					.ifdef @new
  1058 					@FreeMem #@VarData #@VarDataSize
  1059 					eif
  1060 241C 60				rts						; ret
  1061 = 241D 7B 33		S
  1061 				.endl
  1062
  1063 241F			.local	NULLTERMTOSTRING				; FUNCTION
  1064
  1065 				; -----------------------------------------------------------
  1066
  1067 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1068 				; as Pointer
  1069 241F B5 98 8D 9D 33		mva :STACKORIGIN,x PTR
  1070 2424 B5 A8 8D 9E 33		mva :STACKORIGIN+STACKWIDTH,x PTR+1
  1071 2429 CA				dex						; sub bx, 1
  1072
  1073 					ift l_0211-*>3
  1074 					jmp l_0211
  1075 					eif
  1076
  1077 				; IfThenEpilog
  1078 242A			l_0211
  1079
  1080 				; optimize OK (B_UTILS), line = 81
  1081
  1082 242A A9 00 8D 9F 33		mva #$00 adr.RESULT+$00
  1083
  1084 				; --- WhileProlog
  1085 242F			l_0217
  1086
  1087 				; optimize OK (B_UTILS), line = 82
  1088
  1089 242F AD 9E 33			lda PTR+1
  1090 2432 85 8F			sta :bp+1
  1091 2434 AC 9D 33			ldy PTR
  1092 2437 B1 8E			lda (:bp),y
  1093 2439 A0 01			ldy #1
  1094 243B C9 00			cmp #$00
  1095 243D D0 01			bne @+
  1096 243F 88				dey
  1097 2440			@
  1098 2440 98				tya
  1099 2441 D0 03			bne *+5
  1100 2443 4C 68 24			jmp l_0226
  1101
  1102 				; optimize OK (B_UTILS), line = 83
  1103
  1104 2446 EE 9F 33			inc adr.RESULT+$00
  1105
  1106 				; optimize OK (B_UTILS), line = 84
  1107
  1108 2449 AD 9F 33			lda adr.RESULT+$00
  1109 244C 85 A1			sta :STACKORIGIN+9
  1110 244E AD 9E 33			lda PTR+1
  1111 2451 85 8F			sta :bp+1
  1112 2453 AC 9D 33			ldy PTR
  1113 2456 B1 8E			lda (:bp),y
  1114 2458 A4 A1			ldy :STACKORIGIN+9
  1115 245A 99 9F 33			sta adr.RESULT,y
  1116
  1117 				; optimize FAIL (0, B_UTILS), line = 85
  1118 245D EE 9D 33 D0 03 EE + 	inw PTR
  1119
  1120 				; --- WhileDoEpilog
  1121 2465			c_0217
  1122
  1123 				; WhileDoEpilog
  1124 2465 4C 2F 24			jmp l_0217
  1125 2468			l_0226
  1126 2468			b_0217
  1127
  1128 2468			@exit
  1129
  1130 				; -----------------------------------------------------------
  1131
  1132 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1133 				; as Pointer
  1134
  1135 2468 E8				inx						; add bx, 1
  1136 2469 AD 74 24 95 98		mva RESULT :STACKORIGIN,x
  1137 246E AD 75 24 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
  1138
  1139 					.ifdef @new
  1140 					@FreeMem #@VarData #@VarDataSize
  1141 					eif
  1142
  1143 				; -----------------------------------------------------------
  1144
  1145 = 339D			PTR	= DATAORIGIN+$0353
  1146 = 339F			adr.RESULT	= DATAORIGIN+$0355
  1147 2473			.var RESULT	= adr.RESULT .word
  1148
  1149 = 339D			@VarData	= PTR
  1150 = 0102			@VarDataSize	= 258
  1151
  1152 2473 60				rts						; ret
  1153 = 2474 9F 33		RESULT
  1153 				.endl
  1154
  1155 				; -----------------------------------------------------------
  1156
  1157
  1158 				.endl							; UNIT B_UTILS
  1159
  1160 				; -----------------------------------------------------------
  1161
  1162 2476			.local	B_DL						; UNIT
  1163
  1164 				; -----------------------------------------------------------
  1165
  1166 = 0000			DL_BLANK1	= $0000
  1167 = 0010			DL_BLANK2	= $0010
  1168 = 0020			DL_BLANK3	= $0020
  1169 = 0030			DL_BLANK4	= $0030
  1170 = 0040			DL_BLANK5	= $0040
  1171 = 0050			DL_BLANK6	= $0050
  1172 = 0060			DL_BLANK7	= $0060
  1173 = 0070			DL_BLANK8	= $0070
  1174 = 0080			DL_DLI	= $0080
  1175 = 0040			DL_LMS	= $0040
  1176 = 0020			DL_VSCROLL	= $0020
  1177 = 0010			DL_HSCROLL	= $0010
  1178 = 0002			DL_MODE_40X24T2	= $0002
  1179 = 0004			DL_MODE_40X24T5	= $0004
  1180 = 0005			DL_MODE_40X12T5	= $0005
  1181 = 0006			DL_MODE_20X24T5	= $0006
  1182 = 0007			DL_MODE_20X12T5	= $0007
  1183 = 0008			DL_MODE_40X24G4	= $0008
  1184 = 0009			DL_MODE_80X48G2	= $0009
  1185 = 000A			DL_MODE_80X48G4	= $000A
  1186 = 000B			DL_MODE_160X96G2	= $000B
  1187 = 000C			DL_MODE_160X192G2	= $000C
  1188 = 000D			DL_MODE_160X96G4	= $000D
  1189 = 000E			DL_MODE_160X192G4	= $000E
  1190 = 000F			DL_MODE_320X192G2	= $000F
  1191 = 0001			DL_JMP	= $0001
  1192 = 0041			DL_JVB	= $0041
  1193 = 349F			DL_ADDRESS	= DATAORIGIN+$0455
  1194 = 34A1			DL_CURSOR	= DATAORIGIN+$0457
  1195
  1196 				.endl							; UNIT B_DL
  1197
  1198 				; -----------------------------------------------------------
  1199
  1200 2476			.local	B_SYSTEM					; UNIT
  1201
  1202 				; -----------------------------------------------------------
  1203
  1204 = 34A2			__NMIEN	= DATAORIGIN+$0458
  1205 = 0080			PORTB_SELFTEST_OFF	= $0080
  1206 = 0002			PORTB_BASIC_OFF	= $0002
  1207 = 0001			PORTB_SYSTEM_ON	= $0001
  1208
  1209 				.endl							; UNIT B_SYSTEM
  1210
  1211 2476			.local	DLI1						; PROCEDURE | ASSEMBLER | INTERRUPT
  1212
  1213
  1214 				; ---------------------  ASM Block 069  ---------------------
  1215
  1216
  1217 2476 48			        pha
  1218 2477 8D 0A D4		        sta ATARI.WSYNC
  1219 247A A9 0C 8D 16 D0	        mva #$0c ATARI.colpf0
  1220 247F A9 06 8D 17 D0	        mva #$06 ATARI.colpf1
  1221 2484 A9 02 8D 18 D0	        mva #$02 ATARI.colpf2
  1222 2489 A9 0C 8D 19 D0	        mva #$0c ATARI.colpf3
  1223 248E A9 00 8D 1A D0	        mva #$00 ATARI.colbk
  1224 2493 A9 AB 8D 00 02 A9 +         mwa #DLI2 ATARI.VDSLST
  1225 249D A9 3C		        lda #60
  1226 249F CD 0B D4		@       cmp vcount
  1227 24A2 10 FB		        bpl @-
  1228 24A4 A9 00 8D 18 D0	        mva #$00 ATARI.colpf2
  1229
  1230 24A9 68			        pla
  1231 				        
  1232 24AA 40				rti						; ret
  1233 				.endl
  1234
  1235 24AB			.local	DLI2						; PROCEDURE | ASSEMBLER | INTERRUPT
  1236
  1237
  1238 				; ---------------------  ASM Block 070  ---------------------
  1239
  1240
  1241 24AB 48			        pha
  1242 24AC 8D 0A D4		        sta ATARI.WSYNC
  1243 				        ;mva #$00 ATARI.colbk
  1244 24AF A9 00 8D 16 D0	        mva #$00 ATARI.colpf0
  1245 24B4 A9 0C 8D 17 D0	        mva #$0c ATARI.colpf1
  1246 24B9 A9 00 8D 18 D0	        mva #$00 ATARI.colpf2
  1247 24BE A9 00 8D 19 D0	        mva #$00 ATARI.colpf3
  1248 24C3 A9 CF 8D 00 02 A9 +         mwa #DLI3 ATARI.VDSLST
  1249 24CD 68			        pla
  1250 				        
  1251 24CE 40				rti						; ret
  1252 				.endl
  1253
  1254 24CF			.local	DLI3						; PROCEDURE | ASSEMBLER | INTERRUPT
  1255
  1256
  1257 				; ---------------------  ASM Block 071  ---------------------
  1258
  1259
  1260 24CF 48			        pha
  1261 24D0 A9 06 8D 17 D0	        mva #$06 ATARI.colpf1
  1262 24D5 8D 0A D4 8D 0A D4 +         :3 sta ATARI.WSYNC
  1263 24DE A9 08 8D 17 D0	        mva #$08 ATARI.colpf1
  1264 24E3 8D 0A D4		        sta ATARI.WSYNC
  1265 24E6 A9 0A 8D 17 D0	        mva #$0a ATARI.colpf1
  1266 24EB 8D 0A D4		        sta ATARI.WSYNC
  1267 24EE A9 0C 8D 17 D0	        mva #$0c ATARI.colpf1
  1268 24F3 8D 0A D4		        sta ATARI.WSYNC
  1269 24F6 A9 0A 8D 17 D0	        mva #$0a ATARI.colpf1
  1270 24FB 8D 0A D4		        sta ATARI.WSYNC
  1271 24FE A9 08 8D 17 D0	        mva #$08 ATARI.colpf1
  1272 2503 68			        pla
  1273 				        
  1274 2504 40				rti						; ret
  1275 				.endl
  1276
  1277 2505			.local	VBL						; PROCEDURE | ASSEMBLER | INTERRUPT
  1278
  1279
  1280 				; ---------------------  ASM Block 072  ---------------------
  1281
  1282
  1283 2505 48 8A 48 98 48	    phr ; store registers
  1284
  1285 				;   *** example test routine
  1286 				;    mva 20 atari.colbk // blink background
  1287
  1288 				;   *** RMT play routine
  1289 				;    lda MSX
  1290 				;    ldy MSX+1
  1291 				;    jsr RMT.TRMT.PLAY
  1292
  1293 250A A9 76 8D 00 02 A9 +     mwa #dli1 ATARI.VDSLST
  1294
  1295 2514 68 A8 68 AA 68	    plr ; restore registers
  1296 2519 4C 62 E4		    jmp $E462 ; jump to system VBL handler
  1297 				  
  1298 251C 40				rti						; ret
  1299 				.endl
  1300
  1301 251D			.local	DLIC						; PROCEDURE | ASSEMBLER | INTERRUPT
  1302
  1303
  1304 				; ---------------------  ASM Block 073  ---------------------
  1305
  1306
  1307 251D 48			        pha
  1308 251E 8D 0A D4		        sta ATARI.WSYNC
  1309 2521 A9 06 8D 1A D0	        mva #$06 ATARI.colbk
  1310 				        ;mva #$00 ATARI.colpf0
  1311 2526 A9 02 8D 17 D0	        mva #$02 ATARI.colpf1
  1312 252B A9 06 8D 18 D0	        mva #$06 ATARI.colpf2
  1313 				        ;mva #$00 ATARI.colpf3
  1314 2530 68			        pla
  1315 				        
  1316 2531 40				rti						; ret
  1317 				.endl
  1318
  1319 2532			.local	VBLC						; PROCEDURE | ASSEMBLER | INTERRUPT
  1320
  1321
  1322 				; ---------------------  ASM Block 074  ---------------------
  1323
  1324
  1325 2532 48 8A 48 98 48	    phr ; store registers
  1326
  1327 				;   *** example test routine
  1328 				;    mva 20 atari.colbk // blink background
  1329
  1330 				;   *** RMT play routine
  1331 				;    lda MSX
  1332 				;    ldy MSX+1
  1333 				;    jsr RMT.TRMT.PLAY
  1334
  1335 				    ; mwa #dlic ATARI.VDSLST
  1336
  1337 2537 68 A8 68 AA 68	    plr ; restore registers
  1338 253C 4C 62 E4		    jmp $E462 ; jump to system VBL handler
  1339 				  
  1340 253F 40				rti						; ret
  1341 				.endl
  1342
  1343 2540			.local	CLRLINE						; PROCEDURE
  1344
  1345 					ift l_0249-*>3
  1346 					jmp l_0249
  1347 					eif
  1348
  1349 				; IfThenEpilog
  1350 2540			l_0249
  1351
  1352 				; optimize FAIL ('CRT.WHEREY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 37
  1353 2540 E8				inx
  1354 2541 A9 58 95 98			mva #$58 :STACKORIGIN,x
  1355 2545 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1356 2549 20 51 21			jsr SYSTEM.DPEEK
  1357 254C E8				inx
  1358 254D A9 01 95 98			mva #$01 :STACKORIGIN,x
  1359 2551 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1360 2555 20 84 2D			jsr addAX_CX
  1361 2558 CA				dex
  1362 2559 20 9E 23			jsr CRT.WHEREY
  1363 255C E8				inx
  1364 255D A9 28 95 98			mva #$28 :STACKORIGIN,x
  1365 2561 20 FF 2D			jsr imulBYTE
  1366 2564 20 73 2D			jsr movaBX_EAX
  1367 2567 CA				dex
  1368 2568 20 84 2D			jsr addAX_CX
  1369 256B A9 29 95 98			mva #$29 :STACKORIGIN,x
  1370 256F 20 C9 2D			jsr @expandToCARD.BYTE
  1371 2572 20 9B 2D			jsr subEAX_ECX
  1372 2575 A9 28 95 98			mva #$28 :STACKORIGIN,x
  1373 2579 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1374 257D E8				inx
  1375 257E A9 00 95 98			mva #$00 :STACKORIGIN,x
  1376 2582 20 BD 21			jsr SYSTEM.FILLCHAR_014E
  1377
  1378 2585			@exit
  1379 					.ifdef @new
  1380 					@FreeMem #@VarData #@VarDataSize
  1381 					eif
  1382 2585 60				rts						; ret
  1383 				.endl
  1384
  1385 2586			.local	INTTOSTR_025F					; FUNCTION | OVERLOAD
  1386
  1387 				; -----------------------------------------------------------
  1388
  1389 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
  1390 				; as Pointer
  1391 2586 B5 98 8D B8 34		mva :STACKORIGIN,x VAL
  1392 258B B5 A8 8D B9 34		mva :STACKORIGIN+STACKWIDTH,x VAL+1
  1393 2590 B5 B8 8D BA 34		mva :STACKORIGIN+STACKWIDTH*2,x VAL+2
  1394 2595 B5 C8 8D BB 34		mva :STACKORIGIN+STACKWIDTH*3,x VAL+3
  1395 259A CA				dex						; sub bx, 1
  1396
  1397 					ift l_0268-*>3
  1398 					jmp l_0268
  1399 					eif
  1400
  1401 				; IfThenEpilog
  1402 259B			l_0268
  1403
  1404 				; optimize FAIL ('SYSTEM.STR', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 78
  1405 259B E8				inx
  1406 259C AD B8 34 95 98		mva VAL :STACKORIGIN,x
  1407 25A1 AD B9 34 95 A8		mva VAL+1 :STACKORIGIN+STACKWIDTH,x
  1408 25A6 AD BA 34 95 B8		mva VAL+2 :STACKORIGIN+STACKWIDTH*2,x
  1409 25AB AD BB 34 95 C8		mva VAL+3 :STACKORIGIN+STACKWIDTH*3,x
  1410 25B0 E8				inx
  1411 25B1 AD CA 25 95 98		mva RESULT :STACKORIGIN,x
  1412 25B6 AD CB 25 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
  1413 25BB 20 73 21			jsr SYSTEM.STR
  1414
  1415 25BE			@exit
  1416
  1417 				; -----------------------------------------------------------
  1418
  1419 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1420 				; as Pointer
  1421
  1422 25BE E8				inx						; add bx, 1
  1423 25BF AD CA 25 95 98		mva RESULT :STACKORIGIN,x
  1424 25C4 AD CB 25 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
  1425
  1426 					.ifdef @new
  1427 					@FreeMem #@VarData #@VarDataSize
  1428 					eif
  1429
  1430 				; -----------------------------------------------------------
  1431
  1432 = 34B8			VAL	= DATAORIGIN+$046E
  1433 = 34BC			adr.RESULT	= DATAORIGIN+$0472
  1434 25C9			.var RESULT	= adr.RESULT .word
  1435
  1436 = 34B8			@VarData	= VAL
  1437 = 0104			@VarDataSize	= 260
  1438
  1439 25C9 60				rts						; ret
  1440 = 25CA BC 34		RESULT
  1440 				.endl
  1441
  1442 25CC			.local	START						; PROCEDURE
  1443
  1444 					ift l_0272-*>3
  1445 					jmp l_0272
  1446 					eif
  1447
  1448 				; IfThenEpilog
  1449 25CC			l_0272
  1450
  1451 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 97
  1452
  1453 25CC A9 88 8D AD 34		mva #$88 PLAYER.UEC
  1454 25D1 A9 13 8D AE 34		mva #$13 PLAYER.UEC+1
  1455 25D6 A9 00 8D AF 34		mva #$00 PLAYER.UEC+2
  1456 25DB 8D B0 34			sta PLAYER.UEC+3
  1457
  1458 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 98
  1459
  1460 25DE A9 00 8D B1 34		mva #$00 PLAYER.LOC
  1461
  1462 25E3			@exit
  1463 					.ifdef @new
  1464 					@FreeMem #@VarData #@VarDataSize
  1465 					eif
  1466 25E3 60				rts						; ret
  1467 				.endl
  1468
  1469 25E4			.local	CONSOLE_NAVIGATION				; PROCEDURE
  1470
  1471 					ift l_0284-*>3
  1472 					jmp l_0284
  1473 					eif
  1474
  1475 				; IfThenEpilog
  1476 25E4			l_0284
  1477
  1478 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 104
  1479 25E4 E8				inx
  1480 25E5 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1481 25E9 E8				inx
  1482 25EA 95 98			sta :STACKORIGIN,x
  1483 25EC 20 81 23			jsr CRT.GOTOXY
  1484
  1485 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 104
  1486 25EF 20 40 25			jsr CLRLINE
  1487
  1488 					@printSTRING #CODEORIGIN+$0000
  1488 				 LDY> CODEORIGIN+$0000\ LDA< CODEORIGIN+$0000\ JSR @PRINTSTRING
  1488 25F2 A0 20		 LDY> CODEORIGIN+$0000
  1488 25F4 A9 00		 LDA< CODEORIGIN+$0000
  1488 25F6 20 23 2E		 JSR @PRINTSTRING
  1489
  1490 				; Array index LOCATIONS[0..0]
  1491
  1492 				; -----------------------------------------------------------
  1493
  1494 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1495 				; as Pointer
  1496
  1497 25F9 E8				inx						; add bx, 1
  1498 25FA AD B1 34 95 98		mva PLAYER.LOC :STACKORIGIN,x
  1499 25FF A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x		; expand to WORD
  1500
  1501 2603				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 2603 16 98			asl :STACKORIGIN-0,x
     2 2605 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1502
  1503 				; -----------------------------------------------------------
  1504
  1505 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1506 				; as Pointer to Array Origin
  1507
  1508
  1509 2607 AD 6B 2D			lda LOCATIONS
  1510 260A 18 75 98			add :STACKORIGIN,x
  1511 260D 85 90			sta :bp2
  1512 260F AD 6C 2D			lda LOCATIONS+1
  1513 2612 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1514 2614 85 91			sta :bp2+1
  1515 2616 A0 00			ldy #$00
  1516 2618 B1 90			lda (:bp2),y
  1517 261A 95 98			sta :STACKORIGIN,x
  1518 261C C8				iny
  1519 261D B1 90			lda (:bp2),y
  1520 261F 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1521
  1522 2621 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1523
  1524
  1525 2624 B5 98			lda :STACKORIGIN,x
  1526 2626 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1527 2628 20 23 2E			jsr @printSTRING
  1528 262B CA				dex						; sub bx, 1
  1529 262C 20 15 2E			@printEOL
  1530
  1531 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 106
  1532 262F E8				inx
  1533 2630 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1534 2634 E8				inx
  1535 2635 A9 02 95 98			mva #$02 :STACKORIGIN,x
  1536 2639 20 81 23			jsr CRT.GOTOXY
  1537
  1538 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 106
  1539 263C 20 40 25			jsr CLRLINE
  1540
  1541 					@printSTRING #CODEORIGIN+$0005
  1541 				 LDY> CODEORIGIN+$0005\ LDA< CODEORIGIN+$0005\ JSR @PRINTSTRING
  1541 263F A0 20		 LDY> CODEORIGIN+$0005
  1541 2641 A9 05		 LDA< CODEORIGIN+$0005
  1541 2643 20 23 2E		 JSR @PRINTSTRING
  1542 2646 20 15 2E			@printEOL
  1543
  1544 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 108
  1545 2649 E8				inx
  1546 264A A9 01 95 98			mva #$01 :STACKORIGIN,x
  1547 264E E8				inx
  1548 264F A9 03 95 98			mva #$03 :STACKORIGIN,x
  1549 2653 20 81 23			jsr CRT.GOTOXY
  1550
  1551 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 108
  1552 2656 20 40 25			jsr CLRLINE
  1553
  1554 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 109
  1555 2659 E8				inx
  1556 265A A9 01 95 98			mva #$01 :STACKORIGIN,x
  1557 265E E8				inx
  1558 265F A9 04 95 98			mva #$04 :STACKORIGIN,x
  1559 2663 20 81 23			jsr CRT.GOTOXY
  1560
  1561 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 109
  1562 2666 20 40 25			jsr CLRLINE
  1563
  1564 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 110
  1565 2669 E8				inx
  1566 266A A9 01 95 98			mva #$01 :STACKORIGIN,x
  1567 266E E8				inx
  1568 266F A9 05 95 98			mva #$05 :STACKORIGIN,x
  1569 2673 20 81 23			jsr CRT.GOTOXY
  1570
  1571 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 110
  1572 2676 20 40 25			jsr CLRLINE
  1573
  1574 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 111
  1575 2679 E8				inx
  1576 267A A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1577 267E E8				inx
  1578 267F A9 06 95 98			mva #$06 :STACKORIGIN,x
  1579 2683 20 81 23			jsr CRT.GOTOXY
  1580
  1581 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 111
  1582 2686 20 40 25			jsr CLRLINE
  1583
  1584 				; Array index STRINGS[0..0]
  1585
  1586 				; -----------------------------------------------------------
  1587
  1588 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1589 				; as Value $0000000C (12)
  1590
  1591 2689 E8				inx						; add bx, 1
  1592 268A A9 0C 95 98			mva #$0C :STACKORIGIN,x
  1593 268E A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1594
  1595 				; -----------------------------------------------------------
  1596
  1597 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1598 				; as Pointer to Array Origin
  1599
  1600
  1601 2692 AD 69 2D			lda STRINGS
  1602 2695 18 75 98			add :STACKORIGIN,x
  1603 2698 85 90			sta :bp2
  1604 269A AD 6A 2D			lda STRINGS+1
  1605 269D 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1606 269F 85 91			sta :bp2+1
  1607 26A1 A0 00			ldy #$00
  1608 26A3 B1 90			lda (:bp2),y
  1609 26A5 95 98			sta :STACKORIGIN,x
  1610 26A7 C8				iny
  1611 26A8 B1 90			lda (:bp2),y
  1612 26AA 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1613
  1614 26AC 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1615
  1616
  1617 26AF B5 98			lda :STACKORIGIN,x
  1618 26B1 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1619 26B3 20 23 2E			jsr @printSTRING
  1620 26B6 CA				dex						; sub bx, 1
  1621 26B7 20 15 2E			@printEOL
  1622
  1623 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 113
  1624 26BA E8				inx
  1625 26BB A9 01 95 98			mva #$01 :STACKORIGIN,x
  1626 26BF E8				inx
  1627 26C0 A9 07 95 98			mva #$07 :STACKORIGIN,x
  1628 26C4 20 81 23			jsr CRT.GOTOXY
  1629
  1630 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 113
  1631 26C7 20 40 25			jsr CLRLINE
  1632
  1633 				; --- RepeatUntilProlog
  1634 26CA			l_02B9
  1635
  1636 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 117
  1637 26CA 20 6D 23			jsr CRT.KEYPRESSED
  1638 					.ifdef IFTMP_23
  1639 					lda :STACKORIGIN,x
  1640 					sta IFTMP_23
  1641 					eif
  1642 26CD CA				dex
  1643 26CE B5 99			lda :STACKORIGIN+1,x
  1644 26D0 D0 03			bne *+5
  1645 26D2 4C F6 26			jmp l_02C3
  1646
  1647 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 118
  1648 26D5 20 D8 22			jsr CRT.READKEY
  1649 26D8 B5 98 8D A3 34		mva :STACKORIGIN,x KEYVAL
  1650 26DD CA				dex
  1651
  1652 				; -----------------------------------------------------------
  1653
  1654 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1655 				; as Pointer
  1656
  1657 26DE E8				inx						; add bx, 1
  1658 26DF AD A3 34 95 98		mva KEYVAL :STACKORIGIN,x
  1659
  1660 				; GenerateCaseProlog
  1661 26E4 CA				dex						; sub bx, 1
  1662
  1663 				; GenerateCaseEqualityCheck
  1664 26E5 B5 99			lda :STACKORIGIN+1,x
  1665 26E7 C9 62			cmp #98
  1666 26E9 F0 03			beq @+
  1667
  1668 				; GenerateCaseStatementProlog
  1669 26EB 4C F6 26			jmp l_02D9
  1670 26EE			@
  1671
  1672 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 120
  1673
  1674 26EE A9 01 8D AC 34		mva #$01 CURRENT_MENU
  1675
  1676 				; GenerateCaseStatementEpilog
  1677 26F3 4C F6 26			jmp a_0002
  1678 26F6			l_02D9
  1679
  1680 				; GenerateIfElseEpilog
  1681
  1682 				; GenerateCaseEpilog
  1683
  1684 				; GenerateIfElseEpilog
  1685 26F6			a_0002
  1686
  1687 				; IfThenEpilog
  1688 26F6			l_02C3
  1689
  1690 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 123
  1691
  1692 26F6 A0 01			ldy #1
  1693 26F8 AD A3 34			lda KEYVAL
  1694 26FB C9 62			cmp #$62
  1695 26FD F0 01			beq @+
  1696 26FF 88				dey
  1697 2700			@
  1698 2700 98				tya
  1699 2701 D0 03			bne *+5
  1700 2703			c_02B9
  1701 2703 4C CA 26			jmp l_02B9
  1702 2706			b_02B9
  1703
  1704 2706			@exit
  1705 					.ifdef @new
  1706 					@FreeMem #@VarData #@VarDataSize
  1707 					eif
  1708 2706 60				rts						; ret
  1709 				.endl
  1710
  1711 2707			.local	CONSOLE_TRADE					; PROCEDURE
  1712
  1713 					ift l_02F8-*>3
  1714 					jmp l_02F8
  1715 					eif
  1716
  1717 				; IfThenEpilog
  1718 2707			l_02F8
  1719
  1720 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 130
  1721
  1722 2707 A9 1D 8D 00 02		mva <DLIC VDSLST
  1723 270C A9 25 8D 01 02		mva >DLIC VDSLST+1
  1724
  1725 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 131
  1726
  1727 2711 A9 32			lda <VBLC
  1728 2713 A0 05			ldy #5
  1729 2715 8D 0A D4			sta wsync
  1730 2718 88				dey
  1731 2719 D0 FD			rne
  1732 271B 8D 24 02			sta VVBLKD
  1733 271E A9 25			lda >VBLC
  1734 2720 8D 25 02			sta VVBLKD+1
  1735
  1736 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 132
  1737
  1738 2723 A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  1739 2728 A9 60 8D 31 02		mva #$60 ATARI.SDLSTL+1
  1740
  1741 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 133
  1742
  1743 272D A9 06 8D 1A D0		mva #$06 ATARI.COLBK
  1744 				; For
  1745
  1746 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 134
  1747
  1748 2732 A9 01 8D BC 35		mva #$01 Y
  1749
  1750 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 134
  1751
  1752 2737 AD 91 02 8D BD 36		mva ATARI.TXTCOL @FORTMP_784
  1753 				; To
  1754 273D			l_0316
  1755
  1756 				; ForToDoCondition
  1757
  1758 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 134
  1759
  1760 273D AD BC 35			lda Y
  1761 2740 CD BD 36			cmp @FORTMP_784
  1762 2743 90 05			bcc *+7
  1763 2745 F0 03			beq *+5
  1764
  1765 				; ForToDoProlog
  1766 2747 4C 63 27			jmp l_0324
  1767
  1768 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 136
  1769 274A E8				inx
  1770 274B A9 01 95 98			mva #$01 :STACKORIGIN,x
  1771 274F E8				inx
  1772 2750 AD BC 35 95 98		mva Y :STACKORIGIN,x
  1773 2755 20 81 23			jsr CRT.GOTOXY
  1774
  1775 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 136
  1776 2758 20 40 25			jsr CLRLINE
  1777
  1778 				; ForToDoEpilog
  1779 275B			c_0316
  1780 275B EE BC 35			inc Y						; inc ptr byte [CounterAddress]
  1781
  1782 275E F0 03			seq
  1783
  1784 				; WhileDoEpilog
  1785 2760 4C 3D 27			jmp l_0316
  1786 2763			l_0324
  1787 2763			b_0316
  1788
  1789 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 138
  1790 2763 E8				inx
  1791 2764 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1792 2768 E8				inx
  1793 2769 95 98			sta :STACKORIGIN,x
  1794 276B 20 81 23			jsr CRT.GOTOXY
  1795
  1796 				; -----------------------------------------------------------
  1797
  1798 				; Push CARDINAL / INTEGER / REAL / SINGLE
  1799 				; as Pointer
  1800
  1801 276E E8				inx						; add bx, 1
  1802 276F AD AD 34 95 98		mva PLAYER.UEC :STACKORIGIN,x
  1803 2774 AD AE 34 95 A8		mva PLAYER.UEC+1 :STACKORIGIN+STACKWIDTH,x
  1804 2779 AD AF 34 95 B8		mva PLAYER.UEC+2 :STACKORIGIN+STACKWIDTH*2,x
  1805 277E AD B0 34 95 C8		mva PLAYER.UEC+3 :STACKORIGIN+STACKWIDTH*3,x
  1806
  1807 2783 20 86 25			jsr INTTOSTR_025F				; call Entry
  1808
  1809
  1810 				; -----------------------------------------------------------
  1811
  1812 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1813 				; as Value $00002020 (8224)
  1814
  1815 2786 E8				inx						; add bx, 1
  1816 2787 A9 20 95 98			mva #$20 :STACKORIGIN,x
  1817 278B A9 20 95 A8			mva #$20 :STACKORIGIN+STACKWIDTH,x
  1818
  1819 278F 20 04 22			jsr SYSTEM.CONCAT_0173				; call Entry
  1820
  1821
  1822 					@moveSTRING UEC
  1822 				 LDY UEC+1\ LDA UEC\ JSR @MOVESTRING
  1822 2792 AC F3 28		 LDY UEC+1
  1822 2795 AD F2 28		 LDA UEC
  1822 2798 20 37 2F		 JSR @MOVESTRING
  1823 279B CA				dex						; sub bx, 1
  1824
  1825 				; Array index LOCATIONS[0..0]
  1826
  1827 				; -----------------------------------------------------------
  1828
  1829 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1830 				; as Pointer
  1831
  1832 279C E8				inx						; add bx, 1
  1833 279D AD B1 34 95 98		mva PLAYER.LOC :STACKORIGIN,x
  1834 27A2 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x		; expand to WORD
  1835
  1836 27A6				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 27A6 16 98			asl :STACKORIGIN-0,x
     2 27A8 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1837
  1838 				; -----------------------------------------------------------
  1839
  1840 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1841 				; as Pointer to Array Origin
  1842
  1843
  1844 27AA AD 6B 2D			lda LOCATIONS
  1845 27AD 18 75 98			add :STACKORIGIN,x
  1846 27B0 85 90			sta :bp2
  1847 27B2 AD 6C 2D			lda LOCATIONS+1
  1848 27B5 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1849 27B7 85 91			sta :bp2+1
  1850 27B9 A0 00			ldy #$00
  1851 27BB B1 90			lda (:bp2),y
  1852 27BD 95 98			sta :STACKORIGIN,x
  1853 27BF C8				iny
  1854 27C0 B1 90			lda (:bp2),y
  1855 27C2 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1856
  1857 27C4 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1858
  1859
  1860 27C7 B5 98			lda :STACKORIGIN,x
  1861 27C9 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1862 27CB 20 23 2E			jsr @printSTRING
  1863 27CE CA				dex						; sub bx, 1
  1864
  1865 					@printSTRING #CODEORIGIN+$0026
  1865 				 LDY> CODEORIGIN+$0026\ LDA< CODEORIGIN+$0026\ JSR @PRINTSTRING
  1865 27CF A0 20		 LDY> CODEORIGIN+$0026
  1865 27D1 A9 26		 LDA< CODEORIGIN+$0026
  1865 27D3 20 23 2E		 JSR @PRINTSTRING
  1866
  1867 				; optimize FAIL ('B_UTILS.WRITERIGHTALIGNED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 142
  1868 27D6 E8				inx
  1869 27D7 A9 08 95 98			mva #$08 :STACKORIGIN,x
  1870 27DB E8				inx
  1871 27DC AD F2 28 95 98		mva UEC :STACKORIGIN,x
  1872 27E1 AD F3 28 95 A8		mva UEC+1 :STACKORIGIN+STACKWIDTH,x
  1873 27E6 20 AB 23			jsr B_UTILS.WRITERIGHTALIGNED
  1874
  1875 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 143
  1876 27E9 E8				inx
  1877 27EA A9 01 95 98			mva #$01 :STACKORIGIN,x
  1878 27EE E8				inx
  1879 27EF A9 02 95 98			mva #$02 :STACKORIGIN,x
  1880 27F3 20 81 23			jsr CRT.GOTOXY
  1881
  1882 					@printSTRING #CODEORIGIN+$0034
  1882 				 LDY> CODEORIGIN+$0034\ LDA< CODEORIGIN+$0034\ JSR @PRINTSTRING
  1882 27F6 A0 20		 LDY> CODEORIGIN+$0034
  1882 27F8 A9 34		 LDA< CODEORIGIN+$0034
  1882 27FA 20 23 2E		 JSR @PRINTSTRING
  1883
  1884 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 145
  1885 27FD E8				inx
  1886 27FE A9 01 95 98			mva #$01 :STACKORIGIN,x
  1887 2802 E8				inx
  1888 2803 A9 03 95 98			mva #$03 :STACKORIGIN,x
  1889 2807 20 81 23			jsr CRT.GOTOXY
  1890
  1891 					@printSTRING #CODEORIGIN+$005E
  1891 				 LDY> CODEORIGIN+$005E\ LDA< CODEORIGIN+$005E\ JSR @PRINTSTRING
  1891 280A A0 20		 LDY> CODEORIGIN+$005E
  1891 280C A9 5E		 LDA< CODEORIGIN+$005E
  1891 280E 20 23 2E		 JSR @PRINTSTRING
  1892
  1893 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 147
  1894 2811 E8				inx
  1895 2812 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1896 2816 E8				inx
  1897 2817 A9 04 95 98			mva #$04 :STACKORIGIN,x
  1898 281B 20 81 23			jsr CRT.GOTOXY
  1899
  1900 					@printSTRING #CODEORIGIN+$0088
  1900 				 LDY> CODEORIGIN+$0088\ LDA< CODEORIGIN+$0088\ JSR @PRINTSTRING
  1900 281E A0 20		 LDY> CODEORIGIN+$0088
  1900 2820 A9 88		 LDA< CODEORIGIN+$0088
  1900 2822 20 23 2E		 JSR @PRINTSTRING
  1901
  1902 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 149
  1903 2825 E8				inx
  1904 2826 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1905 282A E8				inx
  1906 282B A9 05 95 98			mva #$05 :STACKORIGIN,x
  1907 282F 20 81 23			jsr CRT.GOTOXY
  1908
  1909 					@printSTRING #CODEORIGIN+$00B2
  1909 				 LDY> CODEORIGIN+$00B2\ LDA< CODEORIGIN+$00B2\ JSR @PRINTSTRING
  1909 2832 A0 20		 LDY> CODEORIGIN+$00B2
  1909 2834 A9 B2		 LDA< CODEORIGIN+$00B2
  1909 2836 20 23 2E		 JSR @PRINTSTRING
  1910
  1911 					@printSTRING #CODEORIGIN+$00DC
  1911 				 LDY> CODEORIGIN+$00DC\ LDA< CODEORIGIN+$00DC\ JSR @PRINTSTRING
  1911 2839 A0 20		 LDY> CODEORIGIN+$00DC
  1911 283B A9 DC		 LDA< CODEORIGIN+$00DC
  1911 283D 20 23 2E		 JSR @PRINTSTRING
  1912
  1913 				; optimize FAIL ('B_UTILS.WRITERIGHTALIGNED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 151
  1914 2840 E8				inx
  1915 2841 A9 09 95 98			mva #$09 :STACKORIGIN,x
  1916 2845 E8				inx
  1917 2846 A9 EA 95 98			mva #$EA :STACKORIGIN,x
  1918 284A A9 20 95 A8			mva #$20 :STACKORIGIN+STACKWIDTH,x
  1919 284E 20 AB 23			jsr B_UTILS.WRITERIGHTALIGNED
  1920 2851 20 15 2E			@printEOL
  1921
  1922 					@printSTRING #CODEORIGIN+$00F0
  1922 				 LDY> CODEORIGIN+$00F0\ LDA< CODEORIGIN+$00F0\ JSR @PRINTSTRING
  1922 2854 A0 20		 LDY> CODEORIGIN+$00F0
  1922 2856 A9 F0		 LDA< CODEORIGIN+$00F0
  1922 2858 20 23 2E		 JSR @PRINTSTRING
  1923
  1924 				; optimize FAIL ('B_UTILS.WRITERIGHTALIGNED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 152
  1925 285B E8				inx
  1926 285C A9 09 95 98			mva #$09 :STACKORIGIN,x
  1927 2860 E8				inx
  1928 2861 A9 EA 95 98			mva #$EA :STACKORIGIN,x
  1929 2865 A9 20 95 A8			mva #$20 :STACKORIGIN+STACKWIDTH,x
  1930 2869 20 AB 23			jsr B_UTILS.WRITERIGHTALIGNED
  1931 286C 20 15 2E			@printEOL
  1932
  1933 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 153
  1934 286F E8				inx
  1935 2870 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1936 2874 E8				inx
  1937 2875 A9 08 95 98			mva #$08 :STACKORIGIN,x
  1938 2879 20 81 23			jsr CRT.GOTOXY
  1939
  1940 					@printSTRING #CODEORIGIN+$00B2
  1940 				 LDY> CODEORIGIN+$00B2\ LDA< CODEORIGIN+$00B2\ JSR @PRINTSTRING
  1940 287C A0 20		 LDY> CODEORIGIN+$00B2
  1940 287E A9 B2		 LDA< CODEORIGIN+$00B2
  1940 2880 20 23 2E		 JSR @PRINTSTRING
  1941
  1942 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 155
  1943 2883 E8				inx
  1944 2884 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1945 2888 E8				inx
  1946 2889 A9 13 95 98			mva #$13 :STACKORIGIN,x
  1947 288D 20 81 23			jsr CRT.GOTOXY
  1948
  1949 					@printSTRING #CODEORIGIN+$00B2
  1949 				 LDY> CODEORIGIN+$00B2\ LDA< CODEORIGIN+$00B2\ JSR @PRINTSTRING
  1949 2890 A0 20		 LDY> CODEORIGIN+$00B2
  1949 2892 A9 B2		 LDA< CODEORIGIN+$00B2
  1949 2894 20 23 2E		 JSR @PRINTSTRING
  1950
  1951 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 157
  1952 2897 E8				inx
  1953 2898 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1954 289C E8				inx
  1955 289D A9 17 95 98			mva #$17 :STACKORIGIN,x
  1956 28A1 20 81 23			jsr CRT.GOTOXY
  1957
  1958 				; optimize FAIL ('B_UTILS.WRITERIGHTALIGNED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 158
  1959 28A4 E8				inx
  1960 28A5 A9 28 95 98			mva #$28 :STACKORIGIN,x
  1961 28A9 E8				inx
  1962 28AA A9 FE 95 98			mva #$FE :STACKORIGIN,x
  1963 28AE A9 20 95 A8			mva #$20 :STACKORIGIN+STACKWIDTH,x
  1964 28B2 20 AB 23			jsr B_UTILS.WRITERIGHTALIGNED
  1965
  1966 				; --- RepeatUntilProlog
  1967 28B5			l_037E
  1968
  1969 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 164
  1970 28B5 20 6D 23			jsr CRT.KEYPRESSED
  1971 					.ifdef IFTMP_24
  1972 					lda :STACKORIGIN,x
  1973 					sta IFTMP_24
  1974 					eif
  1975 28B8 CA				dex
  1976 28B9 B5 99			lda :STACKORIGIN+1,x
  1977 28BB D0 03			bne *+5
  1978 28BD 4C E1 28			jmp l_0388
  1979
  1980 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 165
  1981 28C0 20 D8 22			jsr CRT.READKEY
  1982 28C3 B5 98 8D A3 34		mva :STACKORIGIN,x KEYVAL
  1983 28C8 CA				dex
  1984
  1985 				; -----------------------------------------------------------
  1986
  1987 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1988 				; as Pointer
  1989
  1990 28C9 E8				inx						; add bx, 1
  1991 28CA AD A3 34 95 98		mva KEYVAL :STACKORIGIN,x
  1992
  1993 				; GenerateCaseProlog
  1994 28CF CA				dex						; sub bx, 1
  1995
  1996 				; GenerateCaseEqualityCheck
  1997 28D0 B5 99			lda :STACKORIGIN+1,x
  1998 28D2 C9 62			cmp #98
  1999 28D4 F0 03			beq @+
  2000
  2001 				; GenerateCaseStatementProlog
  2002 28D6 4C E1 28			jmp l_039E
  2003 28D9			@
  2004
  2005 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 167
  2006
  2007 28D9 A9 01 8D AC 34		mva #$01 CURRENT_MENU
  2008
  2009 				; GenerateCaseStatementEpilog
  2010 28DE 4C E1 28			jmp a_0003
  2011 28E1			l_039E
  2012
  2013 				; GenerateIfElseEpilog
  2014
  2015 				; GenerateCaseEpilog
  2016
  2017 				; GenerateIfElseEpilog
  2018 28E1			a_0003
  2019
  2020 				; IfThenEpilog
  2021 28E1			l_0388
  2022
  2023 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 170
  2024
  2025 28E1 A0 01			ldy #1
  2026 28E3 AD A3 34			lda KEYVAL
  2027 28E6 C9 62			cmp #$62
  2028 28E8 F0 01			beq @+
  2029 28EA 88				dey
  2030 28EB			@
  2031 28EB 98				tya
  2032 28EC D0 03			bne *+5
  2033 28EE			c_037E
  2034 28EE 4C B5 28			jmp l_037E
  2035 28F1			b_037E
  2036
  2037 				; -----------------------------------------------------------
  2038
  2039 = 35BC			Y	= DATAORIGIN+$0572
  2040 = 35BD			adr.UEC	= DATAORIGIN+$0573
  2041 28F1			.var UEC	= adr.UEC .word
  2042 = 36BD			@FORTMP_784	= DATAORIGIN+$0673
  2043
  2044 = 35BC			@VarData	= Y
  2045 = 0102			@VarDataSize	= 258
  2046
  2047
  2048 28F1			@exit
  2049 					.ifdef @new
  2050 					@FreeMem #@VarData #@VarDataSize
  2051 					eif
  2052 28F1 60				rts						; ret
  2053 = 28F2 BD 35		UEC
  2053 				.endl
  2054
  2055 28F4			.local	MENU						; PROCEDURE
  2056
  2057 					ift l_03BD-*>3
  2058 					jmp l_03BD
  2059 					eif
  2060
  2061 				; IfThenEpilog
  2062 28F4			l_03BD
  2063
  2064 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 175
  2065
  2066 28F4 A9 76 8D 00 02		mva <DLI1 VDSLST
  2067 28F9 A9 24 8D 01 02		mva >DLI1 VDSLST+1
  2068
  2069 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 176
  2070
  2071 28FE A9 05			lda <VBL
  2072 2900 A0 05			ldy #5
  2073 2902 8D 0A D4			sta wsync
  2074 2905 88				dey
  2075 2906 D0 FD			rne
  2076 2908 8D 24 02			sta VVBLKD
  2077 290B A9 25			lda >VBL
  2078 290D 8D 25 02			sta VVBLKD+1
  2079
  2080 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 177
  2081
  2082 2910 A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  2083 2915 A9 5F 8D 31 02		mva #$5F ATARI.SDLSTL+1
  2084
  2085 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 179
  2086 291A E8				inx
  2087 291B A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2088 291F E8				inx
  2089 2920 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2090 2924 20 81 23			jsr CRT.GOTOXY
  2091
  2092 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 179
  2093 2927 20 40 25			jsr CLRLINE
  2094
  2095 				; Array index STRINGS[0..0]
  2096
  2097 				; -----------------------------------------------------------
  2098
  2099 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2100 				; as Value $00000006 (6)
  2101
  2102 292A E8				inx						; add bx, 1
  2103 292B A9 06 95 98			mva #$06 :STACKORIGIN,x
  2104 292F A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2105
  2106 				; -----------------------------------------------------------
  2107
  2108 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2109 				; as Pointer to Array Origin
  2110
  2111
  2112 2933 AD 69 2D			lda STRINGS
  2113 2936 18 75 98			add :STACKORIGIN,x
  2114 2939 85 90			sta :bp2
  2115 293B AD 6A 2D			lda STRINGS+1
  2116 293E 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2117 2940 85 91			sta :bp2+1
  2118 2942 A0 00			ldy #$00
  2119 2944 B1 90			lda (:bp2),y
  2120 2946 95 98			sta :STACKORIGIN,x
  2121 2948 C8				iny
  2122 2949 B1 90			lda (:bp2),y
  2123 294B 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2124
  2125 294D 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2126
  2127
  2128 2950 B5 98			lda :STACKORIGIN,x
  2129 2952 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2130 2954 20 23 2E			jsr @printSTRING
  2131 2957 CA				dex						; sub bx, 1
  2132 2958 20 15 2E			@printEOL
  2133
  2134 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 181
  2135 295B E8				inx
  2136 295C A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2137 2960 E8				inx
  2138 2961 A9 02 95 98			mva #$02 :STACKORIGIN,x
  2139 2965 20 81 23			jsr CRT.GOTOXY
  2140
  2141 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 181
  2142 2968 20 40 25			jsr CLRLINE
  2143
  2144 				; Array index STRINGS[0..0]
  2145
  2146 				; -----------------------------------------------------------
  2147
  2148 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2149 				; as Value $00000008 (8)
  2150
  2151 296B E8				inx						; add bx, 1
  2152 296C A9 08 95 98			mva #$08 :STACKORIGIN,x
  2153 2970 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2154
  2155 				; -----------------------------------------------------------
  2156
  2157 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2158 				; as Pointer to Array Origin
  2159
  2160
  2161 2974 AD 69 2D			lda STRINGS
  2162 2977 18 75 98			add :STACKORIGIN,x
  2163 297A 85 90			sta :bp2
  2164 297C AD 6A 2D			lda STRINGS+1
  2165 297F 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2166 2981 85 91			sta :bp2+1
  2167 2983 A0 00			ldy #$00
  2168 2985 B1 90			lda (:bp2),y
  2169 2987 95 98			sta :STACKORIGIN,x
  2170 2989 C8				iny
  2171 298A B1 90			lda (:bp2),y
  2172 298C 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2173
  2174 298E 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2175
  2176
  2177 2991 B5 98			lda :STACKORIGIN,x
  2178 2993 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2179 2995 20 23 2E			jsr @printSTRING
  2180 2998 CA				dex						; sub bx, 1
  2181 2999 20 15 2E			@printEOL
  2182
  2183 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 183
  2184 299C E8				inx
  2185 299D A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2186 29A1 E8				inx
  2187 29A2 A9 03 95 98			mva #$03 :STACKORIGIN,x
  2188 29A6 20 81 23			jsr CRT.GOTOXY
  2189
  2190 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 183
  2191 29A9 20 40 25			jsr CLRLINE
  2192
  2193 				; Array index STRINGS[0..0]
  2194
  2195 				; -----------------------------------------------------------
  2196
  2197 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2198 				; as Value $0000000C (12)
  2199
  2200 29AC E8				inx						; add bx, 1
  2201 29AD A9 0C 95 98			mva #$0C :STACKORIGIN,x
  2202 29B1 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2203
  2204 				; -----------------------------------------------------------
  2205
  2206 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2207 				; as Pointer to Array Origin
  2208
  2209
  2210 29B5 AD 69 2D			lda STRINGS
  2211 29B8 18 75 98			add :STACKORIGIN,x
  2212 29BB 85 90			sta :bp2
  2213 29BD AD 6A 2D			lda STRINGS+1
  2214 29C0 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2215 29C2 85 91			sta :bp2+1
  2216 29C4 A0 00			ldy #$00
  2217 29C6 B1 90			lda (:bp2),y
  2218 29C8 95 98			sta :STACKORIGIN,x
  2219 29CA C8				iny
  2220 29CB B1 90			lda (:bp2),y
  2221 29CD 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2222
  2223 29CF 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2224
  2225
  2226 29D2 B5 98			lda :STACKORIGIN,x
  2227 29D4 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2228 29D6 20 23 2E			jsr @printSTRING
  2229 29D9 CA				dex						; sub bx, 1
  2230 29DA 20 15 2E			@printEOL
  2231
  2232 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 185
  2233 29DD E8				inx
  2234 29DE A9 01 95 98			mva #$01 :STACKORIGIN,x
  2235 29E2 E8				inx
  2236 29E3 A9 04 95 98			mva #$04 :STACKORIGIN,x
  2237 29E7 20 81 23			jsr CRT.GOTOXY
  2238
  2239 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 185
  2240 29EA 20 40 25			jsr CLRLINE
  2241
  2242 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 186
  2243 29ED E8				inx
  2244 29EE A9 01 95 98			mva #$01 :STACKORIGIN,x
  2245 29F2 E8				inx
  2246 29F3 A9 05 95 98			mva #$05 :STACKORIGIN,x
  2247 29F7 20 81 23			jsr CRT.GOTOXY
  2248
  2249 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 186
  2250 29FA 20 40 25			jsr CLRLINE
  2251
  2252 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 187
  2253 29FD E8				inx
  2254 29FE A9 01 95 98			mva #$01 :STACKORIGIN,x
  2255 2A02 E8				inx
  2256 2A03 A9 06 95 98			mva #$06 :STACKORIGIN,x
  2257 2A07 20 81 23			jsr CRT.GOTOXY
  2258
  2259 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 187
  2260 2A0A 20 40 25			jsr CLRLINE
  2261
  2262 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 188
  2263 2A0D E8				inx
  2264 2A0E A9 01 95 98			mva #$01 :STACKORIGIN,x
  2265 2A12 E8				inx
  2266 2A13 A9 07 95 98			mva #$07 :STACKORIGIN,x
  2267 2A17 20 81 23			jsr CRT.GOTOXY
  2268
  2269 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 188
  2270 2A1A 20 40 25			jsr CLRLINE
  2271
  2272 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 189
  2273
  2274 2A1D A9 00 8D A3 34		mva #$00 KEYVAL
  2275
  2276 				; --- RepeatUntilProlog
  2277 2A22			l_0400
  2278
  2279 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 193
  2280 2A22 20 6D 23			jsr CRT.KEYPRESSED
  2281 					.ifdef IFTMP_25
  2282 					lda :STACKORIGIN,x
  2283 					sta IFTMP_25
  2284 					eif
  2285 2A25 CA				dex
  2286 2A26 B5 99			lda :STACKORIGIN+1,x
  2287 2A28 D0 03			bne *+5
  2288 2A2A 4C 70 2A			jmp l_040A
  2289
  2290 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 194
  2291 2A2D 20 D8 22			jsr CRT.READKEY
  2292 2A30 B5 98 8D A3 34		mva :STACKORIGIN,x KEYVAL
  2293 2A35 CA				dex
  2294
  2295 				; -----------------------------------------------------------
  2296
  2297 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2298 				; as Pointer
  2299
  2300 2A36 E8				inx						; add bx, 1
  2301 2A37 AD A3 34 95 98		mva KEYVAL :STACKORIGIN,x
  2302
  2303 				; GenerateCaseProlog
  2304 2A3C CA				dex						; sub bx, 1
  2305
  2306 				; GenerateCaseEqualityCheck
  2307 2A3D B5 99			lda :STACKORIGIN+1,x
  2308 2A3F C9 31			cmp #49
  2309 2A41 F0 03			beq @+
  2310
  2311 				; GenerateCaseStatementProlog
  2312 2A43 4C 4E 2A			jmp l_0420
  2313 2A46			@
  2314
  2315 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 196
  2316
  2317 2A46 A9 02 8D AC 34		mva #$02 CURRENT_MENU
  2318
  2319 				; GenerateCaseStatementEpilog
  2320 2A4B 4C 70 2A			jmp a_0004
  2321 2A4E			l_0420
  2322
  2323 				; GenerateIfElseEpilog
  2324
  2325 				; GenerateCaseEqualityCheck
  2326 2A4E B5 99			lda :STACKORIGIN+1,x
  2327 2A50 C9 32			cmp #50
  2328 2A52 F0 03			beq @+
  2329
  2330 				; GenerateCaseStatementProlog
  2331 2A54 4C 5F 2A			jmp l_0432
  2332 2A57			@
  2333
  2334 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 197
  2335
  2336 2A57 A9 03 8D AC 34		mva #$03 CURRENT_MENU
  2337
  2338 				; GenerateCaseStatementEpilog
  2339 2A5C 4C 70 2A			jmp a_0004
  2340 2A5F			l_0432
  2341
  2342 				; GenerateIfElseEpilog
  2343
  2344 				; GenerateCaseEqualityCheck
  2345 2A5F B5 99			lda :STACKORIGIN+1,x
  2346 2A61 C9 62			cmp #98
  2347 2A63 F0 03			beq @+
  2348
  2349 				; GenerateCaseStatementProlog
  2350 2A65 4C 70 2A			jmp l_0444
  2351 2A68			@
  2352
  2353 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 198
  2354
  2355 2A68 A9 00 8D AC 34		mva #$00 CURRENT_MENU
  2356
  2357 				; GenerateCaseStatementEpilog
  2358 2A6D 4C 70 2A			jmp a_0004
  2359 2A70			l_0444
  2360
  2361 				; GenerateIfElseEpilog
  2362
  2363 				; GenerateCaseEpilog
  2364
  2365 				; GenerateIfElseEpilog
  2366
  2367 				; GenerateIfElseEpilog
  2368
  2369 				; GenerateIfElseEpilog
  2370 2A70			a_0004
  2371
  2372 				; IfThenEpilog
  2373 2A70			l_040A
  2374
  2375 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 201
  2376
  2377 2A70 A0 01			ldy #1
  2378 2A72 AD A3 34			lda KEYVAL
  2379 2A75 C9 62			cmp #$62
  2380 2A77 F0 01			beq @+
  2381 2A79 88				dey
  2382 2A7A			@
  2383 2A7A 84 A1			sty :STACKORIGIN+9
  2384 2A7C A0 01			ldy #1
  2385 2A7E AD A3 34			lda KEYVAL
  2386 2A81 C9 31			cmp #$31
  2387 2A83 F0 01			beq @+
  2388 2A85 88				dey
  2389 2A86			@
  2390 2A86 98				tya
  2391 2A87 05 A1			ora :STACKORIGIN+9
  2392 2A89 85 A1			sta :STACKORIGIN+9
  2393 2A8B A0 01			ldy #1
  2394 2A8D AD A3 34			lda KEYVAL
  2395 2A90 C9 32			cmp #$32
  2396 2A92 F0 01			beq @+
  2397 2A94 88				dey
  2398 2A95			@
  2399 2A95 98				tya
  2400 2A96 05 A1			ora :STACKORIGIN+9
  2401 2A98 D0 03			bne *+5
  2402 2A9A			c_0400
  2403 2A9A 4C 22 2A			jmp l_0400
  2404 2A9D			b_0400
  2405
  2406 2A9D			@exit
  2407 					.ifdef @new
  2408 					@FreeMem #@VarData #@VarDataSize
  2409 					eif
  2410 2A9D 60				rts						; ret
  2411 				.endl
  2412
  2413 2A9E			.local	TITLE						; PROCEDURE
  2414
  2415 					ift l_047D-*>3
  2416 					jmp l_047D
  2417 					eif
  2418
  2419 				; IfThenEpilog
  2420 2A9E			l_047D
  2421
  2422 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 209
  2423
  2424 2A9E A9 76 8D 00 02		mva <DLI1 VDSLST
  2425 2AA3 A9 24 8D 01 02		mva >DLI1 VDSLST+1
  2426
  2427 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 210
  2428
  2429 2AA8 A9 05			lda <VBL
  2430 2AAA A0 05			ldy #5
  2431 2AAC 8D 0A D4			sta wsync
  2432 2AAF 88				dey
  2433 2AB0 D0 FD			rne
  2434 2AB2 8D 24 02			sta VVBLKD
  2435 2AB5 A9 25			lda >VBL
  2436 2AB7 8D 25 02			sta VVBLKD+1
  2437
  2438 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 212
  2439
  2440 2ABA A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  2441 2ABF A9 5F 8D 31 02		mva #$5F ATARI.SDLSTL+1
  2442
  2443 				; Array index STRINGS[0..0]
  2444
  2445 				; -----------------------------------------------------------
  2446
  2447 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2448 				; as Value $00000002 (2)
  2449
  2450 2AC4 E8				inx						; add bx, 1
  2451 2AC5 A9 02 95 98			mva #$02 :STACKORIGIN,x
  2452 2AC9 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2453
  2454 				; -----------------------------------------------------------
  2455
  2456 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2457 				; as Pointer to Array Origin
  2458
  2459
  2460 2ACD AD 69 2D			lda STRINGS
  2461 2AD0 18 75 98			add :STACKORIGIN,x
  2462 2AD3 85 90			sta :bp2
  2463 2AD5 AD 6A 2D			lda STRINGS+1
  2464 2AD8 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2465 2ADA 85 91			sta :bp2+1
  2466 2ADC A0 00			ldy #$00
  2467 2ADE B1 90			lda (:bp2),y
  2468 2AE0 95 98			sta :STACKORIGIN,x
  2469 2AE2 C8				iny
  2470 2AE3 B1 90			lda (:bp2),y
  2471 2AE5 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2472
  2473 2AE7 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2474
  2475
  2476 					@moveSTRING STR
  2476 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2476 2AEA AC 5A 2C		 LDY STR+1
  2476 2AED AD 59 2C		 LDA STR
  2476 2AF0 20 37 2F		 JSR @MOVESTRING
  2477 2AF3 CA				dex						; sub bx, 1
  2478
  2479 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 216
  2480 2AF4 E8				inx
  2481 2AF5 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2482 2AF9 E8				inx
  2483 2AFA A9 01 95 98			mva #$01 :STACKORIGIN,x
  2484 2AFE 20 81 23			jsr CRT.GOTOXY
  2485
  2486 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 216
  2487 2B01 20 40 25			jsr CLRLINE
  2488
  2489 				; -----------------------------------------------------------
  2490
  2491 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2492 				; as Pointer
  2493
  2494 2B04 E8				inx						; add bx, 1
  2495 2B05 AD 59 2C 95 98		mva STR :STACKORIGIN,x
  2496 2B0A AD 5A 2C 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2497
  2498 2B0F B5 98			lda :STACKORIGIN,x
  2499 2B11 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2500 2B13 20 23 2E			jsr @printSTRING
  2501 2B16 CA				dex						; sub bx, 1
  2502 2B17 20 15 2E			@printEOL
  2503
  2504 				; Array index STRINGS[0..0]
  2505
  2506 				; -----------------------------------------------------------
  2507
  2508 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2509 				; as Value $00000004 (4)
  2510
  2511 2B1A E8				inx						; add bx, 1
  2512 2B1B A9 04 95 98			mva #$04 :STACKORIGIN,x
  2513 2B1F A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2514
  2515 				; -----------------------------------------------------------
  2516
  2517 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2518 				; as Pointer to Array Origin
  2519
  2520
  2521 2B23 AD 69 2D			lda STRINGS
  2522 2B26 18 75 98			add :STACKORIGIN,x
  2523 2B29 85 90			sta :bp2
  2524 2B2B AD 6A 2D			lda STRINGS+1
  2525 2B2E 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2526 2B30 85 91			sta :bp2+1
  2527 2B32 A0 00			ldy #$00
  2528 2B34 B1 90			lda (:bp2),y
  2529 2B36 95 98			sta :STACKORIGIN,x
  2530 2B38 C8				iny
  2531 2B39 B1 90			lda (:bp2),y
  2532 2B3B 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2533
  2534 2B3D 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2535
  2536
  2537 					@moveSTRING STR
  2537 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2537 2B40 AC 5A 2C		 LDY STR+1
  2537 2B43 AD 59 2C		 LDA STR
  2537 2B46 20 37 2F		 JSR @MOVESTRING
  2538 2B49 CA				dex						; sub bx, 1
  2539
  2540 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 219
  2541 2B4A E8				inx
  2542 2B4B A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2543 2B4F E8				inx
  2544 2B50 A9 02 95 98			mva #$02 :STACKORIGIN,x
  2545 2B54 20 81 23			jsr CRT.GOTOXY
  2546
  2547 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 219
  2548 2B57 20 40 25			jsr CLRLINE
  2549
  2550 				; -----------------------------------------------------------
  2551
  2552 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2553 				; as Pointer
  2554
  2555 2B5A E8				inx						; add bx, 1
  2556 2B5B AD 59 2C 95 98		mva STR :STACKORIGIN,x
  2557 2B60 AD 5A 2C 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2558
  2559 2B65 B5 98			lda :STACKORIGIN,x
  2560 2B67 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2561 2B69 20 23 2E			jsr @printSTRING
  2562 2B6C CA				dex						; sub bx, 1
  2563 2B6D 20 15 2E			@printEOL
  2564
  2565 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 221
  2566 2B70 E8				inx
  2567 2B71 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2568 2B75 E8				inx
  2569 2B76 A9 03 95 98			mva #$03 :STACKORIGIN,x
  2570 2B7A 20 81 23			jsr CRT.GOTOXY
  2571
  2572 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 221
  2573 2B7D 20 40 25			jsr CLRLINE
  2574
  2575 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 222
  2576 2B80 E8				inx
  2577 2B81 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2578 2B85 E8				inx
  2579 2B86 A9 04 95 98			mva #$04 :STACKORIGIN,x
  2580 2B8A 20 81 23			jsr CRT.GOTOXY
  2581
  2582 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 222
  2583 2B8D 20 40 25			jsr CLRLINE
  2584
  2585 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 223
  2586 2B90 E8				inx
  2587 2B91 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2588 2B95 E8				inx
  2589 2B96 A9 05 95 98			mva #$05 :STACKORIGIN,x
  2590 2B9A 20 81 23			jsr CRT.GOTOXY
  2591
  2592 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 223
  2593 2B9D 20 40 25			jsr CLRLINE
  2594
  2595 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 224
  2596 2BA0 E8				inx
  2597 2BA1 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2598 2BA5 E8				inx
  2599 2BA6 A9 06 95 98			mva #$06 :STACKORIGIN,x
  2600 2BAA 20 81 23			jsr CRT.GOTOXY
  2601
  2602 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 224
  2603 2BAD 20 40 25			jsr CLRLINE
  2604
  2605 				; Array index STRINGS[0..0]
  2606
  2607 				; -----------------------------------------------------------
  2608
  2609 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2610 				; as Value $00000000 (0)
  2611
  2612 2BB0 E8				inx						; add bx, 1
  2613 2BB1 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2614 2BB5 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2615
  2616 				; -----------------------------------------------------------
  2617
  2618 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2619 				; as Pointer to Array Origin
  2620
  2621
  2622 2BB9 AD 69 2D			lda STRINGS
  2623 2BBC 18 75 98			add :STACKORIGIN,x
  2624 2BBF 85 90			sta :bp2
  2625 2BC1 AD 6A 2D			lda STRINGS+1
  2626 2BC4 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2627 2BC6 85 91			sta :bp2+1
  2628 2BC8 A0 00			ldy #$00
  2629 2BCA B1 90			lda (:bp2),y
  2630 2BCC 95 98			sta :STACKORIGIN,x
  2631 2BCE C8				iny
  2632 2BCF B1 90			lda (:bp2),y
  2633 2BD1 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2634
  2635 2BD3 20 1F 24			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2636
  2637
  2638 					@moveSTRING STR
  2638 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2638 2BD6 AC 5A 2C		 LDY STR+1
  2638 2BD9 AD 59 2C		 LDA STR
  2638 2BDC 20 37 2F		 JSR @MOVESTRING
  2639 2BDF CA				dex						; sub bx, 1
  2640
  2641 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 226
  2642 2BE0 E8				inx
  2643 2BE1 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2644 2BE5 E8				inx
  2645 2BE6 A9 07 95 98			mva #$07 :STACKORIGIN,x
  2646 2BEA 20 81 23			jsr CRT.GOTOXY
  2647
  2648 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 226
  2649 2BED 20 40 25			jsr CLRLINE
  2650
  2651 				; -----------------------------------------------------------
  2652
  2653 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2654 				; as Pointer
  2655
  2656 2BF0 E8				inx						; add bx, 1
  2657 2BF1 AD 59 2C 95 98		mva STR :STACKORIGIN,x
  2658 2BF6 AD 5A 2C 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2659
  2660 2BFB B5 98			lda :STACKORIGIN,x
  2661 2BFD B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2662 2BFF 20 23 2E			jsr @printSTRING
  2663 2C02 CA				dex						; sub bx, 1
  2664 2C03 20 15 2E			@printEOL
  2665
  2666 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 231
  2667
  2668 2C06 A9 00 8D A3 34		mva #$00 KEYVAL
  2669
  2670 				; --- RepeatUntilProlog
  2671 2C0B			l_04C6
  2672
  2673 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 235
  2674 2C0B 20 6D 23			jsr CRT.KEYPRESSED
  2675 					.ifdef IFTMP_26
  2676 					lda :STACKORIGIN,x
  2677 					sta IFTMP_26
  2678 					eif
  2679 2C0E CA				dex
  2680 2C0F B5 99			lda :STACKORIGIN+1,x
  2681 2C11 D0 03			bne *+5
  2682 2C13 4C 3A 2C			jmp l_04D0
  2683
  2684 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 236
  2685 2C16 20 D8 22			jsr CRT.READKEY
  2686 2C19 B5 98 8D A3 34		mva :STACKORIGIN,x KEYVAL
  2687 2C1E CA				dex
  2688
  2689 				; -----------------------------------------------------------
  2690
  2691 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2692 				; as Pointer
  2693
  2694 2C1F E8				inx						; add bx, 1
  2695 2C20 AD A3 34 95 98		mva KEYVAL :STACKORIGIN,x
  2696
  2697 				; GenerateCaseProlog
  2698 2C25 CA				dex						; sub bx, 1
  2699
  2700 				; GenerateCaseEqualityCheck
  2701 2C26 B5 99			lda :STACKORIGIN+1,x
  2702 2C28 C9 6E			cmp #110
  2703 2C2A F0 03			beq @+
  2704
  2705 				; GenerateCaseStatementProlog
  2706 2C2C 4C 3A 2C			jmp l_04E6
  2707 2C2F			@
  2708
  2709 				; optimize FAIL ('START', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 239
  2710 2C2F 20 CC 25			jsr START
  2711
  2712 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 240
  2713
  2714 2C32 A9 01 8D AC 34		mva #$01 CURRENT_MENU
  2715
  2716 				; GenerateCaseStatementEpilog
  2717 2C37 4C 3A 2C			jmp a_0005
  2718 2C3A			l_04E6
  2719
  2720 				; GenerateIfElseEpilog
  2721
  2722 				; GenerateCaseEpilog
  2723
  2724 				; GenerateIfElseEpilog
  2725 2C3A			a_0005
  2726
  2727 				; IfThenEpilog
  2728 2C3A			l_04D0
  2729
  2730 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 258
  2731
  2732 2C3A A0 01			ldy #1
  2733 2C3C AD A3 34			lda KEYVAL
  2734 2C3F C9 71			cmp #$71
  2735 2C41 F0 01			beq @+
  2736 2C43 88				dey
  2737 2C44			@
  2738 2C44 84 A1			sty :STACKORIGIN+9
  2739 2C46 A0 01			ldy #1
  2740 2C48 AD A3 34			lda KEYVAL
  2741 2C4B C9 6E			cmp #$6E
  2742 2C4D F0 01			beq @+
  2743 2C4F 88				dey
  2744 2C50			@
  2745 2C50 98				tya
  2746 2C51 05 A1			ora :STACKORIGIN+9
  2747 2C53 D0 03			bne *+5
  2748 2C55			c_04C6
  2749 2C55 4C 0B 2C			jmp l_04C6
  2750 2C58			b_04C6
  2751
  2752 				; -----------------------------------------------------------
  2753
  2754 = 36BE			adr.STR	= DATAORIGIN+$0674
  2755 2C58			.var STR	= adr.STR .word
  2756
  2757 = 2C59			@VarData	= STR
  2758 = 0100			@VarDataSize	= 256
  2759
  2760
  2761 2C58			@exit
  2762 					.ifdef @new
  2763 					@FreeMem #@VarData #@VarDataSize
  2764 					eif
  2765 2C58 60				rts						; ret
  2766 = 2C59 BE 36		STR
  2766 				.endl
  2767
  2768 2C5B			.local	FADE						; PROCEDURE
  2769
  2770 					ift l_0512-*>3
  2771 					jmp l_0512
  2772 					eif
  2773
  2774 				; IfThenEpilog
  2775 2C5B			l_0512
  2776 				; For
  2777
  2778 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 271
  2779
  2780 2C5B A9 00 8D C5 37		mva #$00 I
  2781
  2782 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 271
  2783
  2784 				; To
  2785 2C60			l_0521
  2786
  2787 				; ForToDoCondition
  2788
  2789 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 271
  2790
  2791 2C60 AD C5 37			lda I
  2792 2C63 C9 06			cmp #$06
  2793 2C65 90 05			bcc *+7
  2794 2C67 F0 03			beq *+5
  2795
  2796 				; ForToDoProlog
  2797 2C69 4C 8C 2C			jmp l_052F
  2798
  2799 				; optimize FAIL ('CRT.TEXTBACKGROUND', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 273
  2800 2C6C E8				inx
  2801 2C6D AC C5 37			ldy I 
  2802 2C70 B9 BE 37 95 98		mva adr.FADECOLORS,y :STACKORIGIN,x
  2803 2C75 20 E9 22			jsr CRT.TEXTBACKGROUND
  2804
  2805 				; optimize FAIL ('CRT.DELAY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 274
  2806 2C78 E8				inx
  2807 2C79 A9 23 95 98			mva #$23 :STACKORIGIN,x
  2808 2C7D A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2809 2C81 20 09 23			jsr CRT.DELAY
  2810
  2811 				; ForToDoEpilog
  2812 2C84			c_0521
  2813 2C84 EE C5 37			inc I						; inc ptr byte [CounterAddress]
  2814
  2815 2C87 F0 03			seq
  2816
  2817 				; WhileDoEpilog
  2818 2C89 4C 60 2C			jmp l_0521
  2819 2C8C			l_052F
  2820 2C8C			b_0521
  2821
  2822 				; optimize FAIL ('CRT.TEXTCOLOR', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 277
  2823 2C8C E8				inx
  2824 2C8D A9 06 95 98			mva #$06 :STACKORIGIN,x
  2825 2C91 20 FC 22			jsr CRT.TEXTCOLOR
  2826
  2827 				; -----------------------------------------------------------
  2828
  2829 = 37BE			adr.FADECOLORS	= DATAORIGIN+$0774
  2830 2C94			.var FADECOLORS	= adr.FADECOLORS .word
  2831 = 37C5			I	= DATAORIGIN+$077B
  2832 = 37C6			@FORTMP_1307	= DATAORIGIN+$077C
  2833
  2834 = 2C95			@VarData	= FADECOLORS
  2835 = 0009			@VarDataSize	= 9
  2836
  2837
  2838 2C94			@exit
  2839 					.ifdef @new
  2840 					@FreeMem #@VarData #@VarDataSize
  2841 					eif
  2842 2C94 60				rts						; ret
  2843 = 2C95 BE 37		FADECOLORS
  2843 				.endl
  2844
  2845 				; IfThenEpilog
  2846 2C97			l_0114
  2847
  2848 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 291
  2849
  2850 2C97 A9 00 85 58			mva #$00 ATARI.SAVMSC
  2851 2C9B A9 61 85 59			mva #$61 ATARI.SAVMSC+1
  2852
  2853 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 293
  2854
  2855 2C9F A9 00 85 52			mva #$00 ATARI.LMARGIN
  2856
  2857 				; optimize FAIL ('FADE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 294
  2858 2CA3 20 5B 2C			jsr FADE
  2859
  2860 				; optimize FAIL ('CRT.CURSOROFF', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 295
  2861 2CA6 20 A8 22			jsr CRT.CURSOROFF
  2862
  2863 2CA9 AD 24 02			lda VVBLKD
  2864 2CAC 8D A8 34			sta OLDVBL
  2865 2CAF AD 25 02			lda VVBLKD+1
  2866 2CB2 8D A9 34			sta OLDVBL+1
  2867
  2868 2CB5 AD 00 02			lda VDSLST
  2869 2CB8 8D AA 34			sta OLDDLI
  2870 2CBB AD 01 02			lda VDSLST+1
  2871 2CBE 8D AB 34			sta OLDDLI+1
  2872
  2873 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 306
  2874
  2875 2CC1 A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
  2876
  2877 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 309
  2878
  2879 2CC6 A9 40 8D F4 02		mva #$40 ATARI.CHBAS
  2880
  2881 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 313
  2882
  2883 2CCB A9 00 8D AC 34		mva #$00 CURRENT_MENU
  2884
  2885 				; --- RepeatUntilProlog
  2886 2CD0			l_0566
  2887
  2888 				; -----------------------------------------------------------
  2889
  2890 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2891 				; as Pointer
  2892
  2893 2CD0 E8				inx						; add bx, 1
  2894 2CD1 AD AC 34 95 98		mva CURRENT_MENU :STACKORIGIN,x
  2895
  2896 				; GenerateCaseProlog
  2897 2CD6 CA				dex						; sub bx, 1
  2898
  2899 				; GenerateCaseEqualityCheck
  2900 2CD7 B5 99			lda :STACKORIGIN+1,x
  2901 2CD9 F0 03			beq @+
  2902
  2903 				; GenerateCaseStatementProlog
  2904 2CDB 4C E4 2C			jmp l_0574
  2905 2CDE			@
  2906
  2907 				; optimize FAIL ('TITLE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 317
  2908 2CDE 20 9E 2A			jsr TITLE
  2909
  2910 				; GenerateCaseStatementEpilog
  2911 2CE1 4C 11 2D			jmp a_0006
  2912 2CE4			l_0574
  2913
  2914 				; GenerateIfElseEpilog
  2915
  2916 				; GenerateCaseEqualityCheck
  2917 2CE4 B5 99			lda :STACKORIGIN+1,x
  2918 2CE6 C9 01			cmp #1
  2919 2CE8 F0 03			beq @+
  2920
  2921 				; GenerateCaseStatementProlog
  2922 2CEA 4C F3 2C			jmp l_0580
  2923 2CED			@
  2924
  2925 				; optimize FAIL ('MENU', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 319
  2926 2CED 20 F4 28			jsr MENU
  2927
  2928 				; GenerateCaseStatementEpilog
  2929 2CF0 4C 11 2D			jmp a_0006
  2930 2CF3			l_0580
  2931
  2932 				; GenerateIfElseEpilog
  2933
  2934 				; GenerateCaseEqualityCheck
  2935 2CF3 B5 99			lda :STACKORIGIN+1,x
  2936 2CF5 C9 02			cmp #2
  2937 2CF7 F0 03			beq @+
  2938
  2939 				; GenerateCaseStatementProlog
  2940 2CF9 4C 02 2D			jmp l_058C
  2941 2CFC			@
  2942
  2943 				; optimize FAIL ('CONSOLE_NAVIGATION', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 320
  2944 2CFC 20 E4 25			jsr CONSOLE_NAVIGATION
  2945
  2946 				; GenerateCaseStatementEpilog
  2947 2CFF 4C 11 2D			jmp a_0006
  2948 2D02			l_058C
  2949
  2950 				; GenerateIfElseEpilog
  2951
  2952 				; GenerateCaseEqualityCheck
  2953 2D02 B5 99			lda :STACKORIGIN+1,x
  2954 2D04 C9 03			cmp #3
  2955 2D06 F0 03			beq @+
  2956
  2957 				; GenerateCaseStatementProlog
  2958 2D08 4C 11 2D			jmp l_0598
  2959 2D0B			@
  2960
  2961 				; optimize FAIL ('CONSOLE_TRADE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 321
  2962 2D0B 20 07 27			jsr CONSOLE_TRADE
  2963
  2964 				; GenerateCaseStatementEpilog
  2965 2D0E 4C 11 2D			jmp a_0006
  2966 2D11			l_0598
  2967
  2968 				; GenerateIfElseEpilog
  2969
  2970 				; GenerateCaseEpilog
  2971
  2972 				; GenerateIfElseEpilog
  2973
  2974 				; GenerateIfElseEpilog
  2975
  2976 				; GenerateIfElseEpilog
  2977
  2978 				; GenerateIfElseEpilog
  2979 2D11			a_0006
  2980
  2981 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 324
  2982
  2983 2D11 A0 01			ldy #1
  2984 2D13 AD A3 34			lda KEYVAL
  2985 2D16 C9 71			cmp #$71
  2986 2D18 F0 01			beq @+
  2987 2D1A 88				dey
  2988 2D1B			@
  2989 					.ifdef IFTMP_27
  2990 					sty IFTMP_27
  2991 					eif
  2992 2D1B 98				tya
  2993 2D1C D0 03			bne *+5
  2994 2D1E 4C 24 2D			jmp l_05B3
  2995
  2996 2D21 4C 2B 2D			jmp b_0566					; break
  2997
  2998 				; IfThenEpilog
  2999 2D24			l_05B3
  3000
  3001 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 325
  3002
  3003 2D24 A9 00			lda #$00
  3004 2D26 D0 03			bne *+5
  3005 2D28			c_0566
  3006 2D28 4C D0 2C			jmp l_0566
  3007 2D2B			b_0566
  3008
  3009 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 328
  3010
  3011 2D2B AD A8 34			lda OLDVBL
  3012 2D2E A0 05			ldy #5
  3013 2D30 8D 0A D4			sta wsync
  3014 2D33 88				dey
  3015 2D34 D0 FD			rne
  3016 2D36 8D 24 02			sta VVBLKD
  3017 2D39 AD A9 34			lda OLDVBL+1
  3018 2D3C 8D 25 02			sta VVBLKD+1
  3019
  3020 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 329
  3021
  3022 2D3F AD AA 34 8D 00 02		mva OLDDLI VDSLST
  3023 2D45 AD AB 34 8D 01 02		mva OLDDLI+1 VDSLST+1
  3024
  3025 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 330
  3026
  3027 2D4B A9 40 8D 0E D4		mva #$40 ATARI.NMIEN
  3028
  3029 				; optimize FAIL ('CRT.CURSORON', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 333
  3030 2D50 20 C0 22			jsr CRT.CURSORON
  3031
  3032 				; -----------------------------------------------------------
  3033
  3034 = 5B00			FREE_BOTTOM	= $5B00
  3035 = 5B00			STRINGS_ADDRESS	= $5B00
  3036 = 5C00			LOCATIONS_ADDRESS	= $5C00
  3037 = 5E00			ITEMS_ADDRESS	= $5E00
  3038 = 5F00			DISPLAY_LIST_ADDRESS_MENU	= $5F00
  3039 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE	= $6000
  3040 = 6100			VIDEO_RAM_ADDRESS	= $6100
  3041 = 7000			GFX_ADDRESS	= $7000
  3042 = 8A00			RMT_PLAYER_ADDRESS	= $8A00
  3043 = 9200			RMT_MODULE_ADDRESS	= $9200
  3044 = 4000			CHARSET_ADDRESS	= $4000
  3045 = 0028			TXTCOL	= $0028
  3046 = 0031			KEY_OPTION1	= $0031
  3047 = 0032			KEY_OPTION2	= $0032
  3048 = 0033			KEY_OPTION3	= $0033
  3049 = 0034			KEY_OPTION4	= $0034
  3050 = 0062			KEY_BACK	= $0062
  3051 = 0071			KEY_QUIT	= $0071
  3052 = 006E			KEY_NEW	= $006E
  3053 = 0000			MENU_TITLE	= $0000
  3054 = 0001			MENU_MAIN	= $0001
  3055 = 0002			MENU_NAV	= $0002
  3056 = 0003			MENU_TRADE	= $0003
  3057 = 0004			MENU_MAINT	= $0004
  3058 = 34A3			KEYVAL	= DATAORIGIN+$0459
  3059 = 34A4			adr.MSX	= DATAORIGIN+$045A
  3060 2D53			.var MSX	= adr.MSX .word
  3061 = 34A4			MSX.PLAYER	= DATAORIGIN+$045A
  3062 = 34A6			MSX.MODUL	= DATAORIGIN+$045C
  3063 = 34A8			OLDVBL	= DATAORIGIN+$045E
  3064 = 34AA			OLDDLI	= DATAORIGIN+$0460
  3065 = 5B00			adr.STRINGS	= $5B00
  3066 2D53			.var STRINGS	= adr.STRINGS .word
  3067 = 5C00			adr.LOCATIONS	= $5C00
  3068 2D53			.var LOCATIONS	= adr.LOCATIONS .word
  3069 = 5E00			adr.ITEMS	= $5E00
  3070 2D53			.var ITEMS	= adr.ITEMS .word
  3071 = 34AC			CURRENT_MENU	= DATAORIGIN+$0462
  3072 = 34AD			adr.PLAYER	= DATAORIGIN+$0463
  3073 2D53			.var PLAYER	= adr.PLAYER .word
  3074 = 34AD			PLAYER.UEC	= DATAORIGIN+$0463
  3075 = 34B1			PLAYER.LOC	= DATAORIGIN+$0467
  3076 = 34B2			adr.PLAYER.SHIP	= DATAORIGIN+$0468
  3077 2D53			.var PLAYER.SHIP	= adr.PLAYER.SHIP .word
  3078 = 34B2			PLAYER.SHIP.SNAME	= DATAORIGIN+$0468
  3079 = 34B4			PLAYER.SHIP.SCU_MAX	= DATAORIGIN+$046A
  3080 = 34B6			PLAYER.SHIP.SCU	= DATAORIGIN+$046C
  3081
  3082 2D53			@exit
  3083
  3084 2D53 A2 00		@halt	ldx #0
  3085 2D55 9A				txs
  3086
  3087 2D56 60				rts
  3088
  3089 2D57 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  3090
  3091 2D67			.local	@DEFINES
  3092 2D67			ATARI
  3093 				.endl
  3094
  3095 = 2D67 A4 34		MSX
  3095 = 2D69 00 5B		STRINGS
  3095 = 2D6B 00 5C		LOCATIONS
  3095 = 2D6D 00 5E		ITEMS
  3095 = 2D6F AD 34		PLAYER
  3095 = 2D71 B2 34		PLAYER.SHIP
  3095 				.endl
  3096
  3097 				; -----------------------------------------------------------
  3098
  3099 2D73				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   224 					opt l+
   225
   226 				/* ----------------------------------------------------------------------- */
   227
   228
   229 2D73			.proc	hiBYTE
   230 					lda :STACKORIGIN,x
   231 2D73				:4 lsr @
   232 					sta :STACKORIGIN,x
   233 					rts
   234 				.endp
   235
   236 2D73			.proc	hiWORD
   237 					lda :STACKORIGIN+STACKWIDTH,x
   238 					sta :STACKORIGIN,x
   239 					rts
   240 				.endp
   241
   242 2D73			.proc	hiCARD
   243 					lda :STACKORIGIN+STACKWIDTH*3,x
   244 					sta :STACKORIGIN+STACKWIDTH,x
   245
   246 					lda :STACKORIGIN+STACKWIDTH*2,x
   247 					sta :STACKORIGIN,x
   248 					rts
   249 				.endp
   250
   251
   252 2D73			.proc	movaBX_EAX		; mov [BX], EAX
   253 2D73 A5 82 95 97 A5 83 + 	:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   254 2D83 60				rts
   255 				.endp
   256
   257 				/*
   258 				.proc	@pushBYTE
   259 					adc :STACKORIGIN+STACKWIDTH,x
   260 					sta bp+1
   261
   262 					mva (bp),y :STACKORIGIN,x
   263
   264 				;	lda #$00
   265 				;	sta :STACKORIGIN+STACKWIDTH,x
   266 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   267 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   268
   269 					rts
   270 				.endp
   271
   272
   273 				.proc	@pullWORD (.word ya) .reg
   274 					add :STACKORIGIN-1,x
   275 					sta bp2
   276 					tya
   277 					adc :STACKORIGIN-1+STACKWIDTH,x
   278 					sta bp2+1
   279
   280 					ldy #$00
   281
   282 					mva :STACKORIGIN,x (bp2),y
   283 					iny
   284 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   285
   286 					rts
   287 				.endp
   288
   289
   290 				.proc	@pullCARD (.word ya) .reg
   291 					add :STACKORIGIN-1,x
   292 					sta bp2
   293 					tya
   294 					adc :STACKORIGIN-1+STACKWIDTH,x
   295 					sta bp2+1
   296
   297 					ldy #$00
   298
   299 					mva :STACKORIGIN,x (bp2),y
   300 					iny
   301 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   302 					iny
   303 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   304 					iny
   305 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   306
   307 					rts
   308 				.endp
   309
   310
   311 				.proc	@pushWORD (.word ya) .reg
   312 					add :STACKORIGIN,x
   313 					sta bp2
   314 					tya
   315 					adc :STACKORIGIN+STACKWIDTH,x
   316 					sta bp2+1
   317
   318 					ldy #$00
   319
   320 					mva (bp2),y :STACKORIGIN,x
   321 					iny
   322 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   323
   324 					rts
   325 				.endp
   326
   327
   328 				.proc	@pushCARD (.word ya) .reg
   329 					add :STACKORIGIN,x
   330 					sta bp2
   331 					tya
   332 					adc :STACKORIGIN+STACKWIDTH,x
   333 					sta bp2+1
   334
   335 					ldy #$00
   336
   337 					mva (bp2),y :STACKORIGIN,x
   338 					iny
   339 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   340 					iny
   341 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   342 					iny
   343 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   344
   345 					rts
   346 				.endp
   347 				*/
   347
   348
   349 2D84			.proc	shlEAX_CL
   350
   351 				;SHORT	jsr @expandToCARD1.SHORT
   352 				;	jmp CARD
   353
   354 				;SMALL	jsr @expandToCARD1.SMALL
   355 				;	jmp CARD
   356
   357 2D84			BYTE	lda #0
   358 					sta :STACKORIGIN-1+STACKWIDTH,x
   359
   360 2D84			WORD	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   362 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   363
   364 2D84			CARD	clc
   365 					ldy :STACKORIGIN,x	; cl
   366 					beq stop
   367 2D84			@	asl :STACKORIGIN-1,x	; eax
   368 					rol :STACKORIGIN-1+STACKWIDTH,x
   369 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   370 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   371 					dey
   372 					bne @-
   373
   374 2D84			stop	rts
   375 				.endp
   376
   377
   378 2D84			.proc	shrAL_CL
   379
   380 				;SHORT	jsr @expandToCARD1.SHORT
   381 				;	jmp shrEAX_CL
   382
   383 2D84			BYTE	ldy :STACKORIGIN,x	; cl
   384 					beq stop
   385 2D84			@	lsr :STACKORIGIN-1,x
   386 					dey
   387 					bne @-
   388
   389 2D84			stop	lda #0
   390 					sta :STACKORIGIN-1+STACKWIDTH,x
   391 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   392 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   393
   394 					rts
   395 				.endp
   396
   397 2D84			.proc	shrAX_CL
   398
   399 				;SMALL	jsr @expandToCARD1.SMALL
   400 				;	jmp shrEAX_CL
   401
   402 2D84			WORD	ldy :STACKORIGIN,x	; cl
   403 					beq stop
   404 2D84			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   405 					ror :STACKORIGIN-1,x
   406 					dey
   407 					bne @-
   408
   409 2D84			stop	lda #0
   410 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   411 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   412
   413 					rts
   414 				.endp
   415
   416 2D84			.proc	shrEAX_CL
   417
   418 					ldy :STACKORIGIN,x	; cl
   419 					beq stop
   420 2D84			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   421 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   422 					ror :STACKORIGIN-1+STACKWIDTH,x
   423 					ror :STACKORIGIN-1,x
   424 					dey
   425 					bne @-
   426
   427 2D84			stop	rts
   428 				.endp
   429
   430 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   431 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   432 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   433
   434 2D84			.proc	addAL_CL
   435
   436 					ldy #0
   437
   438 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   439 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   440
   441 					lda :STACKORIGIN-1,x
   442 					add :STACKORIGIN,x
   443 					sta :STACKORIGIN-1,x
   444 					scc
   445 					iny
   446
   447 					sty :STACKORIGIN-1+STACKWIDTH,x
   448
   449 					rts
   450 				.endp
   451
   452 2D84			.proc	addAX_CX
   453
   454 2D84 A0 00			ldy #0
   455
   456 2D86 94 C7			sty :STACKORIGIN-1+STACKWIDTH*3,x
   457
   458 2D88 B5 97			lda :STACKORIGIN-1,x
   459 2D8A 18 75 98			add :STACKORIGIN,x
   460 2D8D 95 97			sta :STACKORIGIN-1,x
   461
   462 2D8F B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   463 2D91 75 A8			adc :STACKORIGIN+STACKWIDTH,x
   464 2D93 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   465 2D95 90 01			scc
   466 2D97 C8				iny
   467
   468 2D98 94 B7			sty :STACKORIGIN-1+STACKWIDTH*2,x
   469
   470 2D9A 60				rts
   471 				.endp
   472
   473
   474 2D9B			.proc	addEAX_ECX
   475 				/*
   476 				SHORT	jsr @expandToCARD.SHORT
   477 					jsr @expandToCARD1.SHORT
   478 					jmp CARD
   479
   480 				SMALL	jsr @expandToCARD.SMALL
   481 					jsr @expandToCARD1.SMALL
   482 				*/
   482
   483 2D9B			CARD	lda :STACKORIGIN-1,x
   484 					add :STACKORIGIN,x
   485 					sta :STACKORIGIN-1,x
   486
   487 					lda :STACKORIGIN-1+STACKWIDTH,x
   488 					adc :STACKORIGIN+STACKWIDTH,x
   489 					sta :STACKORIGIN-1+STACKWIDTH,x
   490
   491 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   492 					adc :STACKORIGIN+STACKWIDTH*2,x
   493 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   494
   495 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   496 					adc :STACKORIGIN+STACKWIDTH*3,x
   497 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   498
   499 					rts
   500 				.endp
   501
   502
   503 2D9B			.proc	subAL_CL
   504
   505 					ldy #0
   506
   507 					lda :STACKORIGIN-1,x
   508 					sub :STACKORIGIN,x
   509 					sta :STACKORIGIN-1,x
   510 					scs
   511 					dey
   512
   513 					sty :STACKORIGIN-1+STACKWIDTH,x
   514 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   515 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   516
   517 					rts
   518 				.endp
   519
   520 2D9B			.proc	subAX_CX
   521
   522 					ldy #0
   523
   524 					lda :STACKORIGIN-1,x		; ax
   525 					sub :STACKORIGIN,x		; cx
   526 					sta :STACKORIGIN-1,x
   527
   528 					lda :STACKORIGIN-1+STACKWIDTH,x
   529 					sbc :STACKORIGIN+STACKWIDTH,x
   530 					sta :STACKORIGIN-1+STACKWIDTH,x
   531 					scs
   532 					dey
   533
   534 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   535 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   536
   537 					rts
   538 				.endp
   539
   540 2D9B			.proc	subEAX_ECX
   541
   542 2D9B B5 97			lda :STACKORIGIN-1,x
   543 2D9D 38 F5 98			sub :STACKORIGIN,x
   544 2DA0 95 97			sta :STACKORIGIN-1,x
   545
   546 2DA2 B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   547 2DA4 F5 A8			sbc :STACKORIGIN+STACKWIDTH,x
   548 2DA6 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   549
   550 2DA8 B5 B7			lda :STACKORIGIN-1+STACKWIDTH*2,x
   551 2DAA F5 B8			sbc :STACKORIGIN+STACKWIDTH*2,x
   552 2DAC 95 B7			sta :STACKORIGIN-1+STACKWIDTH*2,x
   553
   554 2DAE B5 C7			lda :STACKORIGIN-1+STACKWIDTH*3,x
   555 2DB0 F5 C8			sbc :STACKORIGIN+STACKWIDTH*3,x
   556 2DB2 95 C7			sta :STACKORIGIN-1+STACKWIDTH*3,x
   557
   558 2DB4 60				rts
   559 				.endp
   560
   561
   562 2DB5			.proc	@expandSHORT2SMALL
   563 					ldy #$00
   564 					lda :STACKORIGIN,x
   565 					spl
   566 					dey
   567 					sty :STACKORIGIN+STACKWIDTH,x
   568
   569 					rts
   570 				.endp
   571
   572 2DB5			.proc	@expandSHORT2SMALL1
   573 					ldy #$00
   574 					lda :STACKORIGIN-1,x
   575 					spl
   576 					dey
   577 					sty :STACKORIGIN-1+STACKWIDTH,x
   578
   579 					rts
   580 				.endp
   581
   582
   583 2DB5			.proc	@expandToCARD
   584
   585 2DB5 B5 A8		SMALL	lda :STACKORIGIN+STACKWIDTH,x
   586 2DB7 10 04			bpl WORD
   587
   588 2DB9 A9 FF			lda #$ff
   589 2DBB D0 10			bne _wo
   590
   591 2DBD A9 00		WORD	lda #$00
   592 2DBF F0 0C			beq _wo
   593
   594 2DC1 B5 98		SHORT	lda :STACKORIGIN,x
   595 2DC3 10 04			bpl BYTE
   596
   597 2DC5 A9 FF			lda #$ff
   598 2DC7 D0 02			bne _by
   599
   600 2DC9 A9 00		BYTE	lda #$00
   601
   602 2DCB 95 A8		_by	sta :STACKORIGIN+STACKWIDTH,x
   603 2DCD 95 B8		_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   604 2DCF 95 C8		_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   605 2DD1 60				rts
   606 				.endp
   607
   608
   609 2DD2			.proc	@expandToCARD1
   610
   611 2DD2			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   612 					bpl WORD
   613
   614 					lda #$ff
   615 					bne _wo
   616
   617 2DD2			WORD	lda #$00
   618 					beq _wo
   619
   620 2DD2			SHORT	lda :STACKORIGIN-1,x
   621 					bpl BYTE
   622
   623 					lda #$ff
   624 					bne _by
   625
   626 2DD2			BYTE	lda #$00
   627
   628 2DD2			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   629 2DD2			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   630 2DD2			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   631 					rts
   632 				.endp
   633
   634 				/*
   635 				.proc	@cmpFor_WORD (.word ya) .reg
   636 					sta ztmp
   637 					sty ztmp+1
   638
   639 					ldy #1
   640 					lda (ztmp),y
   641 					cmp :STACKORIGIN+1+STACKWIDTH,x
   642 					bne stop
   643 					dey
   644 					lda (ztmp),y
   645 					cmp :STACKORIGIN+1,x
   646 				stop	rts
   647 				.endp
   648
   649
   650 				.proc	@cmpFor_CARD (.word ya) .reg
   651 					sta ztmp
   652 					sty ztmp+1
   653
   654 					ldy #3
   655 					lda (ztmp),y
   656 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   657 					bne stop
   658 					dey
   659 					lda (ztmp),y
   660 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   661 					bne stop
   662 					dey
   663 					lda (ztmp),y
   664 					cmp :STACKORIGIN+1+STACKWIDTH,x
   665 					bne stop
   666 					dey
   667 					lda (ztmp),y
   668 					cmp :STACKORIGIN+1,x
   669
   670 				stop	rts
   671 				.endp
   672
   673
   674 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   675 					sta ztmp
   676 					sty ztmp+1
   677
   678 					ldy	#0
   679 					lda	(ztmp),y
   680 					sec
   681 					sbc	:STACKORIGIN+1,x
   682 					bne	@cmpFor_INT.L4
   683
   684 					jmp	@cmpFor_INT.L1
   685 				.endp
   686
   687
   688 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   689 					sta ztmp
   690 					sty ztmp+1
   691
   692 					ldy	#1
   693 					lda	(ztmp),y
   694 					sec
   695 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   696 					bne	@cmpFor_INT.L4
   697
   698 					dey
   699 					lda	(ztmp),y
   700 					cmp	:STACKORIGIN+1,x
   701
   702 					jmp	@cmpFor_INT.L1
   703 				.endp
   704
   705
   706 				.proc	@cmpFor_INT(.word ya) .reg
   707 					sta ztmp
   708 					sty ztmp+1
   709
   710 					ldy	#3
   711 					lda	(ztmp),y
   712 					sec
   713 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   714 					bne	L4
   715
   716 					dey
   717 					lda	(ztmp),y
   718 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   719 					bne	L1
   720
   721 					dey
   722 					lda	(ztmp),y
   723 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   724 					bne	L1
   725
   726 					dey
   727 					lda	(ztmp),y
   728 					cmp	:STACKORIGIN+1,x
   729
   730 				L1	beq	L2
   731 					bcs	L3
   732
   733 					lda	#$FF	; Set the N flag
   734 				L2	rts
   735
   736 				L3	lda	#$01	; Clear the N flag
   737 					rts
   738
   739 				L4	bvc	L5
   740 					eor	#$FF	; Fix the N flag if overflow
   741 					ora	#$01	; Clear the Z flag
   742 				L5	rts
   743 				.endp
   744 				*/
   744
   745
   746 				; Piotr Fusik, 15.04.2002
   747 				; originally by Ullrich von Bassewitz
   748
   749 2DD2			.proc	cmpSHORTINT
   750 					lda	:STACKORIGIN-1,x
   751 					clv:sec
   752 					sbc	:STACKORIGIN,x
   753 					bne	cmpINT.L4
   754
   755 					jmp	cmpINT.L1
   756 				.endp
   757
   758
   759 2DD2			.proc	cmpSMALLINT
   760 					lda	:STACKORIGIN-1+STACKWIDTH,x
   761 					clv:sec
   762 					sbc	:STACKORIGIN+STACKWIDTH,x
   763 					bne	cmpINT.L4
   764
   765 					lda	:STACKORIGIN-1,x
   766 					cmp	:STACKORIGIN,x
   767
   768 					jmp	cmpINT.L1
   769 				.endp
   770
   771
   772 2DD2			.proc	cmpINT
   773 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   774 					clv:sec
   775 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   776 					bne	L4
   777
   778 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   779 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   780 					bne	L1
   781
   782 					lda	:STACKORIGIN-1+STACKWIDTH,x
   783 					cmp	:STACKORIGIN+STACKWIDTH,x
   784 					bne	L1
   785
   786 					lda	:STACKORIGIN-1,x
   787 					cmp	:STACKORIGIN,x
   788
   789 2DD2			L1	beq	L2
   790 					bcs	L3
   791
   792 					lda	#$FF	; Set the N flag
   793 2DD2			L2	rts
   794
   795 2DD2			L3	lda	#$01	; Clear the N flag
   796 					rts
   797
   798 2DD2			L4	bvc	L5
   799 					eor	#$FF	; Fix the N flag if overflow
   800 					ora	#$01	; Clear the Z flag
   801 2DD2			L5	rts
   802 				.endp
   803
   804
   805 2DD2			.proc	cmpEAX_ECX
   806 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   807 					cmp :STACKORIGIN+STACKWIDTH*3,x
   808 					bne _done
   809 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   810 					cmp :STACKORIGIN+STACKWIDTH*2,x
   811 					bne _done
   812 2DD2			AX_CX
   813 					lda :STACKORIGIN-1+STACKWIDTH,x
   814 					cmp :STACKORIGIN+STACKWIDTH,x
   815 					bne _done
   816 					lda :STACKORIGIN-1,x
   817 					cmp :STACKORIGIN,x
   818
   819 2DD2			_done	rts
   820 				.endp
   821
   822
   823 2DD2			.proc	cmpSTRING2CHAR
   824
   825 					lda :STACKORIGIN-1,x
   826 					sta ztmp8
   827 					lda :STACKORIGIN-1+STACKWIDTH,x
   828 					sta ztmp8+1
   829
   830 					lda :STACKORIGIN,x
   831 					sta ztmp10
   832
   833 					ldy #0
   834
   835 					lda (ztmp8),y		; if length <> 1
   836 					cmp #1
   837 					bne fail
   838
   839 					iny
   840
   841 2DD2			loop	lda (ztmp8),y
   842 					cmp ztmp10
   843 					bne fail
   844
   845 					lda #0
   846 					seq
   847
   848 2DD2			fail	lda #$ff
   849
   850 					ldy #1
   851
   852 					cmp #0
   853 					rts
   854 				.endp
   855
   856
   857
   858 2DD2			.proc	cmpCHAR2STRING
   859
   860 					lda :STACKORIGIN-1,x
   861 					sta ztmp8
   862
   863 					lda :STACKORIGIN,x
   864 					sta ztmp10
   865 					lda :STACKORIGIN+STACKWIDTH,x
   866 					sta ztmp10+1
   867
   868 					ldy #0
   869
   870 					lda (ztmp10),y		; if length <> 1
   871 					cmp #1
   872 					bne fail
   873
   874 					iny
   875
   876 2DD2			loop	lda (ztmp10),y
   877 					cmp ztmp8
   878 					bne fail
   879
   880 					lda #0
   881 					seq
   882
   883 2DD2			fail	lda #$ff
   884
   885 					ldy #1
   886
   887 					cmp #0
   888 					rts
   889 				.endp
   890
   891
   892 2DD2			.proc	cmpSTRING
   893
   894 					lda :STACKORIGIN-1,x
   895 					sta ztmp8
   896 					lda :STACKORIGIN-1+STACKWIDTH,x
   897 					sta ztmp8+1
   898
   899 					lda :STACKORIGIN,x
   900 					sta ztmp10
   901 					lda :STACKORIGIN+STACKWIDTH,x
   902 					sta ztmp10+1
   903
   904 					ldy #0
   905
   906 					lda (ztmp8),y		; if length1 = 0
   907 					beq fail
   908 					lda (ztmp10),y		; if length2 = 0
   909 					beq fail
   910
   911 					lda (ztmp8),y		; if length1 <> length2
   912 					cmp (ztmp10),y
   913 					bne fail
   914
   915 					sta max
   916
   917 					inw ztmp8
   918 					inw ztmp10
   919
   920 2DD2			loop	lda (ztmp8),y
   921 					cmp (ztmp10),y
   922 					bne fail
   923
   924 					iny
   925
   926 					cpy #0
   927 2DD2			max	equ *-1
   928 					bne loop
   929
   930 					lda #0
   931 					seq
   932
   933 2DD2			fail	lda #$ff
   934
   935 					ldy #1
   936
   937 					cmp #0
   938 					rts
   939 				.endp
   940
   941
   942 2DD2			.proc	notaBX
   943
   944 					.rept MAXSIZE
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   946 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					.ENDR
   948 					.endr
Source: REPT
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   949
   950 					rts
   951 				.endp
   952
   953
   954 2DD2			.proc	notBOOLEAN
   955 					lda :STACKORIGIN,x
   956 					bne _0
   957
   958 					lda #true
   959 					sne
   960
   961 2DD2			_0	lda #false
   962 					sta :STACKORIGIN,x
   963
   964 					rts
   965 				.endp
   966
   967
   968 2DD2			.proc	negBYTE
   969 					lda #$00
   970 					sub :STACKORIGIN,x
   971 					sta :STACKORIGIN,x
   972
   973 					lda #$00
   974 					sbc #$00
   975 					sta :STACKORIGIN+STACKWIDTH,x
   976
   977 					lda #$00
   978 					sbc #$00
   979 					sta :STACKORIGIN+STACKWIDTH*2,x
   980
   981 					lda #$00
   982 					sbc #$00
   983 					sta :STACKORIGIN+STACKWIDTH*3,x
   984
   985 					rts
   986 				.endp
   987
   988 2DD2			.proc	negWORD
   989 					lda #$00
   990 					sub :STACKORIGIN,x
   991 					sta :STACKORIGIN,x
   992
   993 					lda #$00
   994 					sbc :STACKORIGIN+STACKWIDTH,x
   995 					sta :STACKORIGIN+STACKWIDTH,x
   996
   997 					lda #$00
   998 					sbc #$00
   999 					sta :STACKORIGIN+STACKWIDTH*2,x
  1000
  1001 					lda #$00
  1002 					sbc #$00
  1003 					sta :STACKORIGIN+STACKWIDTH*3,x
  1004
  1005 					rts
  1006 				.endp
  1007
  1008 2DD2			.proc	negCARD
  1009 2DD2 A9 00			lda #$00
  1010 2DD4 38 F5 98			sub :STACKORIGIN,x
  1011 2DD7 95 98			sta :STACKORIGIN,x
  1012
  1013 2DD9 A9 00			lda #$00
  1014 2DDB F5 A8			sbc :STACKORIGIN+STACKWIDTH,x
  1015 2DDD 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1016
  1017 2DDF A9 00			lda #$00
  1018 2DE1 F5 B8			sbc :STACKORIGIN+STACKWIDTH*2,x
  1019 2DE3 95 B8			sta :STACKORIGIN+STACKWIDTH*2,x
  1020
  1021 2DE5 A9 00			lda #$00
  1022 2DE7 F5 C8			sbc :STACKORIGIN+STACKWIDTH*3,x
  1023 2DE9 95 C8			sta :STACKORIGIN+STACKWIDTH*3,x
  1024
  1025 2DEB 60				rts
  1026 				.endp
  1027
  1028
  1029 2DEC			.proc	negBYTE1
  1030 					lda #$00
  1031 					sub :STACKORIGIN-1,x
  1032 					sta :STACKORIGIN-1,x
  1033
  1034 					lda #$00
  1035 					sbc #$00
  1036 					sta :STACKORIGIN-1+STACKWIDTH,x
  1037
  1038 					lda #$00
  1039 					sbc #$00
  1040 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1041
  1042 					lda #$00
  1043 					sbc #$00
  1044 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1045
  1046 					rts
  1047 				.endp
  1048
  1049 2DEC			.proc	negWORD1
  1050 					lda #$00
  1051 					sub :STACKORIGIN-1,x
  1052 					sta :STACKORIGIN-1,x
  1053
  1054 					lda #$00
  1055 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1056 					sta :STACKORIGIN-1+STACKWIDTH,x
  1057
  1058 					lda #$00
  1059 					sbc #$00
  1060 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1061
  1062 					lda #$00
  1063 					sbc #$00
  1064 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1065
  1066 					rts
  1067 				.endp
  1068
  1069 2DEC			.proc	negCARD1
  1070 					lda #$00
  1071 					sub :STACKORIGIN-1,x
  1072 					sta :STACKORIGIN-1,x
  1073
  1074 					lda #$00
  1075 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1076 					sta :STACKORIGIN-1+STACKWIDTH,x
  1077
  1078 					lda #$00
  1079 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1080 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1081
  1082 					lda #$00
  1083 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1084 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1085
  1086 					rts
  1087 				.endp
  1088
  1089
  1090 2DEC			.proc	andAL_CL
  1091
  1092 					lda :STACKORIGIN-1,x
  1093 					and :STACKORIGIN,x
  1094 					sta :STACKORIGIN-1,x
  1095
  1096 					rts
  1097 				.endp
  1098
  1099 2DEC			.proc	andAX_CX
  1100
  1101 					.rept 2
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1103 					AND :STACKORIGIN+#*STACKWIDTH,X
  1104 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					.ENDR
  1105 					.endr
Source: REPT
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1106
  1107 					rts
  1108 				.endp
  1109
  1110 2DEC			.proc	andEAX_ECX
  1111
  1112 					.rept MAXSIZE
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1114 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					.ENDR
  1116 					.endr
Source: REPT
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1117
  1118 					rts
  1119 				.endp
  1120
  1121
  1122 2DEC			.proc	orAL_CL
  1123
  1124 					lda :STACKORIGIN-1,x
  1125 					ora :STACKORIGIN,x
  1126 					sta :STACKORIGIN-1,x
  1127
  1128 					rts
  1129 				.endp
  1130
  1131 2DEC			.proc	orAX_CX
  1132
  1133 					.rept 2
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1135 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1136 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					.ENDR
  1137 					.endr
Source: REPT
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1138
  1139 					rts
  1140 				.endp
  1141
  1142 2DEC			.proc	orEAX_ECX
  1143
  1144 					.rept MAXSIZE
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1146 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					.ENDR
  1148 					.endr
Source: REPT
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1149
  1150 					rts
  1151 				.endp
  1152
  1153
  1154 2DEC			.proc	xorAL_CL
  1155
  1156 					lda :STACKORIGIN-1,x
  1157 					eor :STACKORIGIN,x
  1158 					sta :STACKORIGIN-1,x
  1159
  1160 					rts
  1161 				.endp
  1162
  1163 2DEC			.proc	xorAX_CX
  1164
  1165 					.rept 2
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1167 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1168 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					.ENDR
  1169 					.endr
Source: REPT
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1170
  1171 					rts
  1172 				.endp
  1173
  1174 2DEC			.proc	xorEAX_ECX
  1175
  1176 					.rept MAXSIZE
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1178 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					.ENDR
  1180 					.endr
Source: REPT
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1181
  1182 					rts
  1183 				.endp
  1184
  1185
  1186 				/*
  1187 				.proc	iniEAX_ECX_BYTE
  1188
  1189 					mva :STACKORIGIN,x ecx
  1190 					mva :STACKORIGIN-1,x eax
  1191
  1192 					rts
  1193 				.endp
  1194 				*/
  1194
  1195
  1196
  1197 2DEC			.proc	iniEAX_ECX_WORD
  1198
  1199 					mva :STACKORIGIN,x ecx
  1200 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1201
  1202 					mva :STACKORIGIN-1,x eax
  1203 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1204
  1205 					mva #$00 ecx+2
  1206 					sta ecx+3
  1207
  1208 					sta eax+2
  1209 					sta eax+3
  1210
  1211 					rts
  1212 				.endp
  1213
  1214
  1215 2DEC			.proc	iniEAX_ECX_CARD
  1216 					mva :STACKORIGIN,x ecx
  1217 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1218 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1219 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1220
  1221 					mva :STACKORIGIN-1,x eax
  1222 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1223 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1224 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1225
  1226 					rts
  1227 				.endp
  1228
  1229 2DEC			.proc	movZTMP_aBX
  1230 					mva ZTMP8 :STACKORIGIN-1,x
  1231 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1232 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1233 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1234
  1235 					rts
  1236 				.endp
  1237
  1238
  1239 2DEC				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 2DEC			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 2DEC			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 2DEC			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 2DEC			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 2DEC			lsector	:8 dta l(256)
    55 2DEC			hsector	:8 dta h(256)
    56
    57 				.endp
  1240 2DEC				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 2DEC			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 2DEC			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 2DEC			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 2DEC			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 2DEC			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 2DEC			msg	lda #true
    64 2DEC			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 2DEC			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 2DEC			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 2DEC			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 2DEC			lookup	ldx #$00
   110 					ldy #$01
   111 2DEC			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 2DEC			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 2DEC			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 2DEC			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 2DEC			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 2DEC			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 2DEC			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 2DEC			done	jsr eof
   247
   248 2DEC			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 2DEC			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 2DEC			quit	rts
   265
   266 2DEC			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 2DEC			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 2DEC			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 2DEC			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 2DEC			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 2DEC			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 2DEC			stp2
   336 					dey
   337 					tya
   338 2DEC			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 2DEC			attr	equ *-1
   343 					rts
   344
   345 2DEC			cpName	sta ln
   346 2DEC			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 2DEC			ln	equ *-1
   354 					bne cp
   355 2DEC			stp	rts
   356 				.endp
   357
  1241
  1242 2DEC				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 2DEC			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 2DEC			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 2DEC			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 2DEC			.proc	divmulSHORTINT
    31
    32 2DEC			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 2DEC			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 2DEC			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 2DEC			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 2DEC			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 2DEC			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 2DEC			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1243 2DEC				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 2DEC			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 2DEC			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 2DEC			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 2DEC			.proc	divmulSMALLINT
    37
    38 2DEC			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 2DEC			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 2DEC			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 2DEC			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 2DEC			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 2DEC			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 2DEC			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 2DEC			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1244 2DEC				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 2DEC			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 2DEC			.proc	divmulINT
    16
    17 2DEC			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 2DEC			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 2DEC			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 2DEC			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 2DEC			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 2DEC			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 2DEC			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 2DEC			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1245
  1246 2DEC				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 2DEC			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 2DEC			sm1:		lda square1_lo,x
    49 2DEC			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 2DEC			sm3:		lda square1_hi,x
    52 2DEC			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 2DEC			.proc	imulCL
    75
    76 2DEC A9 00			lda #$00
    77
    78 2DEE A0 09			LDY #$09
    79 2DF0 18				CLC
    80 2DF1 6A			LOOP	ROR @
    81 2DF2 66 82			ROR eax
    82 2DF4 90 03			BCC MUL2
    83 2DF6 18				CLC		;DEC AUX above to remove CLC
    84 2DF7 65 8A			ADC ecx
    85 2DF9 88			MUL2	DEY
    86 2DFA D0 F5			BNE LOOP
    87
    88 2DFC 85 83			STA eax+1
    89
    90 2DFE 60				RTS
    91 				.endp
    92
    93
    94 2DFF			.proc	imulBYTE
    95
    96 2DFF B5 98 85 8A			mva :STACKORIGIN,x ecx
    97 2E03 B5 97 85 82			mva :STACKORIGIN-1,x eax
    98
    99 2E07 A9 00			lda #$00
   100
   101 2E09 85 84			sta eax+2
   102 2E0B 85 85			sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 2E0D 4C EC 2D			jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 2E10			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 2E10			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 2E10			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 2E10			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1247 2E10				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 2E10			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 2E10			sm1a:		lda square1_lo,x
    78 2E10			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 2E10			sm3a:		lda square1_hi,x
    81 2E10			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 2E10			sm1b:		lda square1_lo,x
    88 2E10			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 2E10			sm3b:		lda square1_hi,x
    91 2E10			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 2E10			sm5a:		lda square1_lo,x
    98 2E10			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 2E10			sm7a:		lda square1_hi,x
   101 2E10			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 2E10			sm5b:		lda square1_lo,x
   107 2E10			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 2E10			sm7b:		lda square1_hi,x
   110 2E10			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 2E10			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 2E10			_BB_:		lda #0
   122 2E10			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 2E10			@
   129 						tya
   130 2E10			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 2E10			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 2E10			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 2E10			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 2E10			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 2E10			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 2E10			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 2E10			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 2E10			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 2E10			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 2E10			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1248 2E10				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 2E10			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 2E10			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 2E10			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 2E10			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 2E10			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 2E10			.proc	idivEAX_ECX
    74
    75 2E10			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 2E10			CARD	;jsr iniEAX_ECX_CARD
    81
    82 2E10			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 2E10			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 2E10			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1249
  1250 2E10				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 2E10			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 2E10			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 2E10			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 2E10			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1251 2E10				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 2E10			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 2E10			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 2E10			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 2E10			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 2E10			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 2E10			ecx3	equ *-1
    59 2E10			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 2E10			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 2E10			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 2E10			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 2E10			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 2E10			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 2E10			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 2E10			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 2E10			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 2E10			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 2E10			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 2E10			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 2E10			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1252 2E10				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 2E10			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 2E10			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 2E10			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 2E10			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 2E10			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 2E10			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 2E10			FADD:	LDA	#$00
   159 2E10			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 2E10			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 2E10			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 2E10			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 2E10			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 2E10			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 2E10			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 2E10			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 2E10			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 2E10			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 2E10			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 2E10			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 2E10			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 2E10			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 2E10			FPNORMLEFT1:	BMI	FPNORMDONE
   367 2E10			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 2E10			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 2E10			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 2E10			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 2E10			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 2E10			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 2E10			@	EOR	#$FF
   480 					LDX	#$08
   481 2E10			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 2E10			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 2E10			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 2E10			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 2E10			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 2E10			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 2E10			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 2E10			.proc	FCMPL
   605 2E10			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 2E10			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 2E10			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 2E10			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 2E10			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 2E10			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 2E10			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 2E10			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 2E10			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 2E10			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 2E10			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 2E10			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 2E10			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 2E10			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 2E10			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 2E10			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 2E10			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 2E10			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 2E10			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 2E10			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 2E10			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 2E10			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 2E10			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 2E10			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1253
  1254
  1255 2E10			.proc	@printCHAR
  1256 2E10 B4 98			ldy :STACKORIGIN,x
  1257 2E12 4C 1A 2E			jmp @print
  1258 				.endp
  1259
  1260
  1261 2E15			.proc	@printEOL
  1262 2E15 A0 9B			ldy #eol
  1263 2E17 4C 1A 2E			jmp @print
  1264 				.endp
  1265
  1266
  1267 2E1A			.proc	@print (.byte y) .reg
  1268 2E1A 8A 48			txa:pha
  1269
  1270 2E1C 98				tya
  1271 2E1D 20 14 2F			jsr @putchar
  1272
  1273 2E20 68 AA			pla:tax
  1274 2E22 60				rts
  1275 				.endp
  1276
  1277
  1278 2E23			.proc	@printPCHAR (.word ya) .reg
  1279 					sta addr
  1280 					sty addr+1
  1281
  1282 					stx @sp
  1283
  1284 					lda #0
  1285 					sta loop+1
  1286
  1287 2E23			loop	ldy #0
  1288 					lda $ffff,y
  1289 2E23			addr	equ *-2
  1290 					beq stop
  1291
  1292 					inc loop+1
  1293 					beq stop
  1294
  1295 					jsr @putchar
  1296
  1297 					jmp loop
  1298
  1299 2E23			stop	ldx #0
  1300 2E23			@sp	equ *-1
  1301 					rts
  1302 				.endp
  1303
  1304
  1305 2E23			.proc	@printSTRING (.word ya) .reg
  1306 2E23 85 92			sta ztmp
  1307 2E25 84 93			sty ztmp+1
  1308
  1309 2E27 8E 4C 2E			stx @sp
  1310
  1311 2E2A A0 00			ldy #0
  1312 2E2C 8C 3B 2E			sty loop+1
  1313 2E2F B1 92			lda (ztmp),y
  1314 2E31 8D 3F 2E			sta ln
  1315
  1316 2E34 E6 92 D0 02 E6 93		inw ztmp
  1317
  1318 2E3A A0 00		loop	ldy #0
  1319 2E3C B1 92			lda (ztmp),y
  1320 				;	beq stop
  1321
  1322 2E3E C0 00			cpy #0
  1323 = 2E3F			ln	equ *-1
  1324 2E40 F0 09			beq stop
  1325
  1326 2E42 EE 3B 2E			inc loop+1
  1327
  1328 2E45 20 14 2F			jsr @putchar
  1329
  1330 2E48 4C 3A 2E			jmp loop
  1331
  1332 2E4B A2 00		stop	ldx #0
  1333 = 2E4C			@sp	equ *-1
  1334 2E4D 60				rts
  1335 				.endp
  1336
  1337
  1338 2E4E			.proc	@printBOOLEAN
  1339 					lda :STACKORIGIN,x
  1340 					beq _0
  1341
  1342 2E4E			_1	lda <_true
  1343 					ldy >_true
  1344 					jmp @printSTRING
  1345
  1346 2E4E			_0	lda <_false
  1347 					ldy >_false
  1348 					jmp @printSTRING
  1349
  1350 2E4E			_true	dta 4,c'TRUE'
  1351 2E4E			_false	dta 5,c'FALSE'
  1352 				.endp
  1353
  1354
  1355 2E4E			.proc	mov_BYTE_DX
  1356 					mva :STACKORIGIN,x dx
  1357 					mva #$00 dx+1
  1358 					sta dx+2
  1359 					sta dx+3
  1360
  1361 					rts
  1362 				.endp
  1363
  1364 2E4E			.proc	mov_WORD_DX
  1365 					mva :STACKORIGIN,x dx
  1366 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1367 					mva #$00 dx+2
  1368 					sta dx+3
  1369
  1370 					rts
  1371 				.endp
  1372
  1373 2E4E			.proc	mov_CARD_DX
  1374 2E4E B5 98 85 86			mva :STACKORIGIN,x dx
  1375 2E52 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x dx+1
  1376 2E56 B5 B8 85 88			mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1377 2E5A B5 C8 85 89			mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1378
  1379 2E5E 60				rts
  1380 				.endp
  1381
  1382
  1383 2E5F			.proc	@printMINUS
  1384 2E5F A0 2D			ldy #'-'
  1385 2E61 20 CD 2E			jsr @printVALUE.pout
  1386
  1387 2E64 4C D2 2D			jmp negCARD
  1388 				.endp
  1389
  1390
  1391 2E67			.proc	@printSHORTREAL
  1392 					jsr @expandToCARD.SMALL
  1393 					jmp @printREAL
  1394 				.endp
  1395
  1396
  1397 2E67			.proc	@FTOA
  1398
  1399 = 0086			i	= edx
  1400 = 008A			fra	= ecx
  1401 = 0082			hlp	= eax
  1402
  1403 = 0092			exp	= ztmp
  1404 = 0093			b	= ztmp+1
  1405 = 0094			sht	= ztmp+2
  1406
  1407 = 0440			bit	= @buf+64
  1408
  1409 					stx @sp
  1410
  1411 					mva :STACKORIGIN,x I
  1412 					sta :STACKORIGIN+9
  1413 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1414 					sta :STACKORIGIN+STACKWIDTH+9
  1415 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1416 					sta :STACKORIGIN+STACKWIDTH*2+9
  1417 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1418 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1419
  1420 					bpl skp
  1421
  1422 					ldy #'-'
  1423 					jsr @printVALUE.pout
  1424
  1425 2E67			skp
  1426 				; optimize OK (test_3.pas), line = 32
  1427
  1428 					lda :STACKORIGIN+STACKWIDTH*3+9
  1429 					asl :STACKORIGIN+9
  1430 					rol :STACKORIGIN+STACKWIDTH+9
  1431 					rol :STACKORIGIN+STACKWIDTH*2+9
  1432 					rol @
  1433 					sta EXP				; Exponent
  1434
  1435 				; optimize OK (test_3.pas), line = 33
  1436
  1437 					lda I
  1438 					sta FRA
  1439 					lda I+1
  1440 					sta FRA+1
  1441 					lda I+2
  1442 					sta FRA+2
  1443 					lda I+3
  1444 					sta FRA+3
  1445 					asl FRA
  1446 					rol FRA+1
  1447 					rol FRA+2
  1448 					rol FRA+3
  1449
  1450 				; optimize OK (test_3.pas), line = 35
  1451
  1452 					lda EXP
  1453 					sub #$7F
  1454 					sta SHT
  1455
  1456 				; optimize OK (test_3.pas), line = 37
  1457
  1458 					ldx #$3f
  1459 					lda #0
  1460 					sta:rpl bit,x-
  1461
  1462 				; For
  1463
  1464 				; optimize OK (test_3.pas), line = 39
  1465
  1466 				;	sta B
  1467 					tax
  1468
  1469 				; optimize OK (test_3.pas), line = 39
  1470
  1471 2E67			l_01D4
  1472 				;	lda B
  1473 				;	cmp #$17
  1474 					cpx #$17
  1475 					bcc *+7
  1476 					beq *+5
  1477
  1478 				; ForToDoProlog
  1479 					jmp l_01EE
  1480
  1481 				; optimize OK (test_3.pas), line = 40
  1482
  1483 				;	lda #$20
  1484 				;	add B
  1485 				;	tax
  1486
  1487 					lda FRA+2
  1488 					sta BIT+$20,x
  1489
  1490 				; optimize OK (test_3.pas), line = 41
  1491
  1492 					asl FRA
  1493 					rol FRA+1
  1494 					rol FRA+2
  1495 					rol FRA+3
  1496
  1497 				; ForToDoEpilog
  1498 2E67			c_01D4
  1499 				;	inc B
  1500 					inx
  1501
  1502 					seq
  1503
  1504 				; WhileDoEpilog
  1505 					jmp l_01D4
  1506 2E67			l_01EE
  1507 2E67			b_01D4
  1508
  1509 				; optimize OK (test_3.pas), line = 44
  1510
  1511 					mva #$80 BIT+$1f
  1512
  1513 				; optimize OK (test_3.pas), line = 46
  1514
  1515 					mva #$00 I
  1516 					sta I+1
  1517 					sta I+2
  1518 					sta I+3
  1519
  1520 				; optimize OK (test_3.pas), line = 47
  1521
  1522 					sta FRA+1
  1523 					sta FRA+2
  1524 					sta FRA+3
  1525
  1526 					mva #$01 FRA
  1527
  1528 				; For
  1529
  1530 				; optimize OK (test_3.pas), line = 49
  1531
  1532 					lda SHT
  1533 					add #$1F
  1534 					sta B
  1535
  1536 				; optimize OK (test_3.pas), line = 49
  1537
  1538 					tay
  1539
  1540 2E67			l_035B
  1541 				;	lda B
  1542 				;	cmp #$00
  1543 				;	bcs *+5
  1544
  1545 				; ForToDoProlog
  1546 				;	jmp l_0375
  1547
  1548 				; optimize OK (test_3.pas), line = 50
  1549
  1550 				;	ldy B
  1551 					lda BIT,y
  1552 					bpl l_03D7
  1553
  1554 				; optimize OK (test_3.pas), line = 50
  1555
  1556 					lda I				; Mantissa
  1557 					add FRA
  1558 					sta I
  1559 					lda I+1
  1560 					adc FRA+1
  1561 					sta I+1
  1562 					lda I+2
  1563 					adc FRA+2
  1564 					sta I+2
  1565 					lda I+3
  1566 					adc FRA+3
  1567 					sta I+3
  1568
  1569 				; IfThenEpilog
  1570 2E67			l_03D7
  1571
  1572 				; optimize OK (test_3.pas), line = 52
  1573
  1574 					asl FRA
  1575 					rol FRA+1
  1576 					rol FRA+2
  1577 					rol FRA+3
  1578
  1579 				; ForToDoEpilog
  1580 2E67			c_035B
  1581 				;	dec B
  1582 					dey
  1583
  1584 				;	lda B
  1585 				;	cmp #$ff
  1586 					cpy #$ff
  1587 					seq
  1588
  1589 				; WhileDoEpilog
  1590 					jmp l_035B
  1591 2E67			l_0375
  1592 2E67			b_035B
  1593
  1594 				; optimize OK (test_3.pas), line = 55
  1595
  1596 					mva #$00 FRA
  1597 					sta FRA+1
  1598 					sta FRA+2
  1599 					sta FRA+3
  1600
  1601 				; optimize OK (test_3.pas), line = 56
  1602
  1603 					sta EXP
  1604
  1605 					sta hlp
  1606 					sta hlp+1
  1607
  1608 					lda #$80
  1609 					sta hlp+2
  1610 				; For
  1611
  1612 				; optimize OK (test_3.pas), line = 58
  1613
  1614 					lda SHT
  1615 					add #$20
  1616 				;	sta B
  1617
  1618 					tay
  1619
  1620 				; optimize OK (test_3.pas), line = 58
  1621
  1622 					add #23
  1623 					sta FORTMP_1273
  1624 				; To
  1625 2E67			l_0508
  1626
  1627 				; ForToDoCondition
  1628
  1629 				; optimize OK (test_3.pas), line = 58
  1630
  1631 				;	lda B
  1632 				;	cmp #0
  1633 					cpy #0
  1634 2E67			FORTMP_1273	equ *-1
  1635 					bcc *+7
  1636 					beq *+5
  1637
  1638 				; ForToDoProlog
  1639 					jmp l_0534
  1640
  1641 				; optimize OK (test_3.pas), line = 59
  1642
  1643 				;	ldy B
  1644 					lda BIT,y
  1645 					bpl l_0596
  1646
  1647 				; optimize OK (test_3.pas), line = 59
  1648
  1649 					lda FRA
  1650 					add hlp
  1651 					sta FRA
  1652 					lda FRA+1
  1653 					adc hlp+1
  1654 					sta FRA+1
  1655 					lda FRA+2
  1656 					adc hlp+2
  1657 					sta FRA+2
  1658
  1659 				; IfThenEpilog
  1660 2E67			l_0596
  1661
  1662 					lsr hlp+2
  1663 					ror hlp+1
  1664 					ror hlp
  1665
  1666 				; ForToDoEpilog
  1667 2E67			c_0508
  1668 				;	inc B						; inc ptr byte [CounterAddress]
  1669 					iny
  1670
  1671 					seq
  1672
  1673 				; WhileDoEpilog
  1674 					jmp l_0508
  1675 2E67			l_0534
  1676 2E67			b_0508
  1677 2E67				:3 mva fra+# fracpart+#
  1678
  1679 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1680 					@float #500000
  1681
  1682 					ldx #0
  1683 2E67			@sp	equ *-1
  1684
  1685 					rts
  1686 				.endp
  1687
  1688
  1689 2E67			.proc	@printREAL
  1690
  1691 					stx @sp
  1692
  1693 					lda :STACKORIGIN+STACKWIDTH*3,x
  1694 					spl
  1695 					jsr @printMINUS
  1696
  1697 					jsr mov_CARD_DX
  1698
  1699 					mva dx+1 intpart		; intpart := uvalue shr 8
  1700 					mva dx+2 intpart+1
  1701 					mva dx+3 intpart+2
  1702 					mva #$00 intpart+3
  1703
  1704 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1705 					sta dx+2
  1706 					sta dx+1
  1707
  1708 					sta fracpart
  1709 					sta fracpart+1
  1710
  1711 					lda dx
  1712 					sta fracpart+2
  1713
  1714 2E67				:4 mva intpart+# dx+#		; integer part
  1715
  1716 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1717 					@float #5000
  1718
  1719 					ldx #0
  1720 2E67			@sp	equ *-1
  1721 					rts
  1722
  1723 2E67 00 00 00 00		intpart		.dword
  1724
  1725 				.endp
  1726
  1727
  1728 2E6B			.proc	@float (.long axy) .reg
  1729
  1730 					sty cx
  1731 					stx cx+1
  1732 					sta cx+2
  1733
  1734 					lda @printVALUE.pout		; print integer part
  1735 					pha
  1736 					jsr @printVALUE
  1737 					pla
  1738 					sta @printVALUE.pout
  1739
  1740 					lda #0
  1741 					sta dx
  1742 					sta dx+1
  1743 					sta dx+2
  1744 					sta dx+3
  1745
  1746 2E6B			loop	lda fracpart+2
  1747 					bpl skp
  1748
  1749 					clc
  1750 				;	lda cx
  1751 				;	spl
  1752 				;	sec
  1753
  1754 					lda dx
  1755 					adc cx
  1756 					sta dx
  1757 					lda dx+1
  1758 					adc cx+1
  1759 					sta dx+1
  1760 					lda dx+2
  1761 					adc cx+2
  1762 					sta dx+2
  1763 				;	lda dx+3
  1764 				;	adc #0
  1765 				;	sta dx+3
  1766
  1767 2E6B			skp	lsr cx+2
  1768 					ror cx+1
  1769 					ror cx
  1770
  1771 					asl fracpart
  1772 					rol fracpart+1
  1773 					rol fracpart+2
  1774
  1775 					lda cx
  1776 					ora cx+1
  1777 					ora cx+2
  1778
  1779 					bne loop
  1780
  1781 					ldy #'.'
  1782 					jsr @printVALUE.pout
  1783
  1784 2E6B				:4 mva dx+# fracpart+#
  1785
  1786 					lda @printVALUE.pout
  1787 					pha
  1788
  1789 					lda #{rts}
  1790 					sta @printVALUE.pout
  1791 					jsr @printVALUE			; floating part length
  1792
  1793 					sta cnt
  1794
  1795 					pla
  1796 					sta @printVALUE.pout
  1797
  1798 2E6B			lp	lda #0
  1799 2E6B			cnt	equ *-1
  1800 					cmp #4				; N miejsc po przecinku
  1801 2E6B			afterpoint equ *-1
  1802 					bcs ok
  1803
  1804 					ldy #'0'
  1805 					jsr @printVALUE.pout
  1806
  1807 					inc cnt
  1808 					bne lp
  1809
  1810 2E6B			ok	:4 mva fracpart+# dx+#
  1811 					jmp @printVALUE			; print floating part
  1812
  1813 				.endp
  1814
  1815
  1816 2E6B			.proc	@printSHORTINT
  1817
  1818 					lda :STACKORIGIN,x
  1819 					spl
  1820 					jsr @printMINUS
  1821
  1822 					jmp @printBYTE
  1823 				.endp
  1824
  1825
  1826 2E6B			.proc	@printSMALLINT
  1827
  1828 					lda :STACKORIGIN+STACKWIDTH,x
  1829 					spl
  1830 					jsr @printMINUS
  1831
  1832 					jmp @printWORD
  1833 				.endp
  1834
  1835
  1836 2E6B			.proc	@printINT
  1837
  1838 2E6B B5 C8			lda :STACKORIGIN+STACKWIDTH*3,x
  1839 2E6D 10 03			spl
  1840 2E6F 20 5F 2E			jsr @printMINUS
  1841
  1842 2E72 4C 75 2E			jmp @printCARD
  1843 				.endp
  1844
  1845
  1846 2E75			.proc	@printCARD
  1847 2E75 20 4E 2E			jsr mov_CARD_DX
  1848 2E78 4C 7B 2E			jmp @printVALUE
  1849 				.endp
  1850
  1851
  1852 2E7B			.proc	@printWORD
  1853 					jsr mov_WORD_DX
  1854 					jmp @printVALUE
  1855 				.endp
  1856
  1857
  1858 2E7B			.proc	@printBYTE
  1859 					jsr mov_BYTE_DX
  1860 					jmp @printVALUE
  1861 				.endp
  1862
  1863
  1864 2E7B			.proc	@printVALUE
  1865
  1866 2E7B A5 89			lda dx+3
  1867 2E7D D0 14			bne _32bit
  1868
  1869 2E7F A5 88			lda dx+2
  1870 2E81 D0 0C			bne _24bit
  1871
  1872 2E83 A5 87			lda dx+1
  1873 2E85 D0 04			bne _16bit
  1874
  1875 2E87 A9 03		_8bit	lda #3
  1876 2E89 D0 0A			bne l3
  1877
  1878 2E8B A9 05		_16bit	lda #5
  1879 2E8D D0 06			bne l3
  1880
  1881 2E8F A9 08		_24bit	lda #8
  1882 2E91 D0 02			bne l3
  1883
  1884 					; prints a 32 bit value to the screen (Graham)
  1885
  1886 2E93 A9 0A		_32bit	lda #10
  1887
  1888 2E95 8D A8 2E		l3	sta limit
  1889
  1890 2E98 8E CB 2E			stx @sp
  1891
  1892 2E9B A2 00			ldx #0
  1893 2E9D 8E C9 2E			stx cnt
  1894
  1895 2EA0 20 E1 2E		lp	jsr div10
  1896
  1897 2EA3 9D D7 2E			sta tmp,x
  1898 2EA6 E8				inx
  1899 2EA7 E0 0A			cpx #10
  1900 = 2EA8			limit	equ *-1
  1901 2EA9 D0 F5			bne lp
  1902
  1903 					;ldx #9
  1904 2EAB CA				dex
  1905
  1906 2EAC BD D7 2E		l1	lda tmp,x
  1907 2EAF D0 03			bne l2
  1908 2EB1 CA				dex		; skip leading zeros
  1909 2EB2 D0 F8			bne l1
  1910
  1911 2EB4 BD D7 2E		l2	lda tmp,x
  1912 2EB7 09 30			ora #$30
  1913 2EB9 A8				tay
  1914
  1915 2EBA 20 CD 2E			jsr pout
  1916 2EBD EE C9 2E			inc cnt
  1917
  1918 2EC0 CA				dex
  1919 2EC1 10 F1			bpl l2
  1920
  1921 2EC3 A9 4C 8D CD 2E		mva #{jmp*} pout
  1922
  1923 2EC8 A9 00			lda #0
  1924 = 2EC9			cnt	equ *-1
  1925
  1926 2ECA A2 00			ldx #0
  1927 = 2ECB			@sp	equ *-1
  1928 2ECC 60				rts
  1929
  1930 2ECD 4C 1A 2E		pout	jmp @print
  1931
  1932 2ED0 8C 01 04			sty @buf+1
  1933 = 2ED1			pbuf	equ *-2
  1934 2ED3 EE D1 2E			inc pbuf
  1935
  1936 2ED6 60				rts
  1937
  1938 2ED7 00 00 00 00 00 00 + tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1939
  1940 				.endp
  1941
  1942
  1943 				; divides a 32 bit value by 10
  1944 				; remainder is returned in akku
  1945
  1946 2EE1			.proc	div10
  1947 2EE1 A0 20		        ldy #32		; 32 bits
  1948 2EE3 A9 00		        lda #0
  1949 2EE5 18			        clc
  1950 2EE6 2A			l4      rol @
  1951 2EE7 C9 0A		        cmp #10
  1952 2EE9 90 02		        bcc skip
  1953 2EEB E9 0A		        sbc #10
  1954 2EED 26 86		skip    rol dx
  1955 2EEF 26 87		        rol dx+1
  1956 2EF1 26 88		        rol dx+2
  1957 2EF3 26 89		        rol dx+3
  1958 2EF5 88			        dey
  1959 2EF6 10 EE		        bpl l4
  1960
  1961 2EF8 60				rts
  1962 				.endp
  1963
  1964
  1965 2EF9			.proc	@hexStr
  1966
  1967 = 0086			Value	= edx
  1968 = 008A			Digits	= ecx
  1969
  1970 					ldx Digits
  1971 					cpx #32
  1972 					scc
  1973 					ldx #32
  1974
  1975 					stx Digits
  1976
  1977 					lda Value
  1978 					jsr hex
  1979 					lda Value+1
  1980 					jsr hex
  1981 					lda Value+2
  1982 					jsr hex
  1983 					lda Value+3
  1984 					jsr hex
  1985
  1986 					lda Digits
  1987 					sta @buf
  1988 					rts
  1989
  1990 2EF9			hex	pha
  1991 					and #$f
  1992 					jsr put
  1993 					pla
  1994 2EF9				:4 lsr @
  1995 2EF9			put	tay
  1996 					lda thex,y
  1997 					sta @buf,x
  1998 					dex
  1999 					rts
  2000
  2001 2EF9			thex	dta c'0123456789ABCDEF'
  2002 				.endp
  2003
  2004
  2005 2EF9			.proc	@ValueToStr (.word ya) .reg
  2006
  2007 2EF9 8D 0A 2F			sta adr
  2008 2EFC 8C 0B 2F			sty adr+1
  2009
  2010 2EFF A9 2C 8D CD 2E		mva #{bit*} @printVALUE.pout
  2011 2F04 A9 01 8D D1 2E		mva <@buf+1 @printVALUE.pbuf
  2012
  2013 2F09 20 FF FF			jsr $ffff
  2014 = 2F0A			adr	equ *-2
  2015
  2016 2F0C AC D1 2E			ldy @printVALUE.pbuf
  2017 2F0F 88				dey
  2018 2F10 8C 00 04			sty @buf
  2019
  2020 2F13 60				rts
  2021 				.endp
  2022
  2023
  2024 				;	ecx	isSign
  2025 				;	edx	Result
  2026
  2027 2F14			.proc	@StrToInt (.word ya) .reg
  2028
  2029 					sta bp2
  2030 					sty bp2+1
  2031
  2032 					ldy #0
  2033 					sty MAIN.SYSTEM.IOResult
  2034 					sty edx
  2035 					sty edx+1
  2036 					sty edx+2
  2037 					sty edx+3
  2038
  2039 					lda (bp2),y
  2040 					beq stop
  2041 					sta len
  2042
  2043 					inw bp2
  2044
  2045 					lda (bp2),y
  2046 					cmp #'-'
  2047 					sne
  2048 					iny
  2049
  2050 					sty ecx
  2051
  2052 2F14			l1	lda (bp2),y
  2053
  2054 					CLC
  2055 					ADC #$FF-'9'	; make m = $FF
  2056 					ADC #'9'-'0'+1	; carry set if in range n to m
  2057 					bcs ok
  2058
  2059 					lda #106	; Invalid numeric format
  2060 					sta MAIN.SYSTEM.IOResult
  2061
  2062 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2063
  2064 2F14			ok	jsr fmul10
  2065
  2066 					lda (bp2),y
  2067 					sub #$30
  2068 					sta ztmp
  2069
  2070 					lda #$00
  2071 					sta ztmp+1
  2072 					sta ztmp+2
  2073 					sta ztmp+3
  2074
  2075 					jsr fmul10.add32bit
  2076
  2077 					iny
  2078 					cpy #0
  2079 2F14			len	equ *-1
  2080 					bne l1
  2081
  2082 					lda ecx
  2083 					beq stop
  2084
  2085 					jsr negEDX
  2086
  2087 2F14			stop	ldy #0		; reg Y = 0 conversion successful
  2088 					rts
  2089 				.endp
  2090
  2091
  2092 2F14			.proc	negEDX
  2093 					lda #$00	; minus
  2094 					sub edx
  2095 					sta edx
  2096
  2097 					lda #$00
  2098 					sbc edx+1
  2099 					sta edx+1
  2100
  2101 					lda #$00
  2102 					sbc edx+2
  2103 					sta edx+2
  2104
  2105 					lda #$00
  2106 					sbc edx+3
  2107 					sta edx+3
  2108
  2109 					rts
  2110 				.endp
  2111
  2112
  2113 2F14			.proc	fmul10
  2114 					asl edx		;multiply by 2
  2115 					rol edx+1	;temp store in ZTMP
  2116 					rol edx+2
  2117 					rol edx+3
  2118
  2119 					lda edx
  2120 					sta ztmp
  2121 					lda edx+1
  2122 					sta ztmp+1
  2123 					lda edx+2
  2124 					sta ztmp+2
  2125 					lda edx+3
  2126 					sta ztmp+3
  2127
  2128 					asl edx
  2129 					rol edx+1
  2130 					rol edx+2
  2131 					rol edx+3
  2132
  2133 					asl edx
  2134 					rol edx+1
  2135 					rol edx+2
  2136 					rol edx+3
  2137
  2138 2F14			add32bit
  2139 					lda edx
  2140 					add ztmp
  2141 					sta edx
  2142 					lda edx+1
  2143 					adc ztmp+1
  2144 					sta edx+1
  2145 					lda edx+2
  2146 					adc ztmp+2
  2147 					sta edx+2
  2148 					lda edx+3
  2149 					adc ztmp+3
  2150 					sta edx+3
  2151
  2152 					rts
  2153 				.endp
  2154
  2155
  2156 2F14			.proc	@trunc
  2157
  2158 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2159 					spl
  2160 					jsr negCARD
  2161
  2162 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2163 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2164 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2165 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2166
  2167 					tya
  2168 					spl
  2169 					jsr negCARD
  2170
  2171 					rts
  2172 				.endp
  2173
  2174
  2175 2F14			.proc	@round
  2176
  2177 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2178 					spl
  2179 					jsr negCARD
  2180
  2181 					lda :STACKORIGIN,x
  2182 				//	add #$80
  2183 					cmp #$80
  2184 					lda :STACKORIGIN+STACKWIDTH,x
  2185 					adc #0
  2186 					sta :STACKORIGIN,x
  2187 					lda :STACKORIGIN+STACKWIDTH*2,x
  2188 					adc #0
  2189 					sta :STACKORIGIN+STACKWIDTH,x
  2190 					lda :STACKORIGIN+STACKWIDTH*3,x
  2191 					adc #0
  2192 					sta :STACKORIGIN+STACKWIDTH*2,x
  2193
  2194 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2195
  2196 					tya
  2197 					spl
  2198 					jsr negCARD
  2199
  2200 					rts
  2201 				.endp
  2202
  2203
  2204 2F14			.proc	@frac
  2205
  2206 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2207 					spl
  2208 					jsr negCARD
  2209
  2210 					lda #$00
  2211 					sta :STACKORIGIN+STACKWIDTH,x
  2212 					sta :STACKORIGIN+STACKWIDTH*2,x
  2213 					sta :STACKORIGIN+STACKWIDTH*3,x
  2214
  2215 					tya
  2216 					spl
  2217 					jsr negCARD
  2218
  2219 					rts
  2220 				.endp
  2221
  2222
  2223 2F14			.proc	@int
  2224
  2225 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2226 					spl
  2227 					jsr negCARD
  2228
  2229 					lda #$00
  2230 					sta :STACKORIGIN,x
  2231
  2232 					tya
  2233 					spl
  2234 					jsr negCARD
  2235
  2236 					rts
  2237 				.endp
  2238
  2239
  2240 				;----------------------------;
  2241 				; Biblioteka procedur        ;
  2242 				; graficznych                ;
  2243 				;----------------------------;
  2244 				; Autorzy:                   ;
  2245 				;  Slawomir 'SERO' Ritter,   ;
  2246 				;  Jakub Cebula,             ;
  2247 				;  Winfried Hofacker         ;
  2248 				;----------------------------;
  2249 				; Wersja:1.1 DATA:09.01.2008 ;
  2250 				;----------------------------;
  2251
  2252 = 0003			@open	= $03		; Otworz kanal
  2253 = 000C			@close	= $0c		; Zamknij kanal
  2254
  2255 = 0007			@IDget	= $07		; Narysuj punkt
  2256 = 0009			@IDput	= $09		; Narysuj punkt
  2257 = 0011			@IDdraw	= $11		; Narysuj linie
  2258 = 0012			@IDfill	= $12		; Wypelnij obszar
  2259
  2260
  2261 				;------------------------;
  2262 				;Wy:.Y-numer bledu (1-OK);
  2263 				;   f(N)=1-wystapil blad ;
  2264 				;------------------------;
  2265 2F14			.proc	@COMMAND
  2266
  2267 					ldx	#$00
  2268 2F14			scrchn	equ *-1
  2269
  2270 					sta	iocom,x
  2271
  2272 					lda	#$00
  2273 2F14			colscr	equ *-1
  2274 					sta	atachr
  2275
  2276 					jmp	ciov
  2277 				.endp
  2278
  2279 				;------------------------;
  2280 				; Ustaw tryb ekranu      ;
  2281 				;------------------------;
  2282 				;We:.X-numer kanalu      ;
  2283 				;      (normalnie 0)     ;
  2284 				;   .Y-numer trybu (O.S.);
  2285 				;   .A-Ustawiony bit nr :;
  2286 				;     5-Nie kasowanie    ;
  2287 				;       pamieci ekranu   ;
  2288 				;     4-Obecnosc okna    ;
  2289 				;       tekstowego       ;
  2290 				;     2-Odczyt z ekranu  ;
  2291 				;------------------------;
  2292 				;Wy:SCRCHN-numer kanalu  ;
  2293 				;  .Y-numer bledu (1-OK) ;
  2294 				;   f(N)=1 wystapil blad ;
  2295 				;------------------------;
  2296 2F14			@GRAPHICS .proc (.byte x,y,a) .reg
  2297
  2298 					sta	byte1
  2299 					sty	byte2
  2300
  2301 					stx	@COMMAND.scrchn
  2302
  2303 					lda	#@close
  2304 					jsr	xcio
  2305
  2306 					lda	#0		; =opcje
  2307 2F14			byte1	equ	*-1
  2308 					ora	#8		; +zapis na ekranie
  2309 					sta	ioaux1,x
  2310
  2311 					lda	#0
  2312 2F14			byte2	equ	*-1
  2313 					sta	ioaux2,x	;=nr.trybu
  2314
  2315 					mwa	#sname	ioadr,x
  2316
  2317 					lda	#@open
  2318
  2319 2F14			xcio	sta iocom,x
  2320 					jmp ciov
  2321
  2322 2F14			sname	dta c'S:',$9b
  2323
  2324 					.endp
  2325
  2326
  2327 2F14			.proc	@ata2int
  2328 				        asl
  2329 				        php
  2330 				        cmp #2*$60
  2331 				        bcs @+
  2332 				        sbc #2*$20-1
  2333 				        bcs @+
  2334 				        adc #2*$60
  2335 2F14			@       plp
  2336 				        ror
  2337 					rts
  2338 				.endp
  2339
  2340
  2341 				/*
  2342 				  PUT CHAR
  2343
  2344 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2345 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2346 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2347
  2348 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2349 				  JSR PUTCHR.
  2350 				*/
  2350
  2351
  2352 2F14			.proc	@putchar (.byte a) .reg
  2353
  2354 2F14 2C 14 2F		vbxe	bit *
  2355
  2356 2F17 A2 00			ldx #$00
  2357 					.ifdef MAIN.CRT.TextAttr
  2358 2F19 0D 60 33			ora MAIN.CRT.TextAttr
  2359 					.endif
  2360 2F1C A8				tay
  2361 2F1D BD 47 03			lda icputb+1,x
  2362 2F20 48				pha
  2363 2F21 BD 46 03			lda icputb,x
  2364 2F24 48				pha
  2365 2F25 98				tya
  2366
  2367 2F26 60				rts
  2368
  2369 				.endp
  2370
  2371
  2372 				/*
  2373 				  GETLINE
  2374
  2375 				  Program czeka, az uzytkownik wpisze ciag znakï¿½w z klawiatury i nacisnie klawisz RETURN.
  2376 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2377 				  (odczyt jest robiony z edytora ekranowego).
  2378
  2379 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2380 				  do rejestrï¿½w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2381
  2382 				*/
  2382
  2383
  2384 2F27			.proc	@GetLine
  2385
  2386 					stx @sp
  2387
  2388 					ldx #0
  2389
  2390 					stx MAIN.SYSTEM.EoLn
  2391
  2392 					mwa	#@buf+1	icbufa,x
  2393
  2394 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2395
  2396 					mva	#$05	iccmd,x
  2397
  2398 					jsr	ciov
  2399
  2400 					dew icbufl
  2401 					mva icbufl @buf			; length
  2402
  2403 					ldx @buf+1
  2404 					cpx #EOL
  2405 					bne skp
  2406
  2407 					ldx #TRUE
  2408 					stx MAIN.SYSTEM.EoLn
  2409 2F27			skp
  2410 					ldx #0
  2411 2F27			@sp	equ *-1
  2412
  2413 					rts
  2414 				.endp
  2415
  2416
  2417 2F27			.proc	@GetKey
  2418
  2419 2F27 AD FC 02		getk	lda kbcodes	; odczytaj kbcodes
  2420 2F2A C9 FF			cmp #255		; czy jest znak?
  2421 2F2C F0 F9			beq getk	; nie: czekaj
  2422 2F2E A0 FF			ldy #255		; daj znaï¿½, ï¿½e klawisz
  2423 2F30 8C FC 02			sty kbcodes	; zostaï¿½ odebrany
  2424 2F33 A8				tay		; kod klawisza jako indeks
  2425 2F34 B1 79			lda (keydef),y	; do tablicy w ROM-ie
  2426
  2427 2F36 60				rts
  2428 				.endp
  2429
  2430
  2431 2F37			.proc	@moveSTRING (.word ya) .reg
  2432
  2433 2F37 85 8A			sta @move.dst
  2434 2F39 84 8B			sty @move.dst+1
  2435
  2436 2F3B B5 98 85 86			mva :STACKORIGIN,x @move.src
  2437 2F3F B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2438
  2439 2F43 A0 00			ldy #$00
  2440 2F45 B1 86			lda (@move.src),y
  2441 2F47 18 69 01			add #1
  2442 2F4A 85 82			sta @move.cnt
  2443 2F4C 90 01			scc
  2444 2F4E C8				iny
  2445 2F4F 84 83			sty @move.cnt+1
  2446
  2447 2F51 4C 7F 2F			jmp @move
  2448 				.endp
  2449
  2450
  2451 2F54			.proc	@moveSTRING_1 (.word ya) .reg
  2452
  2453 					sta @move.dst
  2454 					sty @move.dst+1
  2455
  2456 					mva :STACKORIGIN,x @move.src
  2457 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2458
  2459 					ldy #$00
  2460 					lda (@move.src),y
  2461 				;	add #1
  2462 					sta @move.cnt
  2463 					sty @move.cnt+1
  2464
  2465 					inw @move.src
  2466
  2467 					jmp @move
  2468 				.endp
  2469
  2470
  2471 				; Ullrich von Bassewitz, 2003-08-20
  2472 				; Performance increase (about 20%) by
  2473 				; Christian Krueger, 2009-09-13
  2474
  2475 2F54			.proc	@moveu		; assert Y = 0
  2476
  2477 = 0086			ptr1	= edx
  2478 = 008A			ptr2	= ecx
  2479 = 0082			ptr3	= eax
  2480
  2481 2F54 8E 7D 2F			stx @sp
  2482
  2483 2F57 A0 00			ldy	#0
  2484
  2485 2F59 A6 83			ldx     ptr3+1		; Get high byte of n
  2486 2F5B F0 13			beq     L2		; Jump if zero
  2487
  2488 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2489 					LDA     (PTR1),Y	
  2490 					STA     (PTR2),Y
  2491 					INY
  2492 					.ENDR
  2492 					.endr
Source: REPT
  2489 2F5D B1 86			LDA     (PTR1),Y	
  2489 2F5F 91 8A			STA     (PTR2),Y
  2489 2F61 C8				INY
  2489 2F62 B1 86			LDA     (PTR1),Y	
  2489 2F64 91 8A			STA     (PTR2),Y
  2489 2F66 C8				INY
Source: cpu6502.asm
  2493
  2494 2F67 D0 F4			bne     L1
  2495 2F69 E6 87			inc     ptr1+1
  2496 2F6B E6 8B			inc     ptr2+1
  2497 2F6D CA				dex			; Next 256 byte block
  2498 2F6E D0 ED			bne	L1		; Repeat if any
  2499
  2500 					; the following section could be 10% faster if we were able to copy
  2501 					; back to front - unfortunately we are forced to copy strict from
  2502 					; low to high since this function is also used for
  2503 					; memmove and blocks could be overlapping!
  2504 					; {
  2505 2F70			L2:				; assert Y = 0
  2506 2F70 A6 82			ldx     ptr3		; Get the low byte of n
  2507 2F72 F0 08			beq     done		; something to copy
  2508
  2509 2F74 B1 86		L3:     lda     (ptr1),Y	; copy a byte
  2510 2F76 91 8A			sta     (ptr2),Y
  2511 2F78 C8				iny
  2512 2F79 CA				dex
  2513 2F7A D0 F8			bne     L3
  2514
  2515 					; }
  2516
  2517 2F7C A2 00		done	ldx #0
  2518 = 2F7D			@sp	equ *-1
  2519 2F7E 60				rts
  2520 				.endp
  2521
  2522
  2523 2F7F			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2524
  2525 = 0086			ptr1	= edx
  2526 = 008A			ptr2	= ecx
  2527 = 0082			ptr3	= eax
  2528
  2529 = 0086			src	= ptr1
  2530 = 008A			dst	= ptr2
  2531 = 0082			cnt	= ptr3
  2532
  2533 2F7F A5 8B C5 87 D0 04 + 	cpw ptr2 ptr1
  2534 2F89 B0 03			scs
  2535 2F8B 4C 54 2F			jmp @moveu
  2536
  2537 2F8E 8E D2 2F			stx @sp
  2538
  2539 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2540
  2541 2F91 A5 87			lda     ptr1+1
  2542 2F93 18 65 83			add     ptr3+1
  2543 2F96 85 87			sta     ptr1+1
  2544
  2545 2F98 A5 8B			lda     ptr2+1
  2546 2F9A 18 65 83			add     ptr3+1
  2547 2F9D 85 8B			sta     ptr2+1
  2548
  2549 				; handle fractions of a page size first
  2550
  2551 2F9F A4 82			ldy     ptr3		; count, low byte
  2552 2FA1 D0 06			bne     @entry		; something to copy?
  2553 2FA3 F0 0B			beq     PageSizeCopy	; here like bra...
  2554
  2555 2FA5			@copyByte:
  2556 2FA5 B1 86			lda     (ptr1),y
  2557 2FA7 91 8A			sta     (ptr2),y
  2558 2FA9			@entry:
  2559 2FA9 88				dey
  2560 2FAA D0 F9			bne     @copyByte
  2561 2FAC B1 86			lda     (ptr1),y	; copy remaining byte
  2562 2FAE 91 8A			sta     (ptr2),y
  2563
  2564 2FB0			PageSizeCopy:			; assert Y = 0
  2565 2FB0 A6 83			ldx     ptr3+1		; number of pages
  2566 2FB2 F0 1D			beq     done		; none? -> done
  2567
  2568 2FB4			@initBase:
  2569 2FB4 C6 87			dec     ptr1+1		; adjust base...
  2570 2FB6 C6 8B			dec     ptr2+1
  2571 2FB8 88				dey			; in entry case: 0 -> FF
  2572 2FB9 B1 86			lda     (ptr1),y	; need to copy this 'intro byte'
  2573 2FBB 91 8A			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2574 2FBD 88				dey			; FF ->FE
  2575 2FBE			@copyBytes:
  2576 					.rept 2		; Unroll this a bit to make it faster...
  2577 					LDA     (PTR1),Y
  2578 					STA     (PTR2),Y
  2579 					DEY
  2580 					.ENDR
  2580 					.endr
Source: REPT
  2577 2FBE B1 86			LDA     (PTR1),Y
  2577 2FC0 91 8A			STA     (PTR2),Y
  2577 2FC2 88				DEY
  2577 2FC3 B1 86			LDA     (PTR1),Y
  2577 2FC5 91 8A			STA     (PTR2),Y
  2577 2FC7 88				DEY
Source: cpu6502.asm
  2581 2FC8			@copyEntry:			; in entry case: 0 -> FF
  2582 2FC8 D0 F4			bne     @copyBytes
  2583 2FCA B1 86			lda     (ptr1),y	; Y = 0, copy last byte
  2584 2FCC 91 8A			sta     (ptr2),y
  2585 2FCE CA				dex			; one page to copy less
  2586 2FCF D0 E3			bne     @initBase	; still a page to copy?
  2587
  2588 2FD1 A2 00		done	ldx #0
  2589 = 2FD2			@sp	equ *-1
  2590 2FD3 60				rts
  2591 				.endp
  2592
  2593
  2594 				; Ullrich von Bassewitz, 29.05.1998
  2595 				; Performance increase (about 20%) by
  2596 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2597
  2598 2FD4			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2599
  2600 = 0086			ptr1 = edx
  2601 = 008A			ptr3 = ecx
  2602 = 0082			ptr2 = eax
  2603
  2604 2FD4 8E 1B 30			stx @sp
  2605
  2606 2FD7 A6 82			ldx ptr2
  2607
  2608 2FD9 A0 00			ldy #0
  2609
  2610 2FDB 46 8B		        lsr	ptr3+1          ; divide number of
  2611 2FDD 66 8A		        ror	ptr3            ; bytes by two to increase
  2612 2FDF 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2613 2FE1			oddCount:
  2614 								; y is still 0 here
  2615 2FE1 8A			        txa			; restore fill value
  2616 2FE2 91 86		        sta	(ptr1),y	; save value and increase
  2617 2FE4 E6 86		        inc	ptr1		; dest. pointer
  2618 2FE6 D0 02		        bne	evenCount
  2619 2FE8 E6 87		        inc	ptr1+1
  2620 2FEA			evenCount:
  2621 2FEA A5 86			lda	ptr1		; build second pointer section
  2622 2FEC 18				clc
  2623 2FED 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2624 2FEF 85 82			sta     ptr2
  2625 2FF1 A5 87			lda     ptr1+1
  2626 2FF3 65 8B			adc     ptr3+1
  2627 2FF5 85 83			sta     ptr2+1
  2628
  2629 2FF7 8A			        txa			; restore fill value
  2630 2FF8 A6 8B		        ldx	ptr3+1		; Get high byte of n
  2631 2FFA F0 13		        beq	L2		; Jump if zero
  2632
  2633 				; Set 256/512 byte blocks
  2634 								; y is still 0 here
  2635 				L1:	.rept 2		; Unroll this a bit to make it faster
  2636 					STA	(PTR1),Y	
  2637 					STA	(PTR2),Y	
  2638 					INY
  2639 					.ENDR
  2639 					.endr
Source: REPT
  2636 2FFC 91 86			STA	(PTR1),Y	
  2636 2FFE 91 82			STA	(PTR2),Y	
  2636 3000 C8				INY
  2636 3001 91 86			STA	(PTR1),Y	
  2636 3003 91 82			STA	(PTR2),Y	
  2636 3005 C8				INY
Source: cpu6502.asm
  2640 3006 D0 F4		        bne	L1
  2641 3008 E6 87		        inc	ptr1+1
  2642 300A E6 83		        inc	ptr2+1
  2643 300C CA			        dex                     ; Next 256 byte block
  2644 300D D0 ED		        bne	L1              ; Repeat if any
  2645
  2646 				; Set the remaining bytes if any
  2647
  2648 300F A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2649 3011 F0 07			beq	leave           ; something to set? No -> leave
  2650
  2651 3013 88			L3:	dey
  2652 3014 91 86			sta	(ptr1),y	; set bytes in low
  2653 3016 91 82			sta	(ptr2),y	; and high section
  2654 3018 D0 F9			bne     L3		; flags still up to date from dey!
  2655
  2656 301A A2 00		leave	ldx #0
  2657 = 301B			@sp	equ *-1
  2658 301C 60				rts			; return
  2659 				.endp
  2660
  2661
  2662 				/*
  2663 				 add strings
  2664 				 result -> @buf
  2665 				*/
  2665
  2666 301D			.proc	@addString(.word ya) .reg
  2667
  2668 301D 85 92			sta ztmp
  2669 301F 84 93			sty ztmp+1
  2670
  2671 3021 8E 47 30			stx @sp
  2672
  2673 3024 AE 00 04			ldx @buf
  2674 3027 E8				inx
  2675 3028 F0 18			beq stop
  2676
  2677 302A A0 00			ldy #0
  2678 302C B1 92			lda (ztmp),y
  2679 302E 8D 49 30			sta ile
  2680 3031 F0 0F			beq stop
  2681
  2682 3033 C8				iny
  2683
  2684 3034 B1 92		load	lda (ztmp),y
  2685 3036 9D 00 04			sta @buf,x
  2686
  2687 3039 C8				iny
  2688 303A E8				inx
  2689 303B F0 05			beq stop
  2690 303D CE 49 30			dec ile
  2691 3040 D0 F2			bne load
  2692
  2693 3042 CA			stop	dex
  2694 3043 8E 00 04			stx @buf
  2695
  2696 3046 A2 00			ldx #0
  2697 = 3047			@sp	equ *-1
  2698 3048 60				rts
  2699
  2700 3049 00			ile	brk
  2701 				.endp
  2702
  2703
  2704 				/* ----------------------------------------------------------------------- */
  2705
  2706
  2707 304A			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2708
  2709 					jsr swap
  2710
  2711 					adw spoint ztmp+2
  2712
  2713 					rts
  2714
  2715 304A			swap	txa:pha
  2716
  2717 					mwa spoint bp2
  2718
  2719 					ldx #0
  2720 					ldy #0
  2721
  2722 304A			loop	cpy ztmp+2
  2723 					bne @+
  2724 					cpx ztmp+3
  2725 					beq stop
  2726
  2727 304A			@	lda (bp2),y
  2728 					pha
  2729
  2730 					lda (ztmp),y
  2731 					sta (bp2),y
  2732
  2733 					pla
  2734 					sta (ztmp),y
  2735
  2736 					iny
  2737 					bne loop
  2738
  2739 					inc ztmp+1
  2740 					inc bp2+1
  2741 					inx
  2742
  2743 					jmp loop
  2744
  2745 304A			stop	pla:tax
  2746
  2747 					rts
  2748
  2749 304A			spoint	dta a(PROGRAMSTACK)
  2750 				.endp
  2751
  2752
  2753 304A			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2754
  2755 					sbw @AllocMem.spoint ztmp+2
  2756
  2757 					jmp @AllocMem.swap
  2758 				.endp
  2759
  2760
  2761 				/* ----------------------------------------------------------------------- */
  2762
  2763
  2764 304A			.proc	@vbxe_detect
  2765
  2766 					ldy #.sizeof(detect)-1
  2767 					mva:rpl copy,y detect,y-
  2768
  2769 					jmp detect
  2770
  2771 304A			copy
  2772 0400				.local	detect,@buf
  2773 				;
  2774 				; 2009 by KMK/DLT
  2775 				;
  2776 					lda #0
  2777 					sta fxptr
  2778
  2779 				        lda #$d6
  2780 				        sta fxptr+1
  2781 				        ldy #FX_MEMB
  2782 				        jsr ?clr
  2783
  2784 				        jsr ?try
  2785 				        bcc ok
  2786
  2787 				        inc fxptr+1
  2788
  2789 					jsr ?try
  2790 					bcc ok
  2791
  2792 					lda #0
  2793 					sta fxptr+1
  2794 					rts
  2795
  2796 0400			?try    ldx $4000
  2797 				        jsr ?chk
  2798 				        bcc ?ret
  2799 				        inx
  2800 				        stx $4000
  2801 				        jsr ?chk
  2802 				        dec $4000
  2803 0400			?ret    rts
  2804
  2805 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2806 					lda	(fxptr),y
  2807 					rts
  2808
  2809 0400			?chk    lda #$80
  2810 				        jsr _vbxe_write
  2811 				        cpx $4000
  2812 				        bne ?fnd
  2813 				        sec
  2814 0400			        .byte $24
  2815 0400			?fnd    clc
  2816 0400			?clr    lda #$00
  2817 0400			_vbxe_write
  2818 				        sta (fxptr),y
  2819 				        rts
  2820
  2821 				/*
  2822 					lda	#0
  2823 					ldx	#0xd6
  2824 					sta	0xd640			; make sure it isn't coincidence
  2825 					lda	0xd640
  2826 					cmp	#0x10			; do we have major version here?
  2827 					beq	VBXE_Detected		; if so, then VBXE is detected
  2828 					lda	#0
  2829 					inx
  2830 					sta	0xd740			; no such luck, try other location
  2831 					lda	0xd740
  2832 					cmp	#0x10
  2833 					beq	VBXE_Detected
  2834 					ldx 	#0  			; not here, so not present or FX core version too low
  2835 					stx	fxptr+1
  2836 					stx	fxptr
  2837
  2838 					sec
  2839 					rts
  2840
  2841 				VBXE_Detected
  2842 					stx	fxptr+1
  2843 					lda	#0
  2844 					sta	fxptr
  2845
  2846 					ldy	#VBXE_MINOR		; get core minor version
  2847 					lda	(fxptr),y
  2848
  2849 					clc
  2850 					rts	 			; x - page of vbxe
  2851 				*/
  2851
  2852
  2853 					.endl
  2854
  2855 				.endp
  2856
  2857
  2858 304A			.proc	@setxdl(.byte a) .reg
  2859
  2860 					asl @
  2861 					sta idx
  2862
  2863 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2864
  2865 					ldy #0
  2866 304A			idx	equ *-1
  2867
  2868 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2869 					and msk,y
  2870 					ora val,y
  2871 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2872
  2873 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2874 					and msk+1,y
  2875 					ora val+1,y
  2876 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2877
  2878 					fxs FX_MEMS #0
  2879 					rts
  2880
  2881 304A			msk	.array [6] .word
  2882 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2883 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2884 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2885 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2886 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2887 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2888 					.enda
  2889
  2890 304A			val	.array [6] .word
  2891 					[e@xdl.mapon]  = XDLC_MAPON
  2892 					[e@xdl.mapoff] = XDLC_MAPOFF
  2893 					[e@xdl.ovron]  = XDLC_GMON
  2894 					[e@xdl.ovroff] = XDLC_OVOFF
  2895 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2896 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2897 					.enda
  2898
  2899 				.endp
  2900
  2901
  2902 304A			.proc	@vbxe_init
  2903
  2904 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2905 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2906
  2907 					ldx #.sizeof(s@xdl)-1
  2908 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2909
  2910 					jsr cmapini		; init color map
  2911
  2912 					fxsa FX_P1		; A = 0
  2913 					fxsa FX_P2
  2914 					fxsa FX_P3
  2915
  2916 					fxsa FX_IRQ_CONTROL
  2917 					fxsa FX_BLITTER_START
  2918
  2919 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2920 					fxsa FX_XDL_ADR1
  2921 					fxsa FX_XDL_ADR2
  2922
  2923 					sta colpf0s
  2924
  2925 					fxs FX_P0 #$ff
  2926
  2927 					mwa #@vbxe_cmap @putchar.vbxe+1
  2928 					mva #{jsr*} @putchar.vbxe
  2929
  2930 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2931
  2932 					rts
  2933
  2934 304A			cmapini	lda colpf1s
  2935 					and #$0f
  2936 					sta colpf1s
  2937
  2938 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2939 					sta ztmp
  2940
  2941 					mva #4 ztmp+1
  2942
  2943 304A			loop	fxs FX_MEMS ztmp
  2944
  2945 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2946 					sta bp+1
  2947
  2948 					ldx #16
  2949 					ldy #0
  2950
  2951 304A			lop	mva #$00	(bp),y+
  2952 					mva colpf1s	(bp),y+
  2953 					mva colpf2s	(bp),y+
  2954 					mva #%00010000	(bp),y+		; overlay palette #1
  2955 					bne lop
  2956
  2957 					inc bp+1
  2958 					dex
  2959 					bne lop
  2960
  2961 					inc ztmp
  2962
  2963 					dec ztmp+1
  2964 					bne loop
  2965
  2966 					fxs FX_MEMS #$00		; disable VBXE BANK
  2967 					rts
  2968
  2969 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2970 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2971 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2972 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2973 					0, 0, 7, 7, %00010001, $ff)
  2973 304A			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2974 				.endp
  2975
  2976
  2977 304A			.proc	@vbxe_cmap
  2978
  2979 					pha
  2980
  2981 					cmp #eol
  2982 					beq stop
  2983
  2984 					cmp #$7d		; clrscr
  2985 					bne skp
  2986
  2987 					jsr @vbxe_init.cmapini
  2988 					jmp stop
  2989
  2990 304A			skp	lda rowcrs
  2991 					pha
  2992 304A				:4 lsr @
  2993 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2994 					fxsa FX_MEMS
  2995
  2996 					pla
  2997 					and #$0f
  2998 					add >MAIN.SYSTEM.VBXE_WINDOW
  2999 					sta bp+1
  3000
  3001 					lda colcrs
  3002 					asl @
  3003 					asl @
  3004 					tay
  3005 					mva colpf0s (bp),y
  3006 					iny
  3007 					mva colpf1s (bp),y
  3008 					iny
  3009 					mva colpf2s (bp),y
  3010
  3011 					fxs FX_MEMS #$00
  3012
  3013 304A			stop	pla
  3014
  3015 					rts
  3016 				.endp
  3017
  3018
  3019 				/* ----------------------------------------------------------------------- */
  3020
  3021
  3022 				/*
  3023 				.proc	@cmdline (.byte a) .reg
  3024
  3025 					stx @sp
  3026
  3027 					sta idpar
  3028
  3029 					lda #0
  3030 					sta parno
  3031
  3032 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3033 					lsr
  3034 					bcc _no_command_line
  3035
  3036 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3037 					cmp #$c0
  3038 					bcs _no_command_line
  3039
  3040 					ldy #$03
  3041 					lda (dosvec),y
  3042 					cmp #{jmp}
  3043 					bne _no_command_line
  3044
  3045 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3046 					lda (dosvec),y
  3047 					sta lbuf
  3048 					iny
  3049 					lda (dosvec),y
  3050 					sta hbuf
  3051
  3052 					adw dosvec #3 zcr
  3053
  3054 				loop	lda #0
  3055 					sta @buf
  3056
  3057 					jsr $ffff
  3058 				zcr	equ *-2
  3059 					beq stop
  3060
  3061 					lda idpar
  3062 					bne skp
  3063
  3064 					ldy #33			; ParamStr(0)
  3065 				_par0	lda (dosvec),y
  3066 					sta @buf-33+1,y
  3067 					iny
  3068 					cpy #36
  3069 					bne _par0
  3070
  3071 					lda #3
  3072 					sta @buf
  3073 					bne stop
  3074
  3075 				skp	ldy #36
  3076 				_cp	lda (dosvec),y
  3077 					sta @buf-36+1,y
  3078 					iny
  3079 					cmp #$9b
  3080 					bne _cp
  3081
  3082 					tya
  3083 					sub #37
  3084 					sta @buf
  3085
  3086 					inc parno
  3087 					lda #0
  3088 				parno	equ *-1
  3089 					cmp #0
  3090 				idpar	equ *-1
  3091
  3092 					bne loop
  3093
  3094 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3095 					lda #0
  3096 				lbuf	equ *-1
  3097 					sta (dosvec),y
  3098 					iny
  3099 					lda #0
  3100 				hbuf	equ *-1
  3101 					sta (dosvec),y
  3102
  3103 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3104
  3105 					lda parno
  3106
  3107 					ldx #0
  3108 				@sp	equ *-1
  3109 					rts
  3110 				.endp
  3111 				*/
  3111
  3112
  3113
  3114 304A			.proc	@CmdLine (.byte a) .reg
  3115
  3116 					stx @sp
  3117
  3118 					sta idpar
  3119
  3120 					lda #0
  3121 					sta parno
  3122 					sta loop+1
  3123
  3124 					lda	#{jsr*}
  3125 					sta	res
  3126
  3127 				; Get filename from SpartaDOS...
  3128 304A			get_param
  3129 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3130 					lsr
  3131 					bcc no_sparta
  3132
  3133 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3134 					cmp #$c0
  3135 					bcs no_sparta
  3136
  3137 					ldy #$03
  3138 					lda (dosvec),y
  3139 					cmp #{jmp}
  3140 					bne no_sparta
  3141
  3142 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3143 					lda (dosvec),y
  3144 					sta lbuf
  3145 					iny
  3146 					lda (dosvec),y
  3147 					sta hbuf
  3148
  3149 					adw dosvec #33 tmp
  3150
  3151 					ldy #0
  3152 304A			fnm	lda (tmp),y
  3153 					iny
  3154 					cmp #$9b
  3155 					bne fnm
  3156
  3157 					tya			; remove .COM
  3158 					sub #5
  3159 					tay
  3160 					lda #0
  3161 					sta (tmp),y
  3162 					tay
  3163
  3164 					lda	#3
  3165 					sta	loop+1
  3166 					add	dosvec
  3167 					sta	get_adr
  3168 					lda	#0
  3169 					adc	dosvec+1
  3170 					sta	get_adr+1
  3171
  3172 					jmp	_ok
  3173
  3174 304A			no_sparta
  3175 					mwa #next get_adr
  3176
  3177 					lda	#{bit*}
  3178 					sta	res
  3179
  3180 				; ... or channel #0
  3181 					lda	MAIN.IOCB@COPY+2	; command
  3182 					cmp	#5			; read line
  3183 					bne	_no_command_line
  3184 					lda	MAIN.IOCB@COPY+3	; status
  3185 					bmi	_no_command_line
  3186 				; don't assume the line is EOL-terminated
  3187 				; DOS II+/D overwrites the EOL with ".COM"
  3188 				; that's why we rely on the length
  3189 					lda	MAIN.IOCB@COPY+9	; length hi
  3190 					bne	_no_command_line
  3191 					ldx	MAIN.IOCB@COPY+8	; length lo
  3192 					beq	_no_command_line
  3193 					inx:inx
  3194 					stx	arg_len
  3195 				; give access to three bytes before the input buffer
  3196 				; in DOS II+/D the device prompt ("D1:") is there
  3197 					lda	MAIN.IOCB@COPY+4
  3198 					sub	#3
  3199 					sta	tmp
  3200 					lda	MAIN.IOCB@COPY+5
  3201 					sbc	#0
  3202 					sta	tmp+1
  3203
  3204 					lda	#0
  3205 					ldy	#0
  3206 304A			arg_len	equ *-1
  3207 					sta	(tmp),y
  3208
  3209
  3210 304A			loop	ldy	#0
  3211
  3212 304A			_ok	ldx	#0
  3213
  3214 304A			lprea	lda	(tmp),y
  3215 					sta	@buf+1,x
  3216
  3217 					beq	stop
  3218
  3219 					cmp	#$9b
  3220 					beq	stop
  3221 					cmp	#' '
  3222 					beq	stop
  3223
  3224 					iny
  3225 					inx
  3226 					cpx #32
  3227 					bne lprea
  3228
  3229 304A			stop	lda #0
  3230 304A			parno	equ *-1
  3231 					cmp #0
  3232 304A			idpar	equ *-1
  3233 					beq found
  3234
  3235 					jsr $ffff		; sty loop+1
  3236 304A			get_adr	equ *-2
  3237 					beq found
  3238
  3239 					inc parno
  3240 					bne loop
  3241
  3242 304A			found	lda #0	;+$9b
  3243 					sta @buf+1,x
  3244 					stx @buf
  3245
  3246 304A			res	jsr sdxres
  3247
  3248 304A			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3249
  3250 					lda parno
  3251
  3252 					ldx #0
  3253 304A			@sp	equ *-1
  3254 					rts
  3255
  3256
  3257 304A			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3258 					lda #0
  3259 304A			lbuf	equ *-1
  3260 					sta (dosvec),y
  3261 					iny
  3262 					lda #0
  3263 304A			hbuf	equ *-1
  3264 					sta (dosvec),y
  3265 					rts
  3266
  3267
  3268 304A			_next	iny
  3269 304A			next	lda (tmp),y
  3270 					beq _eol
  3271 					cmp #' '
  3272 					beq _next
  3273
  3274 					cmp #$9b
  3275 					beq _eol
  3276
  3277 					sty loop+1
  3278 					rts
  3279
  3280 304A			_eol	lda #0
  3281 					rts
  3282
  3283 				.endp
  3284
  3285
  3286 				/* ----------------------------------------------------------------------- */
  3287
  3288 				/*
  3289 				.proc	@rstsnd
  3290 					lda #0
  3291 					sta $d208
  3292 					sta $d218
  3293
  3294 					ldy #3
  3295 					sty $d20f
  3296 					sty $d21f
  3297 					rts
  3298 				.endp
  3299 				*/
  3299
  3300
  3301 				;	ert (*>$3fff) .and (*<$8000)
  3302
  3303
  3304 				/* ----------------------------------------------------------------------- */
  3305
  3306
  3307 304A			.proc	@xmsBank
  3308
  3309 = 0082			ptr3 = eax			; position	(4)
  3310
  3311 					mva ptr3+3 ztmp+1	; position shr 14
  3312 					mva ptr3+2 ztmp
  3313 					lda ptr3+1
  3314
  3315 					.rept 6
  3316 					LSR ZTMP+1
  3317 					ROR ZTMP
  3318 					ROR @
  3319 					.ENDR
  3319 					.endr
Source: REPT
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
Source: cpu6502.asm
  3320
  3321 					tax			; index to bank
  3322
  3323 					lda portb
  3324 					and #1
  3325 					ora main.misc.adr.banks,x
  3326 					sta portb
  3327
  3328 					lda ptr3 		; offset
  3329 					sta ztmp
  3330 					lda ptr3+1
  3331 					and #$3f
  3332 					ora #$40
  3333 					sta ztmp+1
  3334
  3335 					rts
  3336 				.endp
  3337
  3338
  3339 304A			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3340
  3341 = 0086			ptr1 = dx	; buffer	(2)
  3342
  3343 = 008A			ptr2 = cx	; count		(2)
  3344 = 008C			pos = cx+2	; position	(2) pointer
  3345
  3346 = 0082			ptr3 = eax	; position	(4)
  3347
  3348 					txa:pha
  3349
  3350 					ldy #0
  3351 					lda (pos),y
  3352 					sta ptr3
  3353 					iny
  3354 					lda (pos),y
  3355 					sta ptr3+1
  3356 					iny
  3357 					lda (pos),y
  3358 					sta ptr3+2
  3359 					iny
  3360 					lda (pos),y
  3361 					sta ptr3+3
  3362
  3363 					lda ptr2+1
  3364 					beq lp2
  3365
  3366 304A			lp1	jsr @xmsBank
  3367
  3368 					lda ztmp+1
  3369 					cmp #$7f
  3370 					bne skp
  3371 					lda ztmp
  3372 					beq skp
  3373
  3374 					lda #0
  3375 					jsr nextBank
  3376 					jmp skp2
  3377
  3378 304A			skp	ldy #0
  3379 					mva:rne (ztmp),y @buf,y+
  3380
  3381 304A			skp2	lda portb
  3382 					and #1
  3383 					ora #$fe
  3384 					sta portb
  3385
  3386 					ldy #0
  3387 					mva:rne @buf,y (dx),y+
  3388
  3389 					inc dx+1	// inc(dx, $100)
  3390
  3391 					inl ptr3+1	// inc(position, $100)
  3392
  3393 					dec ptr2+1
  3394 					bne lp1
  3395
  3396 304A			lp2	jsr @xmsBank
  3397
  3398 					lda ztmp+1		; zakonczenie kopiowania
  3399 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3400 					bne skp_
  3401
  3402 					lda ztmp
  3403 					add ptr2
  3404 					bcc skp_
  3405
  3406 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3407 					jsr nextBank
  3408 					jmp skp3
  3409
  3410 304A			skp_	ldy #0
  3411 304A			mv	lda (ztmp),y
  3412 					sta @buf,y
  3413 					iny
  3414 					cpy ptr2
  3415 					bne mv
  3416
  3417 304A			skp3	lda portb
  3418 					and #1
  3419 					ora #$fe
  3420 					sta portb
  3421
  3422 					ldy #0
  3423 304A			lp3	lda @buf,y
  3424 					sta (dx),y
  3425 					iny
  3426 					cpy ptr2
  3427 					bne lp3
  3428
  3429 					jmp @xmsUpdatePosition
  3430
  3431 304A			.local	nextBank
  3432
  3433 					sta max
  3434
  3435 					mwa ztmp src
  3436
  3437 					ldy #0
  3438 304A			mv0	lda $ffff,y
  3439 304A			src	equ *-2
  3440 					sta @buf,y
  3441 					iny
  3442 					inc ztmp
  3443 					bne mv0
  3444
  3445 					lda portb
  3446 					and #1
  3447 					ora main.misc.adr.banks+1,x
  3448 					sta portb
  3449
  3450 					ldx #0
  3451 304A			mv1	cpy #0
  3452 304A			max	equ *-1
  3453 					beq stp
  3454 					lda $4000,x
  3455 					sta @buf,y
  3456 					inx
  3457 					iny
  3458 					bne mv1
  3459 304A			stp	rts
  3460 				.endl
  3461
  3462 				.endp
  3463
  3464
  3465 304A			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3466
  3467 = 0086			ptr1 = dx	; buffer	(2)
  3468
  3469 = 008A			ptr2 = cx	; count		(2)
  3470 = 008C			pos = cx+2	; position	(2) pointer
  3471
  3472 = 0082			ptr3 = eax	; position	(4)
  3473
  3474 					txa:pha
  3475
  3476 					ldy #0			; przepisz POSITION spod wskaznika
  3477 					lda (pos),y
  3478 					sta ptr3
  3479 					iny
  3480 					lda (pos),y
  3481 					sta ptr3+1
  3482 					iny
  3483 					lda (pos),y
  3484 					sta ptr3+2
  3485 					iny
  3486 					lda (pos),y
  3487 					sta ptr3+3
  3488
  3489 304A			lp1	lda portb		; wylacz dodatkowe banki
  3490 					and #1
  3491 					ora #$fe
  3492 					sta portb
  3493
  3494 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3495 					mva:rne (dx),y @buf,y+
  3496
  3497 					jsr @xmsBank		; wlacz dodatkowy bank
  3498
  3499 					lda ptr2+1
  3500 					beq lp2
  3501
  3502 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3503 					cmp #$7f
  3504 					bne skp
  3505 					lda ztmp
  3506 					beq skp
  3507
  3508 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3509 					jsr nextBank
  3510 					jmp skp2
  3511
  3512 304A			skp	mva:rne @buf,y (ztmp),y+
  3513
  3514 304A			skp2	inc dx+1		// inc(dx, $100)
  3515
  3516 					inl ptr3+1		// inc(position, $100)
  3517
  3518 					dec ptr2+1
  3519 					bne lp1
  3520
  3521 304A			lp2	lda ztmp+1		; zakonczenie kopiowania
  3522 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3523 					bne skp_
  3524
  3525 					lda ztmp
  3526 					add ptr2
  3527 					bcc skp_
  3528
  3529 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3530 					jsr nextBank
  3531 					jmp quit
  3532
  3533 304A			skp_	ldy #0
  3534 304A			lp3	lda @buf,y
  3535 					sta (ztmp),y
  3536
  3537 					iny
  3538 					cpy ptr2
  3539 					bne lp3
  3540
  3541 304A			quit	lda portb
  3542 					and #1
  3543 					ora #$fe
  3544 					sta portb
  3545
  3546 					jmp @xmsUpdatePosition
  3547
  3548 304A			.local	nextBank
  3549
  3550 					sta max
  3551
  3552 					mwa ztmp dst
  3553
  3554 					ldy #0
  3555 304A			mv0	lda @buf,y
  3556 					sta $ffff,y
  3557 304A			dst	equ *-2
  3558 					iny
  3559 					inc ztmp
  3560 					bne mv0
  3561
  3562 					lda portb
  3563 					and #1
  3564 					ora main.misc.adr.banks+1,x
  3565 					sta portb
  3566
  3567 					ldx #0
  3568 304A			mv1	cpy #0
  3569 304A			max	equ *-1
  3570 					beq stp
  3571 					lda @buf,y
  3572 					sta $4000,x
  3573 					inx
  3574 					iny
  3575 					bne mv1
  3576 304A			stp	rts
  3577 				.endl
  3578
  3579 				.endp
  3580
  3581
  3582 304A			.proc	@xmsAddPosition
  3583
  3584 304A				.use @xmsReadBuf
  3585
  3586 					add ptr3
  3587 					sta ptr3
  3588 					lda #$00
  3589 					adc ptr3+1
  3590 					sta ptr3+1
  3591 					lda #$00
  3592 					adc ptr3+2
  3593 					sta ptr3+2
  3594 					lda #$00
  3595 					adc ptr3+3
  3596 					sta ptr3+3
  3597
  3598 					rts
  3599 				.endp
  3600
  3601
  3602 304A			.proc	@xmsUpdatePosition
  3603
  3604 304A				.use @xmsReadBuf
  3605
  3606 					tya
  3607 					jsr @xmsAddPosition
  3608
  3609 					ldy #0
  3610 					lda ptr3
  3611 					sta (pos),y
  3612 					iny
  3613 					lda ptr3+1
  3614 					sta (pos),y
  3615 					iny
  3616 					lda ptr3+2
  3617 					sta (pos),y
  3618 					iny
  3619 					lda ptr3+3
  3620 					sta (pos),y
  3621
  3622 					pla:tax
  3623 					rts
  3624 				.endp
  3625
  3626
  3627 				/* ----------------------------------------------------------------------- */
  3628
  3629
  3630 304A			.proc	@ClrScr
  3631
  3632 					ldx #$00
  3633 					lda #$0c
  3634 					jsr xcio
  3635
  3636 					mwa #ename ioadr,x
  3637
  3638 					mva #$0c ioaux1,x
  3639 					mva #$00 ioaux2,x
  3640
  3641 					lda #$03
  3642
  3643 304A			xcio	sta iocom,x
  3644 					jmp ciov
  3645
  3646 304A			ename	.byte 'E:',$9b
  3647
  3648 				.endp
  3649
  3650
  3651 				/* ----------------------------------------------------------------------- */
  3652
  3653
  3654 					opt l+
  3100
  3101 				; -----------------------------------------------------------
  3102
  3103 				.macro UNITINITIALIZATION
  3104 				
  3105 					.ifdef MAIN.SYSTEM.@UnitInit
  3106 					jsr MAIN.SYSTEM.@UnitInit
  3107 					eif
  3108 				
  3109 					.ifdef MAIN.ATARI.@UnitInit
  3110 					jsr MAIN.ATARI.@UnitInit
  3111 					eif
  3112 				
  3113 					.ifdef MAIN..@UnitInit
  3114 					jsr MAIN..@UnitInit
  3115 					eif
  3116 				
  3117 					.ifdef MAIN.CRT.@UnitInit
  3118 					jsr MAIN.CRT.@UnitInit
  3119 					eif
  3120 				
  3121 					.ifdef MAIN.RMT.@UnitInit
  3122 					jsr MAIN.RMT.@UnitInit
  3123 					eif
  3124 				
  3125 					.ifdef MAIN..@UnitInit
  3126 					jsr MAIN..@UnitInit
  3127 					eif
  3128 				
  3129 					.ifdef MAIN.B_UTILS.@UnitInit
  3130 					jsr MAIN.B_UTILS.@UnitInit
  3131 					eif
  3132 				
  3133 					.ifdef MAIN..@UnitInit
  3134 					jsr MAIN..@UnitInit
  3135 					eif
  3136 				
  3137 					.ifdef MAIN.B_DL.@UnitInit
  3138 					jsr MAIN.B_DL.@UnitInit
  3139 					eif
  3140 				
  3141 					.ifdef MAIN..@UnitInit
  3142 					jsr MAIN..@UnitInit
  3143 					eif
  3144 				
  3145 					.ifdef MAIN.B_SYSTEM.@UnitInit
  3146 					jsr MAIN.B_SYSTEM.@UnitInit
  3147 					eif
  3148 				.endm
  3149
  3150 					ift .SIZEOF(MAIN.SYSTEM) > 0
  3151 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  3151 				SYSTEM: $213A..$22A7
  3152 					eif
  3153
  3154 					ift .SIZEOF(MAIN.ATARI) > 0
  3155 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  3156 					eif
  3157
  3158 					ift .SIZEOF(MAIN.CRT) > 0
  3159 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
  3159 				CRT: $22A8..$23AA
  3160 					eif
  3161
  3162 					ift .SIZEOF(MAIN.RMT) > 0
  3163 					.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
  3164 					eif
  3165
  3166 					ift .SIZEOF(MAIN.B_UTILS) > 0
  3167 					.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
  3167 				B_UTILS: $23AB..$2475
  3168 					eif
  3169
  3170 					ift .SIZEOF(MAIN.B_DL) > 0
  3171 					.print 'B_DL: ',MAIN.B_DL,'..',MAIN.B_DL+.SIZEOF(MAIN.B_DL)-1
  3172 					eif
  3173
  3174 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  3175 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  3176 					eif
  3177
  3178 					.print 'CODE: ',CODEORIGIN,'..',*-1
  3178 				CODE: $2000..$3049
  3179
  3180 304A			DATAORIGIN
  3181
  3182 304A 28 00 18 00 0C 00 + .by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3183 3062 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3184 307A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3185 3092 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3186 30AA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3187 30C2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3188 30DA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3189 30F2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3190 310A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3191 3122 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3192 313A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3193 3152 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3194 316A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3195 3182 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3196 319A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3197 31B2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3198 31CA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3199 31E2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3200 31FA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3201 3212 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3202 322A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3203 3242 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3204 325A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3205 3272 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3206 328A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3207 32A2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3208 32BA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3209 32D2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3210 32EA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3211 3302 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3212 331A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3213 3332 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3214 334A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3215 3362 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3216 337A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3217 3392 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3218 33AA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3219 33C2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3220 33DA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3221 33F2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3222 340A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3223 3422 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3224 343A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3225 3452 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3226 346A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3227 3482 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3228 349A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3229 34B2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3230 34CA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3231 34E2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3232 34FA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3233 3512 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3234 352A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3235 3542 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3236 355A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3237 3572 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3238 358A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3239 35A2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3240 35BA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3241 35D2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3242 35EA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3243 3602 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3244 361A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3245 3632 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3246 364A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3247 3662 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3248 367A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3249 3692 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3250 36AA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3251 36C2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3252 36DA 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3253 36F2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3254 370A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3255 3722 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3256 373A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3257 3752 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3258 376A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3259 3782 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3260 379A 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3261 37B2 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $95 $94 $93 $92  $91 $90
  3262
  3263 = 077A			VARINITSIZE	= *-DATAORIGIN
  3264 = 077D			VARDATASIZE	= 1917
  3265
  3266 = 37C7			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  3267
  3268 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  3268 				DATA: $304A..$37C7
  3269
  3270 02E0-02E1> 0D 21			run START
  3271
  3272 				; -----------------------------------------------------------
  3273
  3274 				.macro	STATICDATA
  3275 				.by  $03 $4C $3A $20 $00 $19 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23
  3276 				.by  $23 $23 $23 $23 $23 $23 $23 $00  $04 $20 $55 $45 $43 $00 $0C $20  $5B $42 $75 $79 $5D $20 $53 $65
  3277 				.by  $6C $6C $20 $00 $28 $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3278 				.by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $00 $28 $2F
  3279 				.by  $44 $65 $6C $69 $76 $65 $72 $79  $5F $4C $6F $63 $61 $74 $69 $6F  $6E $73 $20 $7C $20 $2E $2E $2F
  3280 				.by  $41 $76 $61 $69 $6C $61 $62 $6C  $65 $5F $49 $74 $65 $6D $73 $00  $28 $5B $20 $43 $75 $74 $74 $6C
  3281 				.by  $65 $73 $20 $42 $6C $61 $63 $6B  $20 $5D $20 $20 $20 $7C $20 $63  $6F $6D $6D $6F $64 $69 $74 $79
  3282 				.by  $20 $20 $20 $20 $70 $72 $69 $63  $65 $00 $28 $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3283 				.by  $2D $2D $2D $2D $2D $2D $2D $2B  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3284 				.by  $2D $2D $2D $00 $0C $54 $6F $74  $61 $6C $20 $43 $61 $72 $67 $6F  $20 $00 $04 $34 $36 $20 $7C $00
  3285 				.by  $0C $45 $6D $70 $74 $79 $20 $43  $61 $72 $67 $6F $20 $00 $0D $5B  $43 $61 $6E $63 $65 $6C $5D $20
  3286 				.by  $5B $4F $4B $5D $00
  3287 				.endm
  3288
  3289 					end
