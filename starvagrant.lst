mads 2.0.8 build 1 (2 Nov 17)
  1103 					opt l+
    81
    82 205F				RCASM 'dlist_menu.asm' DISPLAY_LIST_ADDRESS_MENU 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 205F				org RESORIGIN
     4 = 0075			len = .sizeof(_DISPLAY_LIST_ADDRESS_MENU)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_MENU+len >= $bc20
    11 205F 20 41 20			jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5F +  MWA #MAIN.DISPLAY_LIST_ADDRESS_MENU ECX
    13 2072 A9 75 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: dlist_menu.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
    13 = 5B00			FREE_BOTTOM = $5b00;
    15 = 5B00			STRINGS_ADDRESS = FREE_BOTTOM;
    16 = 5C00			LOCATIONS_ADDRESS = STRINGS_ADDRESS + $100;
    17 = 5E00			ITEMS_ADDRESS = LOCATIONS_ADDRESS + $200;
    18 = 5F00			DISPLAY_LIST_ADDRESS_MENU = ITEMS_ADDRESS + $100;
    19 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE = DISPLAY_LIST_ADDRESS_MENU + $100;
    21 = 6100			VIDEO_RAM_ADDRESS = DISPLAY_LIST_ADDRESS_CONSOLE + $100;
    24 = 7000			GFX_ADDRESS = $7000;
    29 = 8A00			RMT_PLAYER_ADDRESS = $8a00;
    30 = 9200			RMT_MODULE_ADDRESS = RMT_PLAYER_ADDRESS + $800;
    32 = 000F			NUMBEROFLOCATIONS = 15; // number of locations defined in locations.asm. Needs to match.
    33 = 0016			NUMBEROFITEMS = 22; // number of items defined in items.asm. Needs to match.
    34 = 0028			TXTCOL = 40; // numer of columns in txt mode
    39 = 0031			KEY_OPTION1 = '1';
    40 = 0032			KEY_OPTION2 = '2';
    41 = 0033			KEY_OPTION3 = '3';
    42 = 0034			KEY_OPTION4 = '4';
    43 = 0062			KEY_BACK = 'b';
    44 = 0071			KEY_QUIT = 'q';
    45 = 006E			KEY_NEW = 'n';
    49 = 0000			MENU_TITLE = 0;
    50 = 0001			MENU_MAIN = 1;
    51 = 0002			MENU_NAV = 2;
    52 = 0003			MENU_TRADE = 3;
    53 = 0004			MENU_MAINT = 4;
    53 5F00			dl_start
    54 5F00 70			    dta DL_BLANK8                            ; // 8 blank line
    55 5F01 4E 00 70		    dta DL_MODE_160x192G4 + DL_LMS, a(GFX_ADDRESS)      ; // gfx line + graphics memory start
    56 5F04 0E 0E 0E 0E 0E 0E +     :99 dta DL_MODE_160x192G4                           ; // x graphics line
    57 5F67 70			    dta DL_BLANK8                                       ; // 8 blank lines
    58 5F68 42 00 61		    dta DL_MODE_40x24T2 + DL_LMS, a(VIDEO_RAM_ADDRESS)  ; // mode 0 line + text memory start
    59 5F6B 02 02 02 02 02	    :5 dta DL_MODE_40x24T2                              ; // 5x mode 0 line
    60 5F70 F0			    dta DL_DLI + DL_BLANK8                                       ; // 8 blank line
    61 5F71 12			    dta DL_MODE_40x24T2 + DL_HSCROLL                    ; //  mode 0 line
    62 5F72 41 00 5F		    dta DL_JVB, a(dl_start)                             ; // jump to beginning
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    83 20F5				RCASM 'dlist_console.asm' DISPLAY_LIST_ADDRESS_CONSOLE 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 20F5				org RESORIGIN
     4 = 001F			len = .sizeof(_DISPLAY_LIST_ADDRESS_CONSOLE)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_CONSOLE+len >= $bc20
    11 205F-209E> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 60 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_CONSOLE ECX
    13 2072 A9 1F 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: dlist_console.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
    13 = 5B00			FREE_BOTTOM = $5b00;
    15 = 5B00			STRINGS_ADDRESS = FREE_BOTTOM;
    16 = 5C00			LOCATIONS_ADDRESS = STRINGS_ADDRESS + $100;
    17 = 5E00			ITEMS_ADDRESS = LOCATIONS_ADDRESS + $200;
    18 = 5F00			DISPLAY_LIST_ADDRESS_MENU = ITEMS_ADDRESS + $100;
    19 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE = DISPLAY_LIST_ADDRESS_MENU + $100;
    21 = 6100			VIDEO_RAM_ADDRESS = DISPLAY_LIST_ADDRESS_CONSOLE + $100;
    24 = 7000			GFX_ADDRESS = $7000;
    29 = 8A00			RMT_PLAYER_ADDRESS = $8a00;
    30 = 9200			RMT_MODULE_ADDRESS = RMT_PLAYER_ADDRESS + $800;
    32 = 000F			NUMBEROFLOCATIONS = 15; // number of locations defined in locations.asm. Needs to match.
    33 = 0016			NUMBEROFITEMS = 22; // number of items defined in items.asm. Needs to match.
    34 = 0028			TXTCOL = 40; // numer of columns in txt mode
    39 = 0031			KEY_OPTION1 = '1';
    40 = 0032			KEY_OPTION2 = '2';
    41 = 0033			KEY_OPTION3 = '3';
    42 = 0034			KEY_OPTION4 = '4';
    43 = 0062			KEY_BACK = 'b';
    44 = 0071			KEY_QUIT = 'q';
    45 = 006E			KEY_NEW = 'n';
    49 = 0000			MENU_TITLE = 0;
    50 = 0001			MENU_MAIN = 1;
    51 = 0002			MENU_NAV = 2;
    52 = 0003			MENU_TRADE = 3;
    53 = 0004			MENU_MAINT = 4;
    37 6000			dl_start
    38 6000 70			    dta DL_BLANK8                                       ; // 8 blank line
    39 6001 C2 00 61		    dta DL_MODE_40x24T2 + DL_LMS + DL_DLI, a(VIDEO_RAM_ADDRESS)  ; // mode 0 line + text memory start
    40 6004 02 02 02 02 02 02 +     :22 dta DL_MODE_40x24T2                              ; // 5x mode 0 line
    41 601A 12			    dta DL_MODE_40x24T2 + DL_HSCROLL                    ; //  mode 0 line
    42 601B 70			    dta DL_BLANK8                                       ; // 8 blank lines
    43 601C 41 00 60		    dta DL_JVB, a(dl_start)                             ; // jump to beginning
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    84 209F				RCASM 'strings.asm' STRINGS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 209F				org RESORIGIN
     4 = 007A			len = .sizeof(_STRINGS_ADDRESS)
     6 				mcpy	ift main.STRINGS_ADDRESS+len >= $bc20
    11 205F-20F9> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5B +  MWA #MAIN.STRINGS_ADDRESS ECX
    13 2072 A9 7A 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: strings.asm
     1 5B00			strings_list
     2 5B00 0E 5B		    dta a(txt_0)
     3 5B02 28 5B		    dta a(txt_1)
     4 5B04 33 5B		    dta a(txt_2)
     5 5B06 3A 5B		    dta a(txt_3)
     6 5B08 49 5B		    dta a(txt_4)
     7 5B0A 5B 5B		    dta a(txt_5)
     8 5B0C 71 5B		    dta a(txt_6)
    10 5B0E			strings
    12 5B0E			txt_0
    13 5B0E 20 76 2E 30 2E 31 +     dta c' v.0.1 (c) 2019 MADRAFi. ',0
    14 5B28			txt_1
    15 5B28 5B 4E 5D 65 77 20 +     dta c'[N]ew Game',0
    16 5B33			txt_2
    17 5B33 5B 51 5D 75 69 74 +     dta c'[Q]uit',0
    18 5B3A			txt_3
    19 5B3A 5B 31 5D 20 4E 61 +     dta c'[1] Navigation',0
    20 5B49			txt_4
    21 5B49 5B 32 5D 20 54 72 +     dta c'[2] Trade Console',0
    22 5B5B			txt_5
    23 5B5B 5B 33 5D 20 52 65 +     dta c'[3] Repair/Refuel Pad',0
    24 5B71			txt_6
    25 5B71 5B 42 5D 20 42 61 +     dta c'[B] Back',0
    28 				 .print "STRINGS SIZE: ", *-strings_list
    28 				STRINGS SIZE: $007A
    29 				 .print "STRINGS : ", strings_list, "..", *
    29 				STRINGS : $5B00..$5B7A
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    85 20FA				RCASM 'locations.asm' LOCATIONS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 20FA				org RESORIGIN
     4 = 010D			len = .sizeof(_LOCATIONS_ADDRESS)
     6 				mcpy	ift main.LOCATIONS_ADDRESS+len >= $bc20
    11 205F-218C> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5C +  MWA #MAIN.LOCATIONS_ADDRESS ECX
    13 2072 A9 0D 85 82 A9 01 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: locations.asm
     1 5C00			locations_list
     2 5C00 1E 5C		    dta a(loc_0)
     3 5C02 2A 5C		    dta a(loc_1)
     4 5C04 33 5C		    dta a(loc_2)
     5 5C06 3F 5C		    dta a(loc_3)
     6 5C08 48 5C		    dta a(loc_4)
     7 5C0A 4F 5C		    dta a(loc_5)
     8 5C0C 67 5C		    dta a(loc_6)
     9 5C0E 7D 5C		    dta a(loc_7)
    10 5C10 96 5C		    dta a(loc_8)
    11 5C12 9F 5C		    dta a(loc_9)
    12 5C14 A9 5C		    dta a(loc_10)
    13 5C16 C1 5C		    dta a(loc_11)
    14 5C18 D5 5C		    dta a(loc_12)
    15 5C1A EC 5C		    dta a(loc_13)
    16 5C1C 02 5D		    dta a(loc_14)
    18 5C1E			locations
    19 5C1E			loc_0
    20 5C1E 50 6F 72 74 20 4F +     dta c'Port Olisar',0
    21 5C2A			loc_1
    22 5C2A 47 72 69 6D 20 48 +     dta c'Grim Hex',0
    23 5C33			loc_2
    24 5C33 43 6F 76 61 6C 65 +     dta c'Covalex Hub',0
    25 5C3F			loc_3
    26 5C3F 4C 6F 72 76 69 6C +     dta c'Lorville',0
    27 5C48			loc_4
    28 5C48 4C 65 76 73 6B 69 +     dta c'Levski',0
    29 5C4F			loc_5
    30 5C4F 41 72 63 43 6F 72 +     dta c'ArcCorp Mining Area 157',0
    31 5C67			loc_6
    32 5C67 42 65 6E 73 6F 6E +     dta c'Benson Mining Outpost',0
    33 5C7D			loc_7
    34 5C7D 44 65 61 6B 69 6E +     dta c'Deakins Research Outpost',0
    35 5C96			loc_8
    36 5C96 4A 75 6D 70 74 6F +     dta c'Jumptown',0
    37 5C9F			loc_9
    38 5C9F 4B 75 64 72 65 20 +     dta c'Kudre Ore',0
    39 5CA9			loc_10
    40 5CA9 41 72 63 43 6F 72 +     dta c'ArcCorp Mining Area 141',0
    41 5CC1			loc_11
    42 5CC1 48 61 72 76 65 73 +     dta c'Harvest Hydroponics',0
    43 5CD5			loc_12
    44 5CD5 53 68 75 62 69 6E +     dta c'Shubin Mining Facility',0
    45 5CEC			loc_13
    46 5CEC 54 65 72 72 61 20 +     dta c'Terra Mills HydroFarm',0
    47 5D02			loc_14
    48 5D02 52 26 52 20 43 52 +     dta c'R&R CRU-L1',0
    50 				 .print "LOCATIONS SIZE: ", *-locations_list
    50 				LOCATIONS SIZE: $010D
    51 				 .print "LOCATIONS : ", locations_list, "..", *
    51 				LOCATIONS : $5C00..$5D0D
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    86 218D				RCASM 'items.asm' ITEMS_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 218D				org RESORIGIN
     4 = 00F4			len = .sizeof(_ITEMS_ADDRESS)
     6 				mcpy	ift main.ITEMS_ADDRESS+len >= $bc20
    11 205F-2173> 20 41 20		jsr sys_off
    13 2062 A9 80 85 86 A9 20 +  MWA #DATA EDX
    13 206A A9 00 85 8A A9 5E +  MWA #MAIN.ITEMS_ADDRESS ECX
    13 2072 A9 F4 85 82 A9 00 +  MWA #LEN EAX
    13 207A 20 00 20		 JSR RESOURCE.MEMCPY
    15 207D 4C 50 20			jmp sys_on
    16 2080			data
Source: items.asm
     1 5E00			items_list
     2 5E00 2E 5E		    dta a(item_0)
     3 5E02 37 5E		    dta a(item_1)
     4 5E04 46 5E		    dta a(item_2)
     5 5E06 4F 5E		    dta a(item_3)
     6 5E08 58 5E		    dta a(item_4)
     7 5E0A 5E 5E		    dta a(item_5)
     8 5E0C 67 5E		    dta a(item_6)
     9 5E0E 70 5E		    dta a(item_7)
    10 5E10 78 5E		    dta a(item_8)
    11 5E12 80 5E		    dta a(item_9)
    12 5E14 89 5E		    dta a(item_10)
    13 5E16 8E 5E		    dta a(item_11)
    14 5E18 97 5E		    dta a(item_12)
    15 5E1A 9E 5E		    dta a(item_13)
    16 5E1C A7 5E		    dta a(item_14)
    17 5E1E B4 5E		    dta a(item_15)
    18 5E20 C3 5E		    dta a(item_16)
    19 5E22 CA 5E		    dta a(item_17)
    20 5E24 D0 5E		    dta a(item_18)
    21 5E26 D6 5E		    dta a(item_19)
    22 5E28 DF 5E		    dta a(item_20)
    23 5E2A E8 5E		    dta a(item_21)
    24 5E2C EE 5E		    dta a(item_22)
    26 5E2E			items
    27 5E2E			item_0
    28 5E2E 41 67 72 69 63 69 +     dta c'Agricium',0
    29 5E37			item_1
    30 5E37 41 67 72 69 63 75 +     dta c'Agricult. Sup.',0
    31 5E46			item_2
    32 5E46 41 6C 75 6D 69 6E +     dta c'Aluminum',0
    33 5E4F			item_3
    34 5E4F 41 73 74 61 74 69 +     dta c'Astatine',0
    35 5E58			item_4
    36 5E58 42 65 72 79 6C 00	    dta c'Beryl',0
    37 5E5E			item_5
    38 5E5E 43 68 6C 6F 72 69 +     dta c'Chlorine',0
    39 5E67			item_6
    40 5E67 43 6F 72 75 6E 64 +     dta c'Corundum',0
    41 5E70			item_7
    42 5E70 44 69 61 6D 6F 6E +     dta c'Diamond',0
    43 5E78			item_8
    44 5E78 53 70 69 72 69 74 +     dta c'Spirits',0
    45 5E80			item_9
    46 5E80 46 6C 75 6F 72 69 +     dta c'Fluorine',0
    47 5E89			item_10
    48 5E89 47 6F 6C 64 00	    dta c'Gold',0
    49 5E8E			item_11
    50 5E8E 48 79 64 72 6F 67 +     dta c'Hydrogen',0
    51 5E97			item_12
    52 5E97 49 6F 64 69 6E 65 +     dta c'Iodine',0
    53 5E9E			item_13
    54 5E9E 4C 61 72 61 6E 69 +     dta c'Laranite',0
    55 5EA7			item_14
    56 5EA7 4D 65 64 69 63 61 +     dta c'Medical Sup.',0
    57 5EB4			item_15
    58 5EB4 50 72 6F 63 65 73 +     dta c'Processed Food',0
    59 5EC3			item_16
    60 5EC3 51 75 61 72 74 7A +     dta c'Quartz',0
    61 5ECA			item_17
    62 5ECA 53 63 72 61 70 00	    dta c'Scrap',0
    63 5ED0			item_18
    64 5ED0 53 74 69 6D 73 00	    dta c'Stims',0
    65 5ED6			item_19
    66 5ED6 54 69 74 61 6E 69 +     dta c'Titanium',0
    67 5EDF			item_20
    68 5EDF 54 75 6E 67 73 74 +     dta c'Tungsten',0
    69 5EE8			item_21
    70 5EE8 57 61 73 74 65 00	    dta c'Waste',0
    71 5EEE			item_22
    72 5EEE 57 69 64 6F 77 00	    dta c'Widow',0
    74 				 .print "ITEMS SIZE: ", *-items_list
    74 				ITEMS SIZE: $00F4
    75 				 .print "ITEMS : ", items_list, "..", *
    75 				ITEMS : $5E00..$5EF4
    24 02E2-02E3> 5F 20			ini mcpy
Source: starvagrant.a65
    87 2174				RMTPLAY 'assets/titlemusic.feat' RMT_PLAYER_ADDRESS 1 0 0 0 0 0 0 0
Macro: RESOURCE.RMTPLAY [Source: res6502.asm]
     2 = 0001			STEREOMODE	= 1
     3 = 8A00			PLAYER		= main.RMT_PLAYER_ADDRESS
Source: rmt_player.asm
    25 = 0008			TRACKS		equ 8
    37 2174				org $e0
    38 00E0			p_tis
    39 00E0			p_instrstable	org *+2
    40 00E2			p_trackslbstable	org *+2
    41 00E4			p_trackshbstable	org *+2
    42 00E6			p_song			org *+2
    43 00E8			ns				org *+2
    44 00EA			nr				org *+2
    45 00EC			nt				org *+2
    46 00EE			reg1			org *+1
    47 00EF			reg2			org *+1
    48 00F0			reg3			org *+1
    49 00F1			tmp				org *+1
    54 00F2				org PLAYER-$400+$40
    58 8640			track_variables
    59 8640			trackn_db	org *+TRACKS
    60 8648			trackn_hb	org *+TRACKS
    61 8650			trackn_idx	org *+TRACKS
    62 8658			trackn_pause	org *+TRACKS
    63 8660			trackn_note	org *+TRACKS
    64 8668			trackn_volume	org *+TRACKS
    65 8670			trackn_distor 	org *+TRACKS
    66 8678			trackn_shiftfrq	org *+TRACKS
    74 8680			trackn_instrx2	org *+TRACKS
    75 8688			trackn_instrdb	org *+TRACKS
    76 8690			trackn_instrhb	org *+TRACKS
    77 8698			trackn_instridx	org *+TRACKS
    78 86A0			trackn_instrlen	org *+TRACKS
    79 86A8			trackn_instrlop	org *+TRACKS
    80 86B0			trackn_instrreachend	org *+TRACKS
    81 86B8			trackn_volumeslidedepth org *+TRACKS
    82 86C0			trackn_volumeslidevalue org *+TRACKS
    84 86C8			trackn_volumemin		org *+TRACKS
    86 = 0000			FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
    96 86D0			trackn_tabletypespeed org *+TRACKS
   100 86D8			trackn_tablenote	org *+TRACKS
   101 86E0			trackn_tablea		org *+TRACKS
   102 86E8			trackn_tableend		org *+TRACKS
   104 86F0			trackn_tablelop		org *+TRACKS
   106 86F8			trackn_tablespeeda	org *+TRACKS
   116 8700			trackn_audf	org *+TRACKS
   117 8708			trackn_audc	org *+TRACKS
   121 8710			v_aspeed		org *+1
   122 8711			track_endvariables
   123 8711					org PLAYER-$100-$140-$40+2
   124 = 000C			INSTRPAR	equ 12
   125 8782			tabbeganddistor
   126 8782-8791> 80 00		 dta frqtabpure-frqtab,$00
   127 8784 80 20		 dta frqtabpure-frqtab,$20
   128 8786 80 40		 dta frqtabpure-frqtab,$40
   129 8788 00 C0		 dta frqtabbass1-frqtab,$c0
   130 878A 80 80		 dta frqtabpure-frqtab,$80
   131 878C 80 A0		 dta frqtabpure-frqtab,$a0
   132 878E 00 C0		 dta frqtabbass1-frqtab,$c0
   133 8790 40 C0		 dta frqtabbass2-frqtab,$c0
   146 8792					org PLAYER-$100-$140
   154 87C0					org PLAYER-$100-$100
   155 8800			frqtab
   157 8800			frqtabbass1
   158 8800-88BF> BF B6 AA A1 + 	dta $BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
   159 8810 98 8F 89 80 7A 71 + 	dta $98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
   160 8820 3C 38 35 32 2F 2D + 	dta $3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
   161 8830 17 16 14 13 12 11 + 	dta $17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
   162 8840			frqtabbass2
   163 8840 FF F1 E4 D8 CA C0 + 	dta $FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
   164 8850 66 61 5A 55 52 4B + 	dta $66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
   165 8860 28 25 24 21 1F 1E + 	dta $28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
   166 8870 0F 0E 0D 0C 0B 0A + 	dta $0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
   167 8880			frqtabpure
   168 8880 F3 E6 D9 CC C1 B5 + 	dta $F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
   169 8890 60 5B 55 51 4C 48 + 	dta $60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
   170 88A0 25 23 21 1F 1D 1C + 	dta $25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
   171 88B0 0E 0D 0C 0B 0A 09 + 	dta $0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
   179 88C0					org PLAYER-$0100
   180 8900			volumetab
   181 8900-8D80> 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   182 8910 00 00 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
   183 8920 00 00 00 00 01 01 + 	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
   184 8930 00 00 00 01 01 01 + 	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
   185 8940 00 00 01 01 01 01 + 	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
   186 8950 00 00 01 01 01 02 + 	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
   187 8960 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
   188 8970 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
   189 8980 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
   190 8990 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
   191 89A0 00 01 01 02 03 03 + 	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
   192 89B0 00 01 01 02 03 04 + 	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
   193 89C0 00 01 02 02 03 04 + 	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
   194 89D0 00 01 02 03 03 04 + 	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
   195 89E0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
   196 89F0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
   197 8A00				org PLAYER
   201 8A00			RASTERMUSICTRACKER
   202 8A00 4C D5 8B			jmp rmt_play
   204 8A03 4C 0F 8A			jmp rmt_init
   205 8A06 4C F9 8B			jmp rmt_p3
   206 8A09 4C 56 8A			jmp rmt_silence
   207 8A0C 4C 16 8D			jmp SetPokey
   211 8A0F			rmt_init
   212 8A0F 86 E8			stx ns
   213 8A11 84 E9			sty ns+1
   215 8A13 48				pha
   225 8A14 A0 D1			ldy #track_endvariables-track_variables
   226 8A16 A9 00			lda #0
   227 8A18 99 3F 86		ri0	sta track_variables-1,y
   228 8A1B 88				dey
   229 8A1C D0 FA			bne ri0
   231 8A1E A0 04			ldy #4
   232 8A20 B1 E8			lda (ns),y
   233 8A22 8D ED 8B			sta v_maxtracklen
   234 8A25 C8				iny
   236 8A26 B1 E8			lda (ns),y
   237 8A28 8D C5 8A			sta v_speed
   245 8A2B A9 03			lda #FEAT_INSTRSPEED
   246 8A2D 8D 14 8D			sta v_ainstrspeed
   248 8A30 A0 08			ldy #8
   249 8A32 B1 E8		ri1	lda (ns),y
   250 8A34 99 D8 00			sta p_tis-8,y
   251 8A37 C8				iny
   252 8A38 C0 10			cpy #8+8
   253 8A3A D0 F6			bne ri1
   255 8A3C 68				pla
   256 8A3D 48				pha
   258 8A3E 0A				asl @
   259 8A3F 0A				asl @
   260 8A40 0A				asl @
   261 8A41 18				clc
   262 8A42 65 E6			adc p_song
   263 8A44 85 E6			sta p_song
   264 8A46 68				pla
   265 8A47 08				php
   266 8A48 29 E0			and #$e0
   267 8A4A 0A				asl @
   268 8A4B 2A				rol @
   269 8A4C 2A				rol @
   270 8A4D 2A				rol @
   284 8A4E 28				plp
   285 8A4F 65 E7			adc p_song+1
   286 8A51 85 E7			sta p_song+1
   288 8A53 20 74 8A			jsr GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   289 8A56			rmt_silence
   291 8A56 A9 00			lda #0
   292 8A58 8D 08 D2			sta $d208
   293 8A5B 8D 18 D2			sta $d218
   294 8A5E A0 03			ldy #3
   295 8A60 8C 0F D2			sty $d20f
   296 8A63 8C 1F D2			sty $d21f
   297 8A66 A0 08			ldy #8
   298 8A68 99 00 D2		si1	sta $d200,y
   299 8A6B 99 10 D2			sta $d210,y
   300 8A6E 88				dey
   301 8A6F 10 F7			bpl si1
   315 8A71 A9 03			lda #FEAT_INSTRSPEED
   317 8A73 60				rts
   318 8A74			GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   319 8A74			GetSongLine
   320 8A74 A2 00			ldx #0
   321 8A76 8E EB 8B			stx v_abeat
   322 8A79			nn0
   323 8A79 8A			nn1	txa
   324 8A7A A8				tay
   325 8A7B B1 E6			lda (p_song),y
   326 8A7D C9 FE			cmp #$fe
   327 8A7F B0 2D			bcs nn2
   328 8A81 A8				tay
   329 8A82 B1 E2			lda (p_trackslbstable),y
   330 8A84 9D 40 86			sta trackn_db,x
   331 8A87 B1 E4			lda (p_trackshbstable),y
   332 8A89 9D 48 86		nn1a sta trackn_hb,x
   333 8A8C A9 00			lda #0
   334 8A8E 9D 50 86			sta trackn_idx,x
   335 8A91 A9 01			lda #1
   336 8A93 9D 58 86		nn1a2 sta trackn_pause,x
   337 8A96 A9 80			lda #$80
   338 8A98 9D 80 86			sta trackn_instrx2,x
   339 8A9B E8				inx
   340 8A9C E0 08		xtracks01	cpx #TRACKS
   341 8A9E D0 D9			bne nn1
   342 8AA0 A5 E6			lda p_song
   343 8AA2 18				clc
   344 8AA3 69 08		xtracks02	adc #TRACKS
   345 8AA5 85 E6			sta p_song
   346 8AA7 90 1B			bcc GetTrackLine
   347 8AA9 E6 E7			inc p_song+1
   348 8AAB			nn1b
   349 8AAB 4C C4 8A			jmp GetTrackLine
   350 8AAE			nn2
   351 8AAE F0 04			beq nn3
   352 8AB0			nn2a
   353 8AB0 A9 00			lda #0
   354 8AB2 F0 DF			beq nn1a2
   355 8AB4			nn3
   356 8AB4 A0 02			ldy #2
   357 8AB6 B1 E6			lda (p_song),y
   358 8AB8 AA				tax
   359 8AB9 C8				iny
   360 8ABA B1 E6			lda (p_song),y
   361 8ABC 85 E7			sta p_song+1
   362 8ABE 86 E6			stx p_song
   363 8AC0 A2 00			ldx #0
   364 8AC2 F0 B5			beq nn0
   365 8AC4			GetTrackLine
   366 8AC4			oo0
   367 8AC4			oo0a
   369 8AC4 A9 FF			lda #$ff
   370 = 8AC5			v_speed equ *-1
   371 8AC6 8D 1F 8B			sta v_bspeed
   373 8AC9 A2 FF			ldx #-1
   374 8ACB			oo1
   375 8ACB E8				inx
   376 8ACC DE 58 86			dec trackn_pause,x
   377 8ACF D0 49			bne oo1x
   378 8AD1			oo1b
   379 8AD1 BD 40 86			lda trackn_db,x
   380 8AD4 85 E8			sta ns
   381 8AD6 BD 48 86			lda trackn_hb,x
   382 8AD9 85 E9			sta ns+1
   383 8ADB			oo1i
   384 8ADB BC 50 86			ldy trackn_idx,x
   385 8ADE FE 50 86			inc trackn_idx,x
   386 8AE1 B1 E8			lda (ns),y
   387 8AE3 85 EE			sta reg1
   388 8AE5 29 3F			and #$3f
   389 8AE7 C9 3D			cmp #61
   390 8AE9 F0 0E			beq oo1a
   391 8AEB B0 3C			bcs oo2
   392 8AED 9D 60 86			sta trackn_note,x
   396 8AF0 C8				iny
   397 8AF1 B1 E8			lda (ns),y
   398 8AF3 4A				lsr @
   399 8AF4 29 7E			and #$3f*2
   400 8AF6 9D 80 86			sta trackn_instrx2,x
   401 8AF9			oo1a
   402 8AF9 A9 01			lda #1
   403 8AFB 9D 58 86			sta trackn_pause,x
   404 8AFE BC 50 86			ldy trackn_idx,x
   405 8B01 FE 50 86			inc trackn_idx,x
   406 8B04 B1 E8			lda (ns),y
   407 8B06 4A				lsr @
   408 8B07 66 EE			ror reg1
   409 8B09 4A				lsr @
   410 8B0A 66 EE			ror reg1
   411 8B0C A5 EE			lda reg1
   413 8B0E 38				sec
   414 8B0F E9 00			sbc #$00
   415 = 8B10			RMTGLOBALVOLUMEFADE equ *-1
   416 8B11 B0 02			bcs voig
   417 8B13 A9 00			lda #0
   418 8B15			voig
   420 8B15 29 F0			and #$f0
   421 8B17 9D 68 86			sta trackn_volume,x
   422 8B1A			oo1x
   423 8B1A E0 07		xtracks03sub1	cpx #TRACKS-1
   424 8B1C D0 AD			bne oo1
   426 8B1E A9 FF			lda #$ff
   427 = 8B1F			v_bspeed equ *-1
   428 8B20 8D C5 8A			sta v_speed
   432 8B23 8D 10 87			sta v_aspeed
   433 8B26 4C 6E 8B			jmp InitOfNewSetInstrumentsOnly
   434 8B29			oo2
   435 8B29 C9 3F			cmp #63
   436 8B2B F0 1B			beq oo63
   437 8B2D A5 EE			lda reg1
   438 8B2F 29 C0			and #$c0
   439 8B31 F0 09			beq oo62_b
   440 8B33 0A				asl @
   441 8B34 2A				rol @
   442 8B35 2A				rol @
   443 8B36 9D 58 86			sta trackn_pause,x
   444 8B39 4C 1A 8B			jmp oo1x
   445 8B3C			oo62_b
   446 8B3C C8				iny
   447 8B3D B1 E8			lda (ns),y
   448 8B3F 9D 58 86			sta trackn_pause,x
   449 8B42 FE 50 86			inc trackn_idx,x
   450 8B45 4C 1A 8B			jmp oo1x
   451 8B48			oo63
   452 8B48 A5 EE			lda reg1
   454 8B4A 30 0C			bmi oo63_1X
   455 8B4C C8				iny
   456 8B4D B1 E8			lda (ns),y
   457 8B4F 8D 1F 8B			sta v_bspeed
   458 8B52 FE 50 86			inc trackn_idx,x
   459 8B55 4C DB 8A			jmp oo1i
   460 8B58			oo63_1X
   462 8B58 C9 FF			cmp #255
   463 8B5A F0 09			beq oo63_11
   464 8B5C C8				iny
   465 8B5D B1 E8			lda (ns),y
   466 8B5F 9D 50 86			sta trackn_idx,x
   467 8B62 4C DB 8A			jmp oo1i
   468 8B65			oo63_11
   469 8B65 4C 74 8A			jmp GetSongLine
   470 8B68 4C F9 8B		p2xrmtp3	jmp rmt_p3
   471 8B6B CA			p2x0 dex
   472 8B6C 30 FA			 bmi p2xrmtp3
   473 8B6E			InitOfNewSetInstrumentsOnly
   474 8B6E BC 80 86		p2x1 ldy trackn_instrx2,x
   475 8B71 30 F8			bmi p2x0
   488 8B73			SetUpInstrumentY2
   489 8B73 B1 E0			lda (p_instrstable),y
   490 8B75 9D 88 86			sta trackn_instrdb,x
   491 8B78 85 EC			sta nt
   492 8B7A C8				iny
   493 8B7B B1 E0			lda (p_instrstable),y
   494 8B7D 9D 90 86			sta trackn_instrhb,x
   495 8B80 85 ED			sta nt+1
   504 8B82 A0 01			ldy #1
   506 8B84 B1 EC			lda (nt),y
   507 8B86 9D F0 86			sta trackn_tablelop,x
   508 8B89 C8				iny
   512 8B8A B1 EC			lda (nt),y
   513 8B8C 9D A0 86			sta trackn_instrlen,x
   514 8B8F C8				iny
   515 8B90 B1 EC			lda (nt),y
   516 8B92 9D A8 86			sta trackn_instrlop,x
   517 8B95 C8				iny
   518 8B96 B1 EC			lda (nt),y
   519 8B98 9D D0 86			sta trackn_tabletypespeed,x
   521 8B9B 29 3F			and #$3f
   523 8B9D 9D F8 86			sta trackn_tablespeeda,x
   535 8BA0 A0 06			ldy #6
   537 8BA2 B1 EC			lda (nt),y
   538 8BA4 9D B8 86			sta trackn_volumeslidedepth,x
   540 8BA7 C8				iny
   541 8BA8 B1 EC			lda (nt),y
   542 8BAA 9D C8 86			sta trackn_volumemin,x
   567 8BAD A9 80			lda #128
   568 8BAF 9D C0 86			sta trackn_volumeslidevalue,x
   569 8BB2 9D 80 86			sta trackn_instrx2,x
   570 8BB5 0A				asl @
   571 8BB6 9D B0 86			sta trackn_instrreachend,x
   572 8BB9 9D 78 86			sta trackn_shiftfrq,x
   573 8BBC A8				tay
   574 8BBD B1 EC			lda (nt),y
   575 8BBF 9D E8 86			sta trackn_tableend,x
   576 8BC2 69 00			adc #0
   577 8BC4 9D 98 86			sta trackn_instridx,x
   578 8BC7 A9 0C			lda #INSTRPAR
   579 8BC9 9D E0 86			sta trackn_tablea,x
   580 8BCC A8				tay
   581 8BCD B1 EC			lda (nt),y
   582 8BCF 9D D8 86			sta trackn_tablenote,x
   583 8BD2			xata_rtshere
   587 8BD2 4C 6B 8B			jmp p2x0
   589 8BD5			rmt_play
   590 8BD5			rmt_p0
   591 8BD5 20 16 8D			jsr SetPokey
   592 8BD8			rmt_p1
   594 8BD8 CE 14 8D			dec v_ainstrspeed
   595 8BDB D0 1C			bne rmt_p3
   602 8BDD A9 03			lda #FEAT_INSTRSPEED
   603 8BDF 8D 14 8D			sta v_ainstrspeed
   605 8BE2			rmt_p2
   606 8BE2 CE 10 87			dec v_aspeed
   607 8BE5 D0 12			bne rmt_p3
   608 8BE7 EE EB 8B			inc v_abeat
   609 8BEA A9 FF			lda #$ff
   610 = 8BEB			v_abeat equ *-1
   611 8BEC C9 FF			cmp #$ff
   612 = 8BED			v_maxtracklen equ *-1
   613 8BEE F0 03			beq p2o3
   614 8BF0 4C C4 8A			jmp GetTrackLine
   615 8BF3			p2o3
   616 8BF3 4C 74 8A			jmp GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   617 8BF6 4C FD 8C		go_ppnext	jmp ppnext
   618 8BF9			rmt_p3
   619 8BF9 A9 88			lda #>frqtab
   620 8BFB 85 EB			sta nr+1
   621 8BFD A2 07		xtracks05sub1	ldx #TRACKS-1
   622 8BFF			pp1
   623 8BFF BD 90 86			lda trackn_instrhb,x
   624 8C02 F0 F2			beq go_ppnext
   625 8C04 85 E9			sta ns+1
   626 8C06 BD 88 86			lda trackn_instrdb,x
   627 8C09 85 E8			sta ns
   628 8C0B BC 98 86			ldy trackn_instridx,x
   629 8C0E B1 E8			lda (ns),y
   630 8C10 85 EE			sta reg1
   631 8C12 C8				iny
   632 8C13 B1 E8			lda (ns),y
   633 8C15 85 EF			sta reg2
   634 8C17 C8				iny
   635 8C18 B1 E8			lda (ns),y
   636 8C1A 85 F0			sta reg3
   637 8C1C C8				iny
   638 8C1D 98				tya
   639 8C1E DD A0 86			cmp trackn_instrlen,x
   640 8C21 90 0A			bcc pp2
   641 8C23 F0 08			beq pp2
   642 8C25 A9 80			lda #$80
   643 8C27 9D B0 86			sta trackn_instrreachend,x
   644 8C2A			pp1b
   645 8C2A BD A8 86			lda trackn_instrlop,x
   646 8C2D 9D 98 86		pp2	sta trackn_instridx,x
   647 8C30 A5 EE			lda reg1
   649 8C32 E0 04			cpx #4
   650 8C34 90 04			bcc pp2s
   651 8C36 4A				lsr @
   652 8C37 4A				lsr @
   653 8C38 4A				lsr @
   654 8C39 4A				lsr @
   655 8C3A			pp2s
   657 8C3A 29 0F			and #$0f
   658 8C3C 1D 68 86			ora trackn_volume,x
   659 8C3F A8				tay
   660 8C40 B9 00 89			lda volumetab,y
   661 8C43 85 F1			sta tmp
   662 8C45 A5 EF			lda reg2
   663 8C47 29 0E			and #$0e
   664 8C49 A8				tay
   665 8C4A B9 82 87			lda tabbeganddistor,y
   666 8C4D 85 EA			sta nr
   667 8C4F A5 F1			lda tmp
   668 8C51 19 83 87			ora tabbeganddistor+1,y
   669 8C54 9D 08 87			sta trackn_audc,x
   670 8C57			InstrumentsEffects
   696 8C57 BC E8 86			ldy trackn_tableend,x
   697 8C5A C0 0D			cpy #INSTRPAR+1
   698 8C5C 90 33			bcc ei3
   699 8C5E BD F8 86			lda trackn_tablespeeda,x
   700 8C61 10 28			bpl ei2f
   701 8C63			ei2c
   702 8C63 98				tya
   703 8C64 DD E0 86			cmp trackn_tablea,x
   704 8C67 D0 08			bne ei2c2
   706 8C69 BD F0 86			lda trackn_tablelop,x
   710 8C6C 9D E0 86			sta trackn_tablea,x
   711 8C6F D0 03			bne ei2a
   712 8C71			ei2c2
   713 8C71 FE E0 86			inc trackn_tablea,x
   714 8C74			ei2a
   715 8C74 BD 88 86			lda trackn_instrdb,x
   716 8C77 85 EC			sta nt
   717 8C79 BD 90 86			lda trackn_instrhb,x
   718 8C7C 85 ED			sta nt+1
   719 8C7E BC E0 86			ldy trackn_tablea,x
   720 8C81 B1 EC			lda (nt),y
   728 8C83 9D D8 86			sta trackn_tablenote,x
   729 8C86 BD D0 86			lda trackn_tabletypespeed,x
   731 8C89 29 3F			and #$3f
   733 8C8B			ei2f
   734 8C8B 38				sec
   735 8C8C E9 01			sbc #1
   736 8C8E 9D F8 86			sta trackn_tablespeeda,x
   737 8C91			ei3
   738 8C91 BD B0 86			lda trackn_instrreachend,x
   739 8C94 10 1F			bpl ei4
   740 8C96 BD 68 86			lda trackn_volume,x
   741 8C99 F0 1A			beq ei4
   743 8C9B DD C8 86			cmp trackn_volumemin,x
   744 8C9E F0 15			beq ei4
   745 8CA0 90 13			bcc ei4
   747 8CA2 A8				tay
   748 8CA3 BD C0 86			lda trackn_volumeslidevalue,x
   749 8CA6 18				clc
   750 8CA7 7D B8 86			adc trackn_volumeslidedepth,x
   751 8CAA 9D C0 86			sta trackn_volumeslidevalue,x
   752 8CAD 90 06			bcc ei4
   753 8CAF 98				tya
   754 8CB0 E9 10			sbc #16
   755 8CB2 9D 68 86			sta trackn_volume,x
   756 8CB5			ei4
   762 8CB5 A5 EF			lda reg2
   766 8CB7 29 70			and #$70
   768 8CB9 F0 05			beq cmd0
   808 8CBB			cmd1
   810 8CBB A5 F0			lda reg3
   811 8CBD 4C FA 8C			jmp cmd0c
   813 8CC0			cmd2
   820 8CC0			cmd3
   828 8CC0			cmd4
   837 8CC0			cmd5
   880 8CC0			cmd6
   892 8CC0			cmd7
   912 8CC0			cmd0
   913 8CC0 BD 60 86			lda trackn_note,x
   914 8CC3 18				clc
   915 8CC4 65 F0			adc reg3
   916 8CC6			cmd0a
   918 8CC6 BC D0 86			ldy trackn_tabletypespeed,x
   919 8CC9 30 19			bmi cmd0b
   921 8CCB 18				clc
   922 8CCC 7D D8 86			adc trackn_tablenote,x
   923 8CCF C9 3D			cmp #61
   924 8CD1 90 07			bcc cmd0a1
   925 8CD3 A9 00			lda #0
   926 8CD5 9D 08 87			sta trackn_audc,x
   927 8CD8 A9 3F			lda #63
   928 8CDA			cmd0a1
   932 8CDA A8				tay
   933 8CDB B1 EA			lda (nr),y
   934 8CDD 18				clc
   935 8CDE 7D 78 86			adc trackn_shiftfrq,x
   941 8CE1 4C FA 8C			jmp cmd0c
   942 8CE4			cmd0b
   943 8CE4 C9 3D			cmp #61
   944 8CE6 90 07			bcc cmd0b1
   945 8CE8 A9 00			lda #0
   946 8CEA 9D 08 87			sta trackn_audc,x
   947 8CED A9 3F			lda #63
   948 8CEF			cmd0b1
   949 8CEF A8				tay
   950 8CF0 BD 78 86			lda trackn_shiftfrq,x
   951 8CF3 18				clc
   952 8CF4 7D D8 86			adc trackn_tablenote,x
   953 8CF7 18				clc
   954 8CF8 71 EA			adc (nr),y
   960 8CFA			cmd0c
   961 8CFA 9D 00 87			sta trackn_audf,x
   962 8CFD			pp9
   998 8CFD			ppnext
   999 8CFD CA				dex
  1000 8CFE 30 03			bmi rmt_p4
  1001 8D00 4C FF 8B			jmp pp1
  1002 8D03			rmt_p4
  1010 8D03 A2 00			ldx #0
  1012 8D05			qq1
  1013 8D05 8E 79 8D			stx v_audctl
  1119 8D08			qq5
  1120 8D08 8E 79 8D			stx v_audctl
  1129 8D0B A2 00			ldx #0
  1131 8D0D 8E 17 8D			stx v_audctl2
  1237 8D10			qs5
  1238 8D10 8E 17 8D			stx v_audctl2
  1240 8D13			rmt_p5
  1242 8D13 A9 FF			lda #$ff
  1243 = 8D14			v_ainstrspeed equ *-1
  1247 8D15 60				rts
  1248 8D16			SetPokey
  1250 8D16 A0 FF			ldy #$ff
  1251 = 8D17			v_audctl2 equ *-1
  1252 8D18 AD 04 87			lda trackn_audf+0+4
  1253 8D1B AE 00 87			ldx trackn_audf+0
  1254 8D1E 8D 10 D2		xstastx01	sta $d210
  1255 8D21 8E 00 D2			stx $d200
  1256 8D24 AD 0C 87			lda trackn_audc+0+4
  1257 8D27 AE 08 87			ldx trackn_audc+0
  1258 8D2A 8D 11 D2		xstastx02	sta $d211
  1259 8D2D 8E 01 D2			stx $d201
  1260 8D30 AD 05 87			lda trackn_audf+1+4
  1261 8D33 AE 01 87			ldx trackn_audf+1
  1262 8D36 8D 12 D2		xstastx03	sta $d212
  1263 8D39 8E 02 D2			stx $d202
  1264 8D3C AD 0D 87			lda trackn_audc+1+4
  1265 8D3F AE 09 87			ldx trackn_audc+1
  1266 8D42 8D 13 D2		xstastx04	sta $d213
  1267 8D45 8E 03 D2			stx $d203
  1268 8D48 AD 06 87			lda trackn_audf+2+4
  1269 8D4B AE 02 87			ldx trackn_audf+2
  1270 8D4E 8D 14 D2		xstastx05	sta $d214
  1271 8D51 8E 04 D2			stx $d204
  1272 8D54 AD 0E 87			lda trackn_audc+2+4
  1273 8D57 AE 0A 87			ldx trackn_audc+2
  1274 8D5A 8D 15 D2		xstastx06	sta $d215
  1275 8D5D 8E 05 D2			stx $d205
  1276 8D60 AD 07 87			lda trackn_audf+3+4
  1277 8D63 AE 03 87			ldx trackn_audf+3
  1278 8D66 8D 16 D2		xstastx07	sta $d216
  1279 8D69 8E 06 D2			stx $d206
  1280 8D6C AD 0F 87			lda trackn_audc+3+4
  1281 8D6F AE 0B 87			ldx trackn_audc+3
  1282 8D72 8D 17 D2		xstastx08	sta $d217
  1283 8D75 8E 07 D2			stx $d207
  1284 8D78 A9 FF			lda #$ff
  1285 = 8D79			v_audctl equ *-1
  1286 8D7A 8C 18 D2		xstysta01	sty $d218
  1287 8D7D 8D 08 D2			sta $d208
  1356 8D80 60				rts
  1357 8D81			RMTPLAYEREND
Source: titlemusic.feat
     2 = 0000			FEAT_SFX		equ 0
     3 = 0001			FEAT_GLOBALVOLUMEFADE	equ 1		;RMTGLOBALVOLUMEFADE variable
     4 = 0000			FEAT_NOSTARTINGSONGLINE	equ 0
     5 = 0003			FEAT_INSTRSPEED		equ 3
     6 = 0000			FEAT_CONSTANTSPEED		equ 0		;(22 times)
     7 = 0001			FEAT_COMMAND1		equ 1		;(60 times)
     8 = 0000			FEAT_COMMAND2		equ 0		;(0 times)
     9 = 0000			FEAT_COMMAND3		equ 0		;(0 times)
    10 = 0000			FEAT_COMMAND4		equ 0		;(0 times)
    11 = 0000			FEAT_COMMAND5		equ 0		;(0 times)
    12 = 0000			FEAT_COMMAND6		equ 0		;(0 times)
    13 = 0000			FEAT_COMMAND7SETNOTE		equ 0		;(0 times)
    14 = 0000			FEAT_COMMAND7VOLUMEONLY		equ 0		;(0 times)
    15 = 0000			FEAT_PORTAMENTO		equ 0		;(0 times)
    16 = 0000			FEAT_FILTER		equ 0		;(0 times)
    17 = 0000			FEAT_FILTERG0L		equ 0		;(0 times)
    18 = 0000			FEAT_FILTERG1L		equ 0		;(0 times)
    19 = 0000			FEAT_FILTERG0R		equ 0		;(0 times)
    20 = 0000			FEAT_FILTERG1R		equ 0		;(0 times)
    21 = 0000			FEAT_BASS16		equ 0		;(0 times)
    22 = 0000			FEAT_BASS16G1L		equ 0		;(0 times)
    23 = 0000			FEAT_BASS16G3L		equ 0		;(0 times)
    24 = 0000			FEAT_BASS16G1R		equ 0		;(0 times)
    25 = 0000			FEAT_BASS16G3R		equ 0		;(0 times)
    26 = 0000			FEAT_VOLUMEONLYG0L		equ 0		;(0 times)
    27 = 0000			FEAT_VOLUMEONLYG2L		equ 0		;(0 times)
    28 = 0000			FEAT_VOLUMEONLYG3L		equ 0		;(0 times)
    29 = 0000			FEAT_VOLUMEONLYG0R		equ 0		;(0 times)
    30 = 0000			FEAT_VOLUMEONLYG2R		equ 0		;(0 times)
    31 = 0000			FEAT_VOLUMEONLYG3R		equ 0		;(0 times)
    32 = 0001			FEAT_TABLETYPE		equ 1		;(4 times)
    33 = 0000			FEAT_TABLEMODE		equ 0		;(0 times)
    34 = 0001			FEAT_TABLEGO		equ 1		;(4 times)
    35 = 0000			FEAT_AUDCTLMANUALSET		equ 0		;(0 times)
    36 = 0001			FEAT_VOLUMEMIN		equ 1		;(2 times)
    37 = 0000			FEAT_EFFECTVIBRATO		equ 0		;(0 times)
    38 = 0000			FEAT_EFFECTFSHIFT		equ 0		;(0 times)
    13 					.echo 'RMTPLAYER: ',track_variables,'..',RMTPLAYEREND
    13 				RMTPLAYER: $8640..$8D81
Source: starvagrant.a65
    88 8D81				RMT 'assets/titlemusic.rmt' RMT_MODULE_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RMT [Source: res6502.asm]
     2 = 1784			len = .filesize('assets/titlemusic.rmt')
    26 8D81				org main.RMT_MODULE_ADDRESS
     2 9200				.get [$100] 'assets/titlemusic.rmt',0,6				// wczytujemy plik do bufora MADS'a
     6 = 9200			new_add = MAIN.RMT_MODULE_ADDRESS						// nowy adres dla modulu RMT
     8 = 4000			old_add	= .wget[$102]					// stary adres modulu RMT
    10 = 177E			length	= .wget[$104] - old_add + 1			// dlugosc pliku RMT bez naglowka DOS'u
    12 = 5200			ofset	= new_add-old_add
    14 9200				.get [old_add-6] 'assets/titlemusic.rmt'
    16  [3FFC] 00			.put[old_add-4] = .lo(new_add)			// poprawiamy nag³ówek DOS'a
    17  [3FFD] 92			.put[old_add-3] = .hi(new_add)			// tak aby zawieral informacje o nowym
    19  [3FFE] 7D			.put[old_add-2] = .lo(new_add + length - 1)	// adresie modulu RMT
    20  [3FFF] A9			.put[old_add-1] = .hi(new_add + length - 1)
    22 = 0034			type	= .get[old_add+3]
    24 = 4010			pinst	= .get[old_add+8] + .get[old_add+9]<<8
    25 = 4030			pltrc	= .get[old_add+10] + .get[old_add+11]<<8
    26 = 4069			phtrc	= .get[old_add+12] + .get[old_add+13]<<8
    27 = 56CA			ptlst	= .get[old_add+14] + .get[old_add+15]<<8
    29  [4008] 10			.put[old_add+8] = .lo(pinst+ofset)
    30  [4009] 92			.put[old_add+9] = .hi(pinst+ofset)
    32  [400A] 30			.put[old_add+10] = .lo(pltrc+ofset)
    33  [400B] 92			.put[old_add+11] = .hi(pltrc+ofset)
    35  [400C] 69			.put[old_add+12] = .lo(phtrc+ofset)
    36  [400D] 92			.put[old_add+13] = .hi(phtrc+ofset)
    38  [400E] CA			.put[old_add+14] = .lo(ptlst+ofset)
    39  [400F] A8			.put[old_add+15] = .hi(ptlst+ofset)
    43 = 40A2				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4010] A2			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4011] 92			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 40CA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4012] CA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4013] 92			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4107				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4014] 07			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4015] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4138				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4016] 38			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4017] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 414E				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4018] 4E			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4019] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 416D				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401A] 6D			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401B] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 418C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401C] 8C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401D] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 41DA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [401E] DA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [401F] 93			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4228				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4020] 28			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4021] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 427B				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4022] 7B			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4023] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 428E				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4024] 8E			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4025] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 42DA				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4026] DA			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4027] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 42FB				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4028] FB			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4029] 94			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 431C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402A] 1C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402B] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 436A				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402C] 6A			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402D] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 43B8				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [402E] B8			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [402F] 95			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    52 = 440C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4030] 0C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4069] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4412				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4031] 12			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406A] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4425				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4032] 25			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406B] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 445B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4033] 5B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406C] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 44B3				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4034] B3			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406D] 96			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 450E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4035] 0E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406E] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4570				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4036] 70			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [406F] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 45D1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4037] D1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4070] 97			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 460A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4038] 0A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4071] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4678				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4039] 78			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4072] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 46E1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403A] E1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4073] 98			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4746				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403B] 46			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4074] 99			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 47C8				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403C] C8			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4075] 99			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4846				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403D] 46			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4076] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 48B2				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403E] B2			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4077] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 48D4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [403F] D4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4078] 9A			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 490C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4040] 0C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4079] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4973				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4041] 73			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407A] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 49D4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4042] D4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407B] 9B			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4A26				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4043] 26			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407C] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4A87				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4044] 87			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407D] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4AEE				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4045] EE			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407E] 9C			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4B40				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4046] 40			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [407F] 9D			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4BAC				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4047] AC			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4080] 9D			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4C10				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4048] 10			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4081] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4C8C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4049] 8C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4082] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4CEE				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404A] EE			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4083] 9E			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D2C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404B] 2C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4084] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D7E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404C] 7E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4085] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D83				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404D] 83			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4086] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D87				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404E] 87			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4087] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4D99				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [404F] 99			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4088] 9F			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4E15				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4050] 15			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4089] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4E7E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4051] 7E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408A] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4EFA				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4052] FA			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408B] A0			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4F6A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4053] 6A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408C] A1			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4FDB				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4054] DB			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408D] A1			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5052				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4055] 52			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408E] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 50C9				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4056] C9			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [408F] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 50CD				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4057] CD			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4090] A2			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 510B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4058] 0B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4091] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5110				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4059] 10			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4092] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 518C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405A] 8C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4093] A3			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5205				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405B] 05			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4094] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 525E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405C] 5E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4095] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 52AF				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405D] AF			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4096] A4			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5306				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405E] 06			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4097] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5357				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [405F] 57			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4098] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 53B1				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4060] B1			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4099] A5			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 540B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4061] 0B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409A] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5484				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4062] 84			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409B] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 54DF				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4063] DF			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409C] A6			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5523				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4064] 23			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409D] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 5585				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4065] 85			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409E] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 55E4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4066] E4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [409F] A7			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 562A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4067] 2A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [40A0] A8			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 566F				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4068] 6F			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [40A1] A8			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    66 = 0004				skip=4
    70 = 5776				?TMP = .GET[PTLST+#*SKIP+2] + .GET[PTLST+#*SKIP+3]<<8
    70  [577C] 76			.PUT[PTLST+#*SKIP+2] = .LO(?TMP+OFSET)
    70  [577D] A9			.PUT[PTLST+#*SKIP+3] = .HI(?TMP+OFSET)
    29 A97E			_end
Source: starvagrant.a65
    89 A97E				RCDATA 'assets/StarVagrand-3.dat' GFX_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0FA4			len = .filesize('assets/StarVagrand-3.dat')
    17 A97E				org main.GFX_ADDRESS
    19 7000-7FA3> 00 00 00 00 + 	ins 'assets/StarVagrand-3.dat'
Source: starvagrant.a65
    90 				.endl
    91
    92 				; -----------------------------------------------------------
    93
    94 7FA4				org CODEORIGIN
    95
    96 2000				STATICDATA
Macro: STATICDATA [Source: starvagrant.a65]
     1 2000-3382> 00 00 03 4C + .by  $00 $00 $03 $4C $3A $20 $00 $19  $23 $23 $23 $23 $23 $23 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23
     2 2018 23 23 23 23 23 23 + .by  $23 $23 $23 $23 $23 $23 $23 $23  $23 $00 $0C $20 $5B $42 $75 $79  $5D $20 $53 $65 $6C $6C $20 $00
     3 2030 04 20 55 45 43 00 + .by  $04 $20 $55 $45 $43 $00 $28 $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
     4 2048 2D 2D 2D 2D 2D 2D + .by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $00
     5 2060 28 2F 44 65 6C 69 + .by  $28 $2F $44 $65 $6C $69 $76 $65  $72 $79 $5F $4C $6F $63 $61 $74  $69 $6F $6E $73 $20 $7C $20 $2E
     6 2078 2E 2F 41 76 61 69 + .by  $2E $2F $41 $76 $61 $69 $6C $61  $62 $6C $65 $5F $49 $74 $65 $6D  $73 $00 $28 $5B $20 $43 $75 $74
     7 2090 74 6C 65 73 20 42 + .by  $74 $6C $65 $73 $20 $42 $6C $61  $63 $6B $20 $5D $20 $20 $20 $7C  $20 $63 $6F $6D $6D $6F $64 $69
     8 20A8 74 79 20 20 20 20 + .by  $74 $79 $20 $20 $20 $20 $70 $72  $69 $63 $65 $00 $28 $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
     9 20C0 2D 2D 2D 2D 2D 2D + .by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2B $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
    10 20D8 2D 2D 2D 2D 2D 00	.by  $2D $2D $2D $2D $2D $00
Source: starvagrant.a65
    97
    98 20DE			START
    99 20DE BA				tsx
   100 20DF 8E 1B 2B			stx MAIN.@halt+1
   101
   102 					.ifdef fmulinit
   103 					fmulinit
   104 					eif
   105
   106 					ift DATAORIGIN+VARINITSIZE > $BFFF
   107 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   108 					els
   109 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   109 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   109 20E2 A9 83 85 86 A9 33 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   109 20EA A9 03 85 8A A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   109 20F2 A9 00 85 82		 MVA #0 @FILL.PTR2
   109 20F6 20 9B 2D		 JSR @FILL
   110 					eif
   111
   112 20F9 A2 0F			ldx #$0f
   113 20FB BD 40 03 9D 1E 2B + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   114
   115 2104 A2 00 86 8E			mvx #$00 bp					; lo BP = 0, X = 0 !!!
   116
   117 2108				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: starvagrant.a65]
Source: starvagrant.a65
   118
   119 2108			.local	MAIN						; PROCEDURE
   120
   121 					ift l_00E5-*>3
   122 2108 4C 41 2A			jmp l_00E5
   123 					eif
   124
   125 				; -----------------------------------------------------------
   126
   127 210B			.local	SYSTEM						; UNIT
   128
   129 210B			.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER
   130
   131 				; -----------------------------------------------------------
   132
   133 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   134 				; as Pointer
   135 210B B5 98 85 86			mva :STACKORIGIN,x A
   136 210F B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   137 2113 CA				dex						; sub bx, 1
   138
   139
   140 				; ---------------------  ASM Block 004  ---------------------
   141
   142 2114 A0 00			ldy #0
   143 2116 B1 86 8D EE 2D		mva (edx),y Result
   144
   145
   146 211B			@exit
   147
   148 				; -----------------------------------------------------------
   149
   150 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   151 				; as Pointer
   152
   153 211B E8				inx						; add bx, 1
   154 211C AD EE 2D 95 98		mva RESULT :STACKORIGIN,x
   155
   156 					.ifdef @new
   157 					@FreeMem #@VarData #@VarDataSize
   158 					eif
   159
   160 				; -----------------------------------------------------------
   161
   162 = 0086			A	= edx
   163 = 2DEE			RESULT	= DATAORIGIN+$000A
   164
   165 = 2DEE			@VarData	= RESULT
   166 = 0001			@VarDataSize	= 1
   167
   168 2121 60				rts						; ret
   169 				.endl
   170
   171 2122			.local	DPEEK						; FUNCTION | ASSEMBLER | REGISTER
   172
   173 				; -----------------------------------------------------------
   174
   175 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   176 				; as Pointer
   177 2122 B5 98 85 86			mva :STACKORIGIN,x A
   178 2126 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   179 212A CA				dex						; sub bx, 1
   180
   181
   182 				; ---------------------  ASM Block 005  ---------------------
   183
   184 212B A0 00			ldy #0
   185 212D B1 86 8D EF 2D		mva (edx),y Result
   186 2132 C8				iny
   187 2133 B1 86 8D F0 2D		mva (edx),y Result+1
   188
   189
   190 2138			@exit
   191
   192 				; -----------------------------------------------------------
   193
   194 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   195 				; as Pointer
   196
   197 2138 E8				inx						; add bx, 1
   198 2139 AD EF 2D 95 98		mva RESULT :STACKORIGIN,x
   199 213E AD F0 2D 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   200
   201 					.ifdef @new
   202 					@FreeMem #@VarData #@VarDataSize
   203 					eif
   204
   205 				; -----------------------------------------------------------
   206
   207 = 0086			A	= edx
   208 = 2DEF			RESULT	= DATAORIGIN+$000B
   209
   210 = 2DEF			@VarData	= RESULT
   211 = 0002			@VarDataSize	= 2
   212
   213 2143 60				rts						; ret
   214 				.endl
   215
   216 2144			.local	STR						; PROCEDURE | ASSEMBLER
   217
   218 				; -----------------------------------------------------------
   219
   220 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   221 				; as Pointer
   222 2144 B5 98 8D F5 2D		mva :STACKORIGIN,x S
   223 2149 B5 A8 8D F6 2D		mva :STACKORIGIN+STACKWIDTH,x S+1
   224 214E CA				dex						; sub bx, 1
   225
   226 				; -----------------------------------------------------------
   227
   228 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
   229 				; as Pointer
   230 214F B5 98 8D F1 2D		mva :STACKORIGIN,x A
   231 2154 B5 A8 8D F2 2D		mva :STACKORIGIN+STACKWIDTH,x A+1
   232 2159 B5 B8 8D F3 2D		mva :STACKORIGIN+STACKWIDTH*2,x A+2
   233 215E B5 C8 8D F4 2D		mva :STACKORIGIN+STACKWIDTH*3,x A+3
   234 2163 CA				dex						; sub bx, 1
   235
   236
   237 				; ---------------------  ASM Block 020  ---------------------
   238
   239 2164 8A 48			txa:pha
   240
   241 2166 E8				inx
   242
   243 					@ValueToStr #@printINT
   243 				 LDY> @PRINTINT\ LDA< @PRINTINT\ JSR @VALUETOSTR
   243 2167 A0 2C		 LDY> @PRINTINT
   243 2169 A9 32		 LDA< @PRINTINT
   243 216B 20 C0 2C		 JSR @VALUETOSTR
   244
   245 					@move #@buf s #16	; !!! koniecznie przez wskaznik
   245 				 MWA #@BUF @MOVE.PTR1\ MWA S @MOVE.PTR2\ MWA #16 @MOVE.PTR3\ JSR @MOVE
   245 216E A9 00 85 86 A9 04 +  MWA #@BUF @MOVE.PTR1
   245 2176 AD F5 2D 85 8A AD +  MWA S @MOVE.PTR2
   245 2180 A9 10 85 82 A9 00 +  MWA #16 @MOVE.PTR3
   245 2188 20 46 2D		 JSR @MOVE
   246
   247 218B 68 AA			pla:tax
   248
   249
   250 				; -----------------------------------------------------------
   251
   252 = 2DF1			A	= DATAORIGIN+$000D
   253 = 2DF5			S	= DATAORIGIN+$0011
   254
   255 = 2DF1			@VarData	= A
   256 = 0006			@VarDataSize	= 6
   257
   258
   259 218D			@exit
   260 					.ifdef @new
   261 					@FreeMem #@VarData #@VarDataSize
   262 					eif
   263 218D 60				rts						; ret
   264 				.endl
   265
   266 218E			.local	FILLCHAR_011F					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   267
   268 				; -----------------------------------------------------------
   269
   270 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   271 				; as Pointer
   272 218E B5 98 85 82			mva :STACKORIGIN,x VALUE
   273 2192 CA				dex						; sub bx, 1
   274
   275 				; -----------------------------------------------------------
   276
   277 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   278 				; as Pointer
   279 2193 B5 98 85 8A			mva :STACKORIGIN,x COUNT
   280 2197 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   281 219B CA				dex						; sub bx, 1
   282
   283 				; -----------------------------------------------------------
   284
   285 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   286 				; as Pointer
   287 219C B5 98 85 86			mva :STACKORIGIN,x A
   288 21A0 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   289 21A4 CA				dex						; sub bx, 1
   290
   291
   292 				; ---------------------  ASM Block 024  ---------------------
   293
   294 21A5 20 9B 2D			jsr @fill
   295
   296
   297 				; -----------------------------------------------------------
   298
   299 = 0086			A	= edx
   300 = 008A			COUNT	= ecx
   301 = 0082			VALUE	= eax
   302
   303 21A8			@exit
   304 					.ifdef @new
   305 					@FreeMem #@VarData #@VarDataSize
   306 					eif
   307 21A8 60				rts						; ret
   308 				.endl
   309
   310 				; -----------------------------------------------------------
   311
   312 = 0648			M_PI_2	= $0648
   313 = 0192			D_PI_2	= $0192
   314 = 0004			D_PI_180	= $0004
   315 = 0000			MGTIA	= $0000
   316 = 0080			MVBXE	= $0080
   317 = 0010			WINDOW	= $0010
   318 = 0020			NARROW	= $0020
   319 = 0000			VBXE_XDLADR	= $0000
   320 = 0100			VBXE_BCBADR	= $0100
   321 = 1000			VBXE_MAPADR	= $1000
   322 = 5000			VBXE_OVRADR	= $5000
   323 = B000			VBXE_WINDOW	= $B000
   324 = 0000			IDLI	= $0000
   325 = 0001			IVBL	= $0001
   326 = 00FE			CH_DELCHR	= $00FE
   327 = 009B			CH_ENTER	= $009B
   328 = 001B			CH_ESC	= $001B
   329 = 001C			CH_CURS_UP	= $001C
   330 = 001D			CH_CURS_DOWN	= $001D
   331 = 001E			CH_CURS_LEFT	= $001E
   332 = 001F			CH_CURS_RIGHT	= $001F
   333 = 007F			CH_TAB	= $007F
   334 = 009B			CH_EOL	= $009B
   335 = 007D			CH_CLR	= $007D
   336 = 00FD			CH_BELL	= $00FD
   337 = 007E			CH_DEL	= $007E
   338 = 009C			CH_DELLINE	= $009C
   339 = 009D			CH_INSLINE	= $009D
   340 = 0000			COLOR_BLACK	= $0000
   341 = 000E			COLOR_WHITE	= $000E
   342 = 0032			COLOR_RED	= $0032
   343 = 0096			COLOR_CYAN	= $0096
   344 = 0068			COLOR_VIOLET	= $0068
   345 = 00C4			COLOR_GREEN	= $00C4
   346 = 0074			COLOR_BLUE	= $0074
   347 = 00EE			COLOR_YELLOW	= $00EE
   348 = 004A			COLOR_ORANGE	= $004A
   349 = 00E4			COLOR_BROWN	= $00E4
   350 = 003C			COLOR_LIGHTRED	= $003C
   351 = 0004			COLOR_GRAY1	= $0004
   352 = 0006			COLOR_GRAY2	= $0006
   353 = 000A			COLOR_GRAY3	= $000A
   354 = 00CC			COLOR_LIGHTGREEN	= $00CC
   355 = 007C			COLOR_LIGHTBLUE	= $007C
   356 = 0004			FMOPENREAD	= $0004
   357 = 0008			FMOPENWRITE	= $0008
   358 = 0009			FMOPENAPPEND	= $0009
   359 = 000C			FMOPENREADWRITE	= $000C
   360 = 2DE4			SCREENWIDTH	= DATAORIGIN+$0000
   361 = 2DE6			SCREENHEIGHT	= DATAORIGIN+$0002
   362 = 2DE8			FILEMODE	= DATAORIGIN+$0004
   363 = 2DE9			SCREENMODE	= DATAORIGIN+$0005
   364 = 2DEA			IORESULT	= DATAORIGIN+$0006
   365 = 2DEB			EOLN	= DATAORIGIN+$0007
   366 = 2DEC			RNDSEED	= DATAORIGIN+$0008
   367
   368 				.endl							; UNIT SYSTEM
   369
   370 				; -----------------------------------------------------------
   371
   372 21A9			.local	ATARI						; UNIT
   373
   374 				; -----------------------------------------------------------
   375
   376 = 0012			RTCLOK	= $0012
   377 = 004D			ATRACT	= $004D
   378 = 0052			LMARGIN	= $0052
   379 = 0053			RMARGIN	= $0053
   380 = 0054			ROWCRS	= $0054
   381 = 0055			COLCRS	= $0055
   382 = 0057			DINDEX	= $0057
   383 = 0058			SAVMSC	= $0058
   384 = 0200			VDSLST	= $0200
   385 = 0230			SDLSTL	= $0230
   386 = 0290			TXTROW	= $0290
   387 = 0291			TXTCOL	= $0291
   388 = 0293			TINDEX	= $0293
   389 = 0294			TXTMSC	= $0294
   390 = 022F			SDMCTL	= $022F
   391 = 026F			GPRIOR	= $026F
   392 = 02F0			CRSINH	= $02F0
   393 = 02F3			CHACT	= $02F3
   394 = 02F4			CHBAS	= $02F4
   395 = 02FC			CH	= $02FC
   396 = 02C0			PCOLR0	= $02C0
   397 = 02C1			PCOLR1	= $02C1
   398 = 02C2			PCOLR2	= $02C2
   399 = 02C3			PCOLR3	= $02C3
   400 = 02C4			COLOR0	= $02C4
   401 = 02C5			COLOR1	= $02C5
   402 = 02C6			COLOR2	= $02C6
   403 = 02C7			COLOR3	= $02C7
   404 = 02C8			COLOR4	= $02C8
   405 = D000			HPOSP0	= $D000
   406 = D001			HPOSP1	= $D001
   407 = D002			HPOSP2	= $D002
   408 = D003			HPOSP3	= $D003
   409 = D004			HPOSM0	= $D004
   410 = D005			HPOSM1	= $D005
   411 = D006			HPOSM2	= $D006
   412 = D007			HPOSM3	= $D007
   413 = D008			SIZEP0	= $D008
   414 = D009			SIZEP1	= $D009
   415 = D00A			SIZEP2	= $D00A
   416 = D00B			SIZEP3	= $D00B
   417 = D00C			SIZEM	= $D00C
   418 = D00D			GRAFP0	= $D00D
   419 = D00E			GRAFP1	= $D00E
   420 = D00F			GRAFP2	= $D00F
   421 = D010			GRAFP3	= $D010
   422 = D011			GRAFM	= $D011
   423 = D004			P0PF	= $D004
   424 = D014			PAL	= $D014
   425 = D012			COLPM0	= $D012
   426 = D013			COLPM1	= $D013
   427 = D014			COLPM2	= $D014
   428 = D015			COLPM3	= $D015
   429 = D016			COLPF0	= $D016
   430 = D017			COLPF1	= $D017
   431 = D018			COLPF2	= $D018
   432 = D019			COLPF3	= $D019
   433 = D01A			COLBK	= $D01A
   434 = D01B			PRIOR	= $D01B
   435 = D01D			GRACTL	= $D01D
   436 = D01E			HITCLR	= $D01E
   437 = D200			AUDF1	= $D200
   438 = D201			AUDC1	= $D201
   439 = D202			AUDF2	= $D202
   440 = D203			AUDC2	= $D203
   441 = D204			AUDF3	= $D204
   442 = D205			AUDC3	= $D205
   443 = D206			AUDF4	= $D206
   444 = D207			AUDC4	= $D207
   445 = D208			AUDCTL	= $D208
   446 = D20F			SKSTAT	= $D20F
   447 = D301			PORTB	= $D301
   448 = D400			DMACTL	= $D400
   449 = D401			CHACTL	= $D401
   450 = D402			DLISTL	= $D402
   451 = D404			HSCROL	= $D404
   452 = D405			VSCROL	= $D405
   453 = D407			PMBASE	= $D407
   454 = D409			CHBASE	= $D409
   455 = D40A			WSYNC	= $D40A
   456 = D40B			VCOUNT	= $D40B
   457 = D40C			PENH	= $D40C
   458 = D40D			PENV	= $D40D
   459 = D40E			NMIEN	= $D40E
   460
   461 				.endl							; UNIT ATARI
   462
   463 				; -----------------------------------------------------------
   464
   465 21A9			.local	CRT						; UNIT
   466
   467 21A9			.local	CURSOROFF					; PROCEDURE
   468
   469 					ift l_013E-*>3
   470 					jmp l_013E
   471 					eif
   472
   473 				; IfThenEpilog
   474 21A9			l_013E
   475
   476 				; optimize OK (CRT), line = 116
   477
   478 21A9 A9 01 8D F0 02		mva #$01 ATARI.CRSINH
   479
   480 				; -----------------------------------------------------------
   481
   482 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   483 				; as Value $0000001F (31)
   484
   485 21AE E8				inx						; add bx, 1
   486 21AF A9 1F 95 98			mva #$1F :STACKORIGIN,x
   487
   488 21B3 20 D7 2B			@printCHAR
   489 21B6 CA				dex						; sub bx, 1
   490
   491 				; -----------------------------------------------------------
   492
   493 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   494 				; as Value $0000001E (30)
   495
   496 21B7 E8				inx						; add bx, 1
   497 21B8 A9 1E 95 98			mva #$1E :STACKORIGIN,x
   498
   499 21BC 20 D7 2B			@printCHAR
   500 21BF CA				dex						; sub bx, 1
   501
   502 21C0			@exit
   503 					.ifdef @new
   504 					@FreeMem #@VarData #@VarDataSize
   505 					eif
   506 21C0 60				rts						; ret
   507 				.endl
   508
   509 21C1			.local	CURSORON					; PROCEDURE
   510
   511 					ift l_0155-*>3
   512 					jmp l_0155
   513 					eif
   514
   515 				; IfThenEpilog
   516 21C1			l_0155
   517
   518 				; optimize OK (CRT), line = 129
   519
   520 21C1 A9 00 8D F0 02		mva #$00 ATARI.CRSINH
   521
   522 				; -----------------------------------------------------------
   523
   524 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   525 				; as Value $0000001F (31)
   526
   527 21C6 E8				inx						; add bx, 1
   528 21C7 A9 1F 95 98			mva #$1F :STACKORIGIN,x
   529
   530 21CB 20 D7 2B			@printCHAR
   531 21CE CA				dex						; sub bx, 1
   532
   533 				; -----------------------------------------------------------
   534
   535 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   536 				; as Value $0000001E (30)
   537
   538 21CF E8				inx						; add bx, 1
   539 21D0 A9 1E 95 98			mva #$1E :STACKORIGIN,x
   540
   541 21D4 20 D7 2B			@printCHAR
   542 21D7 CA				dex						; sub bx, 1
   543
   544 21D8			@exit
   545 					.ifdef @new
   546 					@FreeMem #@VarData #@VarDataSize
   547 					eif
   548 21D8 60				rts						; ret
   549 				.endl
   550
   551 21D9			.local	READKEY						; FUNCTION | ASSEMBLER
   552
   553
   554 				; ---------------------  ASM Block 046  ---------------------
   555
   556 21D9 8A 48			txa:pha
   557
   558 21DB 20 EE 2C			@GetKey
   559
   560 21DE 8D F8 2D			sta Result
   561
   562 21E1 68 AA			pla:tax
   563
   564
   565 21E3			@exit
   566
   567 				; -----------------------------------------------------------
   568
   569 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   570 				; as Pointer
   571
   572 21E3 E8				inx						; add bx, 1
   573 21E4 AD F8 2D 95 98		mva RESULT :STACKORIGIN,x
   574
   575 					.ifdef @new
   576 					@FreeMem #@VarData #@VarDataSize
   577 					eif
   578
   579 				; -----------------------------------------------------------
   580
   581 = 2DF8			RESULT	= DATAORIGIN+$0014
   582
   583 = 2DF8			@VarData	= RESULT
   584 = 0001			@VarDataSize	= 1
   585
   586 21E9 60				rts						; ret
   587 				.endl
   588
   589 21EA			.local	TEXTBACKGROUND					; PROCEDURE | ASSEMBLER
   590
   591 				; -----------------------------------------------------------
   592
   593 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   594 				; as Pointer
   595 21EA B5 98 8D F9 2D		mva :STACKORIGIN,x A
   596 21EF CA				dex						; sub bx, 1
   597
   598
   599 				; ---------------------  ASM Block 047  ---------------------
   600
   601 21F0 AD F9 2D 8D C6 02 + 	mwa a colpf2s
   602
   603
   604 				; -----------------------------------------------------------
   605
   606 = 2DF9			A	= DATAORIGIN+$0015
   607
   608 = 2DF9			@VarData	= A
   609 = 0001			@VarDataSize	= 1
   610
   611
   612 21FC			@exit
   613 					.ifdef @new
   614 					@FreeMem #@VarData #@VarDataSize
   615 					eif
   616 21FC 60				rts						; ret
   617 				.endl
   618
   619 21FD			.local	TEXTCOLOR					; PROCEDURE | ASSEMBLER
   620
   621 				; -----------------------------------------------------------
   622
   623 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   624 				; as Pointer
   625 21FD B5 98 8D FA 2D		mva :STACKORIGIN,x A
   626 2202 CA				dex						; sub bx, 1
   627
   628
   629 				; ---------------------  ASM Block 048  ---------------------
   630
   631 2203 AD FA 2D 8D C5 02		mva a colpf1s
   632
   633
   634 				; -----------------------------------------------------------
   635
   636 = 2DFA			A	= DATAORIGIN+$0016
   637
   638 = 2DFA			@VarData	= A
   639 = 0001			@VarDataSize	= 1
   640
   641
   642 2209			@exit
   643 					.ifdef @new
   644 					@FreeMem #@VarData #@VarDataSize
   645 					eif
   646 2209 60				rts						; ret
   647 				.endl
   648
   649 220A			.local	DELAY						; PROCEDURE | ASSEMBLER
   650
   651 				; -----------------------------------------------------------
   652
   653 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   654 				; as Pointer
   655 220A B5 98 8D FB 2D		mva :STACKORIGIN,x COUNT
   656 220F B5 A8 8D FC 2D		mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   657 2214 CA				dex						; sub bx, 1
   658
   659
   660 				; ---------------------  ASM Block 049  ---------------------
   661
   662 2215 8A 48			txa:pha
   663
   664 2217 A2 00			ldx #0
   665 2219 A0 00			ldy #0
   666
   667 221B CC FB 2D		loop	cpy count
   668 221E D0 05			bne @+
   669 2220 EC FC 2D			cpx count+1
   670 2223 F0 46			beq stop
   671
   672 2225 AD 0B D4 CD 0B D4 + @	:8 lda:cmp:req vcount
   673
   674 2265 C8				iny
   675 2266 D0 01			sne
   676 2268 E8				inx
   677
   678 2269 D0 B0			bne loop
   679
   680 226B 68 AA		stop	pla:tax
   681
   682
   683 				; -----------------------------------------------------------
   684
   685 = 2DFB			COUNT	= DATAORIGIN+$0017
   686
   687 = 2DFB			@VarData	= COUNT
   688 = 0002			@VarDataSize	= 2
   689
   690
   691 226D			@exit
   692 					.ifdef @new
   693 					@FreeMem #@VarData #@VarDataSize
   694 					eif
   695 226D 60				rts						; ret
   696 				.endl
   697
   698 226E			.local	KEYPRESSED					; FUNCTION | ASSEMBLER
   699
   700
   701 				; ---------------------  ASM Block 050  ---------------------
   702
   703 226E A0 00			ldy #$00	; false
   704 2270 AD FC 02			lda kbcodes
   705 2273 C9 FF			cmp #$ff
   706 2275 F0 01			beq skp
   707 2277 C8				iny		; true
   708
   709 				;	sty kbcodes
   710
   711 2278 8C FD 2D		skp	sty Result
   712
   713
   714 227B			@exit
   715
   716 				; -----------------------------------------------------------
   717
   718 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   719 				; as Pointer
   720
   721 227B E8				inx						; add bx, 1
   722 227C AD FD 2D 95 98		mva RESULT :STACKORIGIN,x
   723
   724 					.ifdef @new
   725 					@FreeMem #@VarData #@VarDataSize
   726 					eif
   727
   728 				; -----------------------------------------------------------
   729
   730 = 2DFD			RESULT	= DATAORIGIN+$0019
   731
   732 = 2DFD			@VarData	= RESULT
   733 = 0001			@VarDataSize	= 1
   734
   735 2281 60				rts						; ret
   736 				.endl
   737
   738 2282			.local	GOTOXY						; PROCEDURE | ASSEMBLER
   739
   740 				; -----------------------------------------------------------
   741
   742 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   743 				; as Pointer
   744 2282 B5 98 8D FF 2D		mva :STACKORIGIN,x Y
   745 2287 CA				dex						; sub bx, 1
   746
   747 				; -----------------------------------------------------------
   748
   749 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   750 				; as Pointer
   751 2288 B5 98 8D FE 2D		mva :STACKORIGIN,x X
   752 228D CA				dex						; sub bx, 1
   753
   754
   755 				; ---------------------  ASM Block 051  ---------------------
   756
   757 228E AC FE 2D			ldy x
   758 2291 F0 03			beq @+
   759 2293 88				dey
   760 2294 84 55			sty colcrs
   761
   762 2296 AC FF 2D		@	ldy y
   763 2299 F0 03			beq @+
   764 229B 88				dey
   765 229C 84 54			sty rowcrs
   766 229E			@
   767
   768
   769 				; -----------------------------------------------------------
   770
   771 = 2DFE			X	= DATAORIGIN+$001A
   772 = 2DFF			Y	= DATAORIGIN+$001B
   773
   774 = 2DFE			@VarData	= X
   775 = 0002			@VarDataSize	= 2
   776
   777
   778 229E			@exit
   779 					.ifdef @new
   780 					@FreeMem #@VarData #@VarDataSize
   781 					eif
   782 229E 60				rts						; ret
   783 				.endl
   784
   785 229F			.local	WHEREY						; FUNCTION | ASSEMBLER
   786
   787
   788 				; ---------------------  ASM Block 053  ---------------------
   789
   790
   791 229F A4 54			ldy rowcrs
   792 22A1 C8				iny
   793 22A2 8C 00 2E			sty Result
   794
   795
   796 22A5			@exit
   797
   798 				; -----------------------------------------------------------
   799
   800 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   801 				; as Pointer
   802
   803 22A5 E8				inx						; add bx, 1
   804 22A6 AD 00 2E 95 98		mva RESULT :STACKORIGIN,x
   805
   806 					.ifdef @new
   807 					@FreeMem #@VarData #@VarDataSize
   808 					eif
   809
   810 				; -----------------------------------------------------------
   811
   812 = 2E00			RESULT	= DATAORIGIN+$001C
   813
   814 = 2E00			@VarData	= RESULT
   815 = 0001			@VarDataSize	= 1
   816
   817 22AB 60				rts						; ret
   818 				.endl
   819
   820 				; -----------------------------------------------------------
   821
   822 = 2DF7			TEXTATTR	= DATAORIGIN+$0013
   823 = D01F			CONSOL	= $D01F
   824 = 0000			CN_START_SELECT_OPTION	= $0000
   825 = 0001			CN_SELECT_OPTION	= $0001
   826 = 0002			CN_START_OPTION	= $0002
   827 = 0003			CN_OPTION	= $0003
   828 = 0004			CN_START_SELECT	= $0004
   829 = 0005			CN_SELECT	= $0005
   830 = 0006			CN_START	= $0006
   831 = 0007			CN_NONE	= $0007
   832 = 0000			BW40	= $0000
   833 = 0001			CO40	= $0001
   834 = 0002			BW80	= $0002
   835 = 0003			CO80	= $0003
   836 = 0007			MONO	= $0007
   837 = 0001			C40	= $0001
   838 = 0003			C80	= $0003
   839 = 0000			BLACK	= $0000
   840 = 0001			BLUE	= $0001
   841 = 0002			GREEN	= $0002
   842 = 0003			CYAN	= $0003
   843 = 0004			RED	= $0004
   844 = 0005			MAGENTA	= $0005
   845 = 0006			BROWN	= $0006
   846 = 0007			LIGHTGRAY	= $0007
   847 = 0008			DARKGRAY	= $0008
   848 = 0009			LIGHTBLUE	= $0009
   849 = 000A			LIGHTGREEN	= $000A
   850 = 000B			LIGHTCYAN	= $000B
   851 = 000C			LIGHTRED	= $000C
   852 = 000D			LIGHTMAGENTA	= $000D
   853 = 000E			YELLOW	= $000E
   854 = 000F			WHITE	= $000F
   855 = 0080			BLINK	= $0080
   856
   857 				.endl							; UNIT CRT
   858
   859 				; -----------------------------------------------------------
   860
   861 22AC			.local	RMT						; UNIT
   862
   863 				; -----------------------------------------------------------
   864
   865
   866 				.endl							; UNIT RMT
   867
   868 				; -----------------------------------------------------------
   869
   870 22AC			.local	B_UTILS						; UNIT
   871
   872 22AC			.local	NULLTERMTOSTRING				; FUNCTION
   873
   874 				; -----------------------------------------------------------
   875
   876 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   877 				; as Pointer
   878 22AC B5 98 8D 11 2E		mva :STACKORIGIN,x PTR
   879 22B1 B5 A8 8D 12 2E		mva :STACKORIGIN+STACKWIDTH,x PTR+1
   880 22B6 CA				dex						; sub bx, 1
   881
   882 					ift l_01A0-*>3
   883 					jmp l_01A0
   884 					eif
   885
   886 				; IfThenEpilog
   887 22B7			l_01A0
   888
   889 				; optimize OK (B_UTILS), line = 81
   890
   891 22B7 A9 00 8D 13 2E		mva #$00 adr.RESULT+$00
   892
   893 				; --- WhileProlog
   894 22BC			l_01A6
   895
   896 				; optimize OK (B_UTILS), line = 82
   897
   898 22BC AD 12 2E			lda PTR+1
   899 22BF 85 8F			sta :bp+1
   900 22C1 AC 11 2E			ldy PTR
   901 22C4 B1 8E			lda (:bp),y
   902 22C6 A0 01			ldy #1
   903 22C8 C9 00			cmp #$00
   904 22CA D0 01			bne @+
   905 22CC 88				dey
   906 22CD			@
   907 22CD 98				tya
   908 22CE D0 03			bne *+5
   909 22D0 4C F5 22			jmp l_01B5
   910
   911 				; optimize OK (B_UTILS), line = 83
   912
   913 22D3 EE 13 2E			inc adr.RESULT+$00
   914
   915 				; optimize OK (B_UTILS), line = 84
   916
   917 22D6 AD 13 2E			lda adr.RESULT+$00
   918 22D9 85 A1			sta :STACKORIGIN+9
   919 22DB AD 12 2E			lda PTR+1
   920 22DE 85 8F			sta :bp+1
   921 22E0 AC 11 2E			ldy PTR
   922 22E3 B1 8E			lda (:bp),y
   923 22E5 A4 A1			ldy :STACKORIGIN+9
   924 22E7 99 13 2E			sta adr.RESULT,y
   925
   926 				; optimize FAIL (0, B_UTILS), line = 85
   927 22EA EE 11 2E D0 03 EE + 	inw PTR
   928
   929 				; --- WhileDoEpilog
   930 22F2			c_01A6
   931
   932 				; WhileDoEpilog
   933 22F2 4C BC 22			jmp l_01A6
   934 22F5			l_01B5
   935 22F5			b_01A6
   936
   937 22F5			@exit
   938
   939 				; -----------------------------------------------------------
   940
   941 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   942 				; as Pointer
   943
   944 22F5 E8				inx						; add bx, 1
   945 22F6 AD 01 23 95 98		mva RESULT :STACKORIGIN,x
   946 22FB AD 02 23 95 A8		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   947
   948 					.ifdef @new
   949 					@FreeMem #@VarData #@VarDataSize
   950 					eif
   951
   952 				; -----------------------------------------------------------
   953
   954 = 2E11			PTR	= DATAORIGIN+$002D
   955 = 2E13			adr.RESULT	= DATAORIGIN+$002F
   956 2300			.var RESULT	= adr.RESULT .word
   957
   958 = 2E11			@VarData	= PTR
   959 = 0102			@VarDataSize	= 258
   960
   961 2300 60				rts						; ret
   962 = 2301 13 2E		RESULT
   962 				.endl
   963
   964 				; -----------------------------------------------------------
   965
   966
   967 				.endl							; UNIT B_UTILS
   968
   969 				; -----------------------------------------------------------
   970
   971 2303			.local	B_DL						; UNIT
   972
   973 				; -----------------------------------------------------------
   974
   975 = 0000			DL_BLANK1	= $0000
   976 = 0010			DL_BLANK2	= $0010
   977 = 0020			DL_BLANK3	= $0020
   978 = 0030			DL_BLANK4	= $0030
   979 = 0040			DL_BLANK5	= $0040
   980 = 0050			DL_BLANK6	= $0050
   981 = 0060			DL_BLANK7	= $0060
   982 = 0070			DL_BLANK8	= $0070
   983 = 0080			DL_DLI	= $0080
   984 = 0040			DL_LMS	= $0040
   985 = 0020			DL_VSCROLL	= $0020
   986 = 0010			DL_HSCROLL	= $0010
   987 = 0002			DL_MODE_40X24T2	= $0002
   988 = 0004			DL_MODE_40X24T5	= $0004
   989 = 0005			DL_MODE_40X12T5	= $0005
   990 = 0006			DL_MODE_20X24T5	= $0006
   991 = 0007			DL_MODE_20X12T5	= $0007
   992 = 0008			DL_MODE_40X24G4	= $0008
   993 = 0009			DL_MODE_80X48G2	= $0009
   994 = 000A			DL_MODE_80X48G4	= $000A
   995 = 000B			DL_MODE_160X96G2	= $000B
   996 = 000C			DL_MODE_160X192G2	= $000C
   997 = 000D			DL_MODE_160X96G4	= $000D
   998 = 000E			DL_MODE_160X192G4	= $000E
   999 = 000F			DL_MODE_320X192G2	= $000F
  1000 = 0001			DL_JMP	= $0001
  1001 = 0041			DL_JVB	= $0041
  1002 = 2F13			DL_ADDRESS	= DATAORIGIN+$012F
  1003 = 2F15			DL_CURSOR	= DATAORIGIN+$0131
  1004
  1005 				.endl							; UNIT B_DL
  1006
  1007 				; -----------------------------------------------------------
  1008
  1009 2303			.local	B_SYSTEM					; UNIT
  1010
  1011 				; -----------------------------------------------------------
  1012
  1013 = 2F16			__NMIEN	= DATAORIGIN+$0132
  1014 = 0080			PORTB_SELFTEST_OFF	= $0080
  1015 = 0002			PORTB_BASIC_OFF	= $0002
  1016 = 0001			PORTB_SYSTEM_ON	= $0001
  1017
  1018 				.endl							; UNIT B_SYSTEM
  1019
  1020 2303			.local	DLI1						; PROCEDURE | ASSEMBLER | INTERRUPT
  1021
  1022
  1023 				; ---------------------  ASM Block 069  ---------------------
  1024
  1025
  1026 2303 48			        pha
  1027 2304 AD 0A D2		        lda $d20a
  1028 2307 8D 1A D0		        sta $d01a
  1029 230A 8D 0A D4		        sta ATARI.WSYNC
  1030 				//        mva #$01 ATARI.COLOR0
  1031 				//        mva #$02 ATARI.COLOR1
  1032 				//        mva #$03 ATARI.COLOR2
  1033 				//        mva #$04 ATARI.COLOR3
  1034 				//        mva #$05 ATARI.COLOR4
  1035 				//        mwa #DLI2 ATARI.VDSLST
  1036 230D 68			        pla
  1037 				        
  1038 230E 40				rti						; ret
  1039 				.endl
  1040
  1041 230F			.local	DLI2						; PROCEDURE | ASSEMBLER | INTERRUPT
  1042
  1043
  1044 				; ---------------------  ASM Block 070  ---------------------
  1045
  1046
  1047 230F 48			        pha
  1048 2310 8D 0A D4		        sta ATARI.WSYNC
  1049 				      //  mva #$00 ATARI.COLOR0
  1050 2313 A9 0C 8D C5 02	        mva #$0c ATARI.COLOR1
  1051 2318 A9 00 8D C6 02	        mva #$00 ATARI.COLOR2
  1052 231D A9 00 8D C8 02	        mva #$00 ATARI.COLOR4
  1053 2322 A9 2E 8D 00 02 A9 +         mwa #DLI3 ATARI.VDSLST
  1054 232C 68			        pla
  1055 				        
  1056 232D 40				rti						; ret
  1057 				.endl
  1058
  1059 232E			.local	DLI3						; PROCEDURE | ASSEMBLER | INTERRUPT
  1060
  1061
  1062 				; ---------------------  ASM Block 071  ---------------------
  1063
  1064
  1065 232E 48			        pha
  1066 232F A9 06 8D C8 02	        mva #$06 ATARI.COLOR4
  1067 2334 8D 0A D4 8D 0A D4 +         :3 sta ATARI.WSYNC
  1068 233D A9 08 8D C8 02	        mva #$08 ATARI.COLOR4
  1069 2342 8D 0A D4		        sta ATARI.WSYNC
  1070 2345 A9 0A 8D C8 02	        mva #$0a ATARI.COLOR4
  1071 234A 8D 0A D4		        sta ATARI.WSYNC
  1072 234D A9 0C 8D C8 02	        mva #$0c ATARI.COLOR4
  1073 2352 8D 0A D4		        sta ATARI.WSYNC
  1074 2355 A9 0A 8D C8 02	        mva #$0a ATARI.COLOR4
  1075 235A 8D 0A D4		        sta ATARI.WSYNC
  1076 235D A9 08 8D C8 02	        mva #$08 ATARI.COLOR4
  1077
  1078 				      //  mwa #DLI1 ATARI.VDSLST
  1079 2362 68			        pla
  1080 				        
  1081 2363 40				rti						; ret
  1082 				.endl
  1083
  1084 2364			.local	VBL						; PROCEDURE | ASSEMBLER | INTERRUPT
  1085
  1086
  1087 				; ---------------------  ASM Block 072  ---------------------
  1088
  1089
  1090 2364 48 8A 48 98 48	    phr ; store registers
  1091
  1092 				;   *** example test routine
  1093 				;    mva 20 atari.colbk // blink background
  1094
  1095 				;   *** RMT play routine
  1096 				;    lda MSX
  1097 				;    ldy MSX+1
  1098 				;    jsr RMT.TRMT.PLAY
  1099 				;    mwa #dli1 ATARI.VDSLST
  1100
  1101 2369 68 A8 68 AA 68	    plr ; restore registers
  1102 236E 4C 62 E4		    jmp $E462 ; jump to system VBL handler
  1103
  1104 2371 40				rti						; ret
  1105 				.endl
  1106
  1107 2372			.local	CLRLINE						; PROCEDURE
  1108
  1109 					ift l_01D6-*>3
  1110 					jmp l_01D6
  1111 					eif
  1112
  1113 				; IfThenEpilog
  1114 2372			l_01D6
  1115
  1116 				; optimize FAIL ('CRT.WHEREY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 39
  1117 2372 E8				inx
  1118 2373 A9 58 95 98			mva #$58 :STACKORIGIN,x
  1119 2377 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1120 237B 20 22 21			jsr SYSTEM.DPEEK
  1121 237E E8				inx
  1122 237F A9 01 95 98			mva #$01 :STACKORIGIN,x
  1123 2383 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1124 2387 20 4B 2B			jsr addAX_CX
  1125 238A CA				dex
  1126 238B 20 9F 22			jsr CRT.WHEREY
  1127 238E E8				inx
  1128 238F A9 28 95 98			mva #$28 :STACKORIGIN,x
  1129 2393 20 C6 2B			jsr imulBYTE
  1130 2396 20 3A 2B			jsr movaBX_EAX
  1131 2399 CA				dex
  1132 239A 20 4B 2B			jsr addAX_CX
  1133 239D A9 29 95 98			mva #$29 :STACKORIGIN,x
  1134 23A1 20 90 2B			jsr @expandToCARD.BYTE
  1135 23A4 20 62 2B			jsr subEAX_ECX
  1136 23A7 A9 28 95 98			mva #$28 :STACKORIGIN,x
  1137 23AB A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1138 23AF E8				inx
  1139 23B0 A9 00 95 98			mva #$00 :STACKORIGIN,x
  1140 23B4 20 8E 21			jsr SYSTEM.FILLCHAR_011F
  1141
  1142 23B7			@exit
  1143 					.ifdef @new
  1144 					@FreeMem #@VarData #@VarDataSize
  1145 					eif
  1146 23B7 60				rts						; ret
  1147 				.endl
  1148
  1149 23B8			.local	LOADITEMS					; PROCEDURE
  1150
  1151 					ift l_01F0-*>3
  1152 					jmp l_01F0
  1153 					eif
  1154
  1155 				; IfThenEpilog
  1156 23B8			l_01F0
  1157 				; For
  1158
  1159 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 95
  1160
  1161 23B8 A9 00 8D 7A 2F		mva #$00 I
  1162
  1163 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 95
  1164
  1165 				; To
  1166 23BD			l_01FF
  1167
  1168 				; ForToDoCondition
  1169
  1170 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 95
  1171
  1172 23BD AD 7A 2F			lda I
  1173 23C0 C9 16			cmp #$16
  1174 23C2 90 05			bcc *+7
  1175 23C4 F0 03			beq *+5
  1176
  1177 				; ForToDoProlog
  1178 23C6 4C 18 24			jmp l_020D
  1179
  1180 				; optimize FAIL ('B_UTILS.NULLTERMTOSTRING', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 99
  1181 23C9 E8				inx
  1182 23CA AD 7A 2F 95 98		mva I :STACKORIGIN,x
  1183 23CF A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1184 23D3				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 23D3 16 98			asl :STACKORIGIN-0,x
     2 23D5 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1185 23D7 E8				inx
  1186 23D8 AD 7A 2F 95 98		mva I :STACKORIGIN,x
  1187 23DD A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1188 23E1				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 23E1 16 98			asl :STACKORIGIN-0,x
     2 23E3 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1189 23E5 AD 1B 24			lda ITEMSTRINGS
  1190 23E8 18 75 98			add :STACKORIGIN,x
  1191 23EB 85 90			sta :bp2
  1192 23ED AD 1C 24			lda ITEMSTRINGS+1
  1193 23F0 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1194 23F2 85 91			sta :bp2+1
  1195 23F4 A0 00			ldy #$00
  1196 23F6 B1 90			lda (:bp2),y
  1197 23F8 95 98			sta :STACKORIGIN,x
  1198 23FA C8				iny
  1199 23FB B1 90			lda (:bp2),y
  1200 23FD 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1201 23FF 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING
  1202 2402 B4 97			ldy :STACKORIGIN-1,x
  1203 2404 B5 98			lda :STACKORIGIN,x
  1204 2406 99 4C 2F			sta adr.ITEMS,y
  1205 2409 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
  1206 240B 99 4D 2F			sta adr.ITEMS+1,y
  1207 240E CA				dex
  1208 240F CA				dex
  1209
  1210 				; ForToDoEpilog
  1211 2410			c_01FF
  1212 2410 EE 7A 2F			inc I						; inc ptr byte [CounterAddress]
  1213
  1214 2413 F0 03			seq
  1215
  1216 				; WhileDoEpilog
  1217 2415 4C BD 23			jmp l_01FF
  1218 2418			l_020D
  1219 2418			b_01FF
  1220
  1221 				; -----------------------------------------------------------
  1222
  1223 = 2F7A			I	= DATAORIGIN+$0196
  1224 = 2F7B			adr.S	= DATAORIGIN+$0197
  1225 2418			.var S	= adr.S .word
  1226 = 5E00			adr.ITEMSTRINGS	= $5E00
  1227 2418			.var ITEMSTRINGS	= adr.ITEMSTRINGS .word
  1228 = 0016			@FORTMP_505	= $0016
  1229
  1230 = 2F7A			@VarData	= I
  1231 = 0103			@VarDataSize	= 259
  1232
  1233
  1234 2418			@exit
  1235 					.ifdef @new
  1236 					@FreeMem #@VarData #@VarDataSize
  1237 					eif
  1238 2418 60				rts						; ret
  1239 = 2419 7B 2F		S
  1239 = 241B 00 5E		ITEMSTRINGS
  1239 				.endl
  1240
  1241 241D			.local	LOADLOCATIONS					; PROCEDURE
  1242
  1243 					ift l_0222-*>3
  1244 					jmp l_0222
  1245 					eif
  1246
  1247 				; IfThenEpilog
  1248 241D			l_0222
  1249 				; For
  1250
  1251 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 111
  1252
  1253 241D A9 00 8D 7B 30		mva #$00 I
  1254
  1255 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 111
  1256
  1257 				; To
  1258 2422			l_0231
  1259
  1260 				; ForToDoCondition
  1261
  1262 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 111
  1263
  1264 2422 AD 7B 30			lda I
  1265 2425 C9 0F			cmp #$0F
  1266 2427 90 05			bcc *+7
  1267 2429 F0 03			beq *+5
  1268
  1269 				; ForToDoProlog
  1270 242B 4C 7D 24			jmp l_023F
  1271
  1272 				; optimize FAIL ('B_UTILS.NULLTERMTOSTRING', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 113
  1273 242E E8				inx
  1274 242F AD 7B 30 95 98		mva I :STACKORIGIN,x
  1275 2434 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1276 2438				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 2438 16 98			asl :STACKORIGIN-0,x
     2 243A 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1277 243C E8				inx
  1278 243D AD 7B 30 95 98		mva I :STACKORIGIN,x
  1279 2442 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1280 2446				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 2446 16 98			asl :STACKORIGIN-0,x
     2 2448 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1281 244A AD 80 24			lda LOCATIONSTRINGS
  1282 244D 18 75 98			add :STACKORIGIN,x
  1283 2450 85 90			sta :bp2
  1284 2452 AD 81 24			lda LOCATIONSTRINGS+1
  1285 2455 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1286 2457 85 91			sta :bp2+1
  1287 2459 A0 00			ldy #$00
  1288 245B B1 90			lda (:bp2),y
  1289 245D 95 98			sta :STACKORIGIN,x
  1290 245F C8				iny
  1291 2460 B1 90			lda (:bp2),y
  1292 2462 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1293 2464 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING
  1294 2467 B4 97			ldy :STACKORIGIN-1,x
  1295 2469 B5 98			lda :STACKORIGIN,x
  1296 246B 99 2C 2F			sta adr.LOCATIONS,y
  1297 246E B5 A8			lda :STACKORIGIN+STACKWIDTH,x
  1298 2470 99 2D 2F			sta adr.LOCATIONS+1,y
  1299 2473 CA				dex
  1300 2474 CA				dex
  1301
  1302 				; ForToDoEpilog
  1303 2475			c_0231
  1304 2475 EE 7B 30			inc I						; inc ptr byte [CounterAddress]
  1305
  1306 2478 F0 03			seq
  1307
  1308 				; WhileDoEpilog
  1309 247A 4C 22 24			jmp l_0231
  1310 247D			l_023F
  1311 247D			b_0231
  1312
  1313 				; -----------------------------------------------------------
  1314
  1315 = 307B			I	= DATAORIGIN+$0297
  1316 = 307C			adr.S	= DATAORIGIN+$0298
  1317 247D			.var S	= adr.S .word
  1318 = 5C00			adr.LOCATIONSTRINGS	= $5C00
  1319 247D			.var LOCATIONSTRINGS	= adr.LOCATIONSTRINGS .word
  1320 = 000F			@FORTMP_555	= $000F
  1321
  1322 = 307B			@VarData	= I
  1323 = 0103			@VarDataSize	= 259
  1324
  1325
  1326 247D			@exit
  1327 					.ifdef @new
  1328 					@FreeMem #@VarData #@VarDataSize
  1329 					eif
  1330 247D 60				rts						; ret
  1331 = 247E 7C 30		S
  1331 = 2480 00 5C		LOCATIONSTRINGS
  1331 				.endl
  1332
  1333 2482			.local	START						; PROCEDURE
  1334
  1335 					ift l_0254-*>3
  1336 					jmp l_0254
  1337 					eif
  1338
  1339 				; IfThenEpilog
  1340 2482			l_0254
  1341
  1342 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 129
  1343
  1344 2482 A9 88 8D 21 2F		mva #$88 PLAYER.UEC
  1345 2487 A9 13 8D 22 2F		mva #$13 PLAYER.UEC+1
  1346 248C A9 00 8D 23 2F		mva #$00 PLAYER.UEC+2
  1347 2491 8D 24 2F			sta PLAYER.UEC+3
  1348
  1349 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 130
  1350
  1351 2494 A9 00 8D 25 2F		mva #$00 PLAYER.LOC
  1352
  1353 2499			@exit
  1354 					.ifdef @new
  1355 					@FreeMem #@VarData #@VarDataSize
  1356 					eif
  1357 2499 60				rts						; ret
  1358 				.endl
  1359
  1360 249A			.local	CONSOLE_NAVIGATION				; PROCEDURE
  1361
  1362 					ift l_0266-*>3
  1363 					jmp l_0266
  1364 					eif
  1365
  1366 				; IfThenEpilog
  1367 249A			l_0266
  1368
  1369 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 136
  1370 249A E8				inx
  1371 249B A9 01 95 98			mva #$01 :STACKORIGIN,x
  1372 249F E8				inx
  1373 24A0 95 98			sta :STACKORIGIN,x
  1374 24A2 20 82 22			jsr CRT.GOTOXY
  1375
  1376 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 136
  1377 24A5 20 72 23			jsr CLRLINE
  1378
  1379 					@printSTRING #CODEORIGIN+$0002
  1379 				 LDY> CODEORIGIN+$0002\ LDA< CODEORIGIN+$0002\ JSR @PRINTSTRING
  1379 24A8 A0 20		 LDY> CODEORIGIN+$0002
  1379 24AA A9 02		 LDA< CODEORIGIN+$0002
  1379 24AC 20 EA 2B		 JSR @PRINTSTRING
  1380
  1381 				; Array index LOCATIONS[0..15]
  1382
  1383 				; -----------------------------------------------------------
  1384
  1385 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1386 				; as Pointer
  1387
  1388 24AF E8				inx						; add bx, 1
  1389 24B0 AD 25 2F 95 98		mva PLAYER.LOC :STACKORIGIN,x
  1390 24B5 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x		; expand to WORD
  1391
  1392 24B9				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 24B9 16 98			asl :STACKORIGIN-0,x
     2 24BB 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: starvagrant.a65
  1393
  1394 				; -----------------------------------------------------------
  1395
  1396 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1397 				; as Pointer to Array Origin
  1398
  1399
  1400 24BD B4 98			ldy :STACKORIGIN,x				; si
  1401 24BF B9 2C 2F 95 98		mva adr.LOCATIONS,y :STACKORIGIN,x
  1402 24C4 B9 2D 2F 95 A8		mva adr.LOCATIONS+1,y :STACKORIGIN+STACKWIDTH,x
  1403
  1404 24C9 B5 98			lda :STACKORIGIN,x
  1405 24CB B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1406 24CD 20 EA 2B			jsr @printSTRING
  1407 24D0 CA				dex						; sub bx, 1
  1408 24D1 20 DC 2B			@printEOL
  1409
  1410 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 138
  1411 24D4 E8				inx
  1412 24D5 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1413 24D9 E8				inx
  1414 24DA A9 02 95 98			mva #$02 :STACKORIGIN,x
  1415 24DE 20 82 22			jsr CRT.GOTOXY
  1416
  1417 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 138
  1418 24E1 20 72 23			jsr CLRLINE
  1419
  1420 					@printSTRING #CODEORIGIN+$0007
  1420 				 LDY> CODEORIGIN+$0007\ LDA< CODEORIGIN+$0007\ JSR @PRINTSTRING
  1420 24E4 A0 20		 LDY> CODEORIGIN+$0007
  1420 24E6 A9 07		 LDA< CODEORIGIN+$0007
  1420 24E8 20 EA 2B		 JSR @PRINTSTRING
  1421 24EB 20 DC 2B			@printEOL
  1422
  1423 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 140
  1424 24EE E8				inx
  1425 24EF A9 01 95 98			mva #$01 :STACKORIGIN,x
  1426 24F3 E8				inx
  1427 24F4 A9 03 95 98			mva #$03 :STACKORIGIN,x
  1428 24F8 20 82 22			jsr CRT.GOTOXY
  1429
  1430 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 140
  1431 24FB 20 72 23			jsr CLRLINE
  1432
  1433 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 141
  1434 24FE E8				inx
  1435 24FF A9 01 95 98			mva #$01 :STACKORIGIN,x
  1436 2503 E8				inx
  1437 2504 A9 04 95 98			mva #$04 :STACKORIGIN,x
  1438 2508 20 82 22			jsr CRT.GOTOXY
  1439
  1440 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 141
  1441 250B 20 72 23			jsr CLRLINE
  1442
  1443 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 142
  1444 250E E8				inx
  1445 250F A9 01 95 98			mva #$01 :STACKORIGIN,x
  1446 2513 E8				inx
  1447 2514 A9 05 95 98			mva #$05 :STACKORIGIN,x
  1448 2518 20 82 22			jsr CRT.GOTOXY
  1449
  1450 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 142
  1451 251B 20 72 23			jsr CLRLINE
  1452
  1453 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 143
  1454 251E E8				inx
  1455 251F A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1456 2523 E8				inx
  1457 2524 A9 06 95 98			mva #$06 :STACKORIGIN,x
  1458 2528 20 82 22			jsr CRT.GOTOXY
  1459
  1460 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 143
  1461 252B 20 72 23			jsr CLRLINE
  1462
  1463 				; Array index STRINGS[0..0]
  1464
  1465 				; -----------------------------------------------------------
  1466
  1467 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1468 				; as Value $0000000C (12)
  1469
  1470 252E E8				inx						; add bx, 1
  1471 252F A9 0C 95 98			mva #$0C :STACKORIGIN,x
  1472 2533 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1473
  1474 				; -----------------------------------------------------------
  1475
  1476 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1477 				; as Pointer to Array Origin
  1478
  1479
  1480 2537 AD 30 2B			lda STRINGS
  1481 253A 18 75 98			add :STACKORIGIN,x
  1482 253D 85 90			sta :bp2
  1483 253F AD 31 2B			lda STRINGS+1
  1484 2542 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1485 2544 85 91			sta :bp2+1
  1486 2546 A0 00			ldy #$00
  1487 2548 B1 90			lda (:bp2),y
  1488 254A 95 98			sta :STACKORIGIN,x
  1489 254C C8				iny
  1490 254D B1 90			lda (:bp2),y
  1491 254F 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1492
  1493 2551 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1494
  1495
  1496 2554 B5 98			lda :STACKORIGIN,x
  1497 2556 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1498 2558 20 EA 2B			jsr @printSTRING
  1499 255B CA				dex						; sub bx, 1
  1500 255C 20 DC 2B			@printEOL
  1501
  1502 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 145
  1503 255F E8				inx
  1504 2560 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1505 2564 E8				inx
  1506 2565 A9 07 95 98			mva #$07 :STACKORIGIN,x
  1507 2569 20 82 22			jsr CRT.GOTOXY
  1508
  1509 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 145
  1510 256C 20 72 23			jsr CLRLINE
  1511
  1512 				; --- RepeatUntilProlog
  1513 256F			l_029A
  1514
  1515 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 149
  1516 256F 20 6E 22			jsr CRT.KEYPRESSED
  1517 					.ifdef IFTMP_23
  1518 					lda :STACKORIGIN,x
  1519 					sta IFTMP_23
  1520 					eif
  1521 2572 CA				dex
  1522 2573 B5 99			lda :STACKORIGIN+1,x
  1523 2575 D0 03			bne *+5
  1524 2577 4C 9B 25			jmp l_02A4
  1525
  1526 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 150
  1527 257A 20 D9 21			jsr CRT.READKEY
  1528 257D B5 98 8D 17 2F		mva :STACKORIGIN,x KEYVAL
  1529 2582 CA				dex
  1530
  1531 				; -----------------------------------------------------------
  1532
  1533 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1534 				; as Pointer
  1535
  1536 2583 E8				inx						; add bx, 1
  1537 2584 AD 17 2F 95 98		mva KEYVAL :STACKORIGIN,x
  1538
  1539 				; GenerateCaseProlog
  1540 2589 CA				dex						; sub bx, 1
  1541
  1542 				; GenerateCaseEqualityCheck
  1543 258A B5 99			lda :STACKORIGIN+1,x
  1544 258C C9 62			cmp #98
  1545 258E F0 03			beq @+
  1546
  1547 				; GenerateCaseStatementProlog
  1548 2590 4C 9B 25			jmp l_02BA
  1549 2593			@
  1550
  1551 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 152
  1552
  1553 2593 A9 01 8D 20 2F		mva #$01 CURRENT_MENU
  1554
  1555 				; GenerateCaseStatementEpilog
  1556 2598 4C 9B 25			jmp a_0002
  1557 259B			l_02BA
  1558
  1559 				; GenerateIfElseEpilog
  1560
  1561 				; GenerateCaseEpilog
  1562
  1563 				; GenerateIfElseEpilog
  1564 259B			a_0002
  1565
  1566 				; IfThenEpilog
  1567 259B			l_02A4
  1568
  1569 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 155
  1570
  1571 259B A0 01			ldy #1
  1572 259D AD 17 2F			lda KEYVAL
  1573 25A0 C9 62			cmp #$62
  1574 25A2 F0 01			beq @+
  1575 25A4 88				dey
  1576 25A5			@
  1577 25A5 98				tya
  1578 25A6 D0 03			bne *+5
  1579 25A8			c_029A
  1580 25A8 4C 6F 25			jmp l_029A
  1581 25AB			b_029A
  1582
  1583 25AB			@exit
  1584 					.ifdef @new
  1585 					@FreeMem #@VarData #@VarDataSize
  1586 					eif
  1587 25AB 60				rts						; ret
  1588 				.endl
  1589
  1590 25AC			.local	CONSOLE_TRADE					; PROCEDURE
  1591
  1592 					ift l_02D9-*>3
  1593 					jmp l_02D9
  1594 					eif
  1595
  1596 				; IfThenEpilog
  1597 25AC			l_02D9
  1598
  1599 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 162
  1600
  1601 25AC A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  1602 25B1 A9 60 8D 31 02		mva #$60 ATARI.SDLSTL+1
  1603 				; For
  1604
  1605 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 163
  1606
  1607 25B6 A9 01 8D 7C 31		mva #$01 Y
  1608
  1609 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 163
  1610
  1611 				; To
  1612 25BB			l_02EF
  1613
  1614 				; ForToDoCondition
  1615
  1616 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 163
  1617
  1618 25BB AD 7C 31			lda Y
  1619 25BE C9 28			cmp #$28
  1620 25C0 90 05			bcc *+7
  1621 25C2 F0 03			beq *+5
  1622
  1623 				; ForToDoProlog
  1624 25C4 4C E0 25			jmp l_02FD
  1625
  1626 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 165
  1627 25C7 E8				inx
  1628 25C8 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1629 25CC E8				inx
  1630 25CD AD 7C 31 95 98		mva Y :STACKORIGIN,x
  1631 25D2 20 82 22			jsr CRT.GOTOXY
  1632
  1633 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 165
  1634 25D5 20 72 23			jsr CLRLINE
  1635
  1636 				; ForToDoEpilog
  1637 25D8			c_02EF
  1638 25D8 EE 7C 31			inc Y						; inc ptr byte [CounterAddress]
  1639
  1640 25DB F0 03			seq
  1641
  1642 				; WhileDoEpilog
  1643 25DD 4C BB 25			jmp l_02EF
  1644 25E0			l_02FD
  1645 25E0			b_02EF
  1646
  1647 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 167
  1648 25E0 E8				inx
  1649 25E1 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1650 25E5 E8				inx
  1651 25E6 95 98			sta :STACKORIGIN,x
  1652 25E8 20 82 22			jsr CRT.GOTOXY
  1653
  1654 				; optimize FAIL ('SYSTEM.STR', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 168
  1655 25EB E8				inx
  1656 25EC AD 21 2F 95 98		mva PLAYER.UEC :STACKORIGIN,x
  1657 25F1 AD 22 2F 95 A8		mva PLAYER.UEC+1 :STACKORIGIN+STACKWIDTH,x
  1658 25F6 AD 23 2F 95 B8		mva PLAYER.UEC+2 :STACKORIGIN+STACKWIDTH*2,x
  1659 25FB AD 24 2F 95 C8		mva PLAYER.UEC+3 :STACKORIGIN+STACKWIDTH*3,x
  1660 2600 E8				inx
  1661 2601 AD D4 26 95 98		mva UEC :STACKORIGIN,x
  1662 2606 AD D5 26 95 A8		mva UEC+1 :STACKORIGIN+STACKWIDTH,x
  1663 260B 20 44 21			jsr SYSTEM.STR
  1664
  1665 				; Array index LOCATIONS[0..15]
  1666
  1667 				; -----------------------------------------------------------
  1668
  1669 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1670 				; as Value $00000000 (0)
  1671
  1672 260E E8				inx						; add bx, 1
  1673 260F A9 00 95 98			mva #$00 :STACKORIGIN,x
  1674 2613 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1675
  1676 				; -----------------------------------------------------------
  1677
  1678 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1679 				; as Pointer to Array Origin
  1680
  1681
  1682 2617 B4 98			ldy :STACKORIGIN,x				; si
  1683 2619 B9 2C 2F 95 98		mva adr.LOCATIONS,y :STACKORIGIN,x
  1684 261E B9 2D 2F 95 A8		mva adr.LOCATIONS+1,y :STACKORIGIN+STACKWIDTH,x
  1685
  1686 2623 B5 98			lda :STACKORIGIN,x
  1687 2625 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1688 2627 20 EA 2B			jsr @printSTRING
  1689 262A CA				dex						; sub bx, 1
  1690
  1691 					@printSTRING #CODEORIGIN+$0022
  1691 				 LDY> CODEORIGIN+$0022\ LDA< CODEORIGIN+$0022\ JSR @PRINTSTRING
  1691 262B A0 20		 LDY> CODEORIGIN+$0022
  1691 262D A9 22		 LDA< CODEORIGIN+$0022
  1691 262F 20 EA 2B		 JSR @PRINTSTRING
  1692
  1693 				; -----------------------------------------------------------
  1694
  1695 				; Push CARDINAL / INTEGER / REAL / SINGLE
  1696 				; as Pointer
  1697
  1698 2632 E8				inx						; add bx, 1
  1699 2633 AD 21 2F 95 98		mva PLAYER.UEC :STACKORIGIN,x
  1700 2638 AD 22 2F 95 A8		mva PLAYER.UEC+1 :STACKORIGIN+STACKWIDTH,x
  1701 263D AD 23 2F 95 B8		mva PLAYER.UEC+2 :STACKORIGIN+STACKWIDTH*2,x
  1702 2642 AD 24 2F 95 C8		mva PLAYER.UEC+3 :STACKORIGIN+STACKWIDTH*3,x
  1703
  1704 2647 20 3C 2C			jsr @printCARD
  1705 264A CA				dex						; sub bx, 1
  1706
  1707 					@printSTRING #CODEORIGIN+$0030
  1707 				 LDY> CODEORIGIN+$0030\ LDA< CODEORIGIN+$0030\ JSR @PRINTSTRING
  1707 264B A0 20		 LDY> CODEORIGIN+$0030
  1707 264D A9 30		 LDA< CODEORIGIN+$0030
  1707 264F 20 EA 2B		 JSR @PRINTSTRING
  1708 2652 20 DC 2B			@printEOL
  1709
  1710 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 171
  1711 2655 E8				inx
  1712 2656 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1713 265A E8				inx
  1714 265B A9 02 95 98			mva #$02 :STACKORIGIN,x
  1715 265F 20 82 22			jsr CRT.GOTOXY
  1716
  1717 					@printSTRING #CODEORIGIN+$0036
  1717 				 LDY> CODEORIGIN+$0036\ LDA< CODEORIGIN+$0036\ JSR @PRINTSTRING
  1717 2662 A0 20		 LDY> CODEORIGIN+$0036
  1717 2664 A9 36		 LDA< CODEORIGIN+$0036
  1717 2666 20 EA 2B		 JSR @PRINTSTRING
  1718 2669 20 DC 2B			@printEOL
  1719
  1720 					@printSTRING #CODEORIGIN+$0060
  1720 				 LDY> CODEORIGIN+$0060\ LDA< CODEORIGIN+$0060\ JSR @PRINTSTRING
  1720 266C A0 20		 LDY> CODEORIGIN+$0060
  1720 266E A9 60		 LDA< CODEORIGIN+$0060
  1720 2670 20 EA 2B		 JSR @PRINTSTRING
  1721 2673 20 DC 2B			@printEOL
  1722
  1723 					@printSTRING #CODEORIGIN+$008A
  1723 				 LDY> CODEORIGIN+$008A\ LDA< CODEORIGIN+$008A\ JSR @PRINTSTRING
  1723 2676 A0 20		 LDY> CODEORIGIN+$008A
  1723 2678 A9 8A		 LDA< CODEORIGIN+$008A
  1723 267A 20 EA 2B		 JSR @PRINTSTRING
  1724 267D 20 DC 2B			@printEOL
  1725
  1726 					@printSTRING #CODEORIGIN+$00B4
  1726 				 LDY> CODEORIGIN+$00B4\ LDA< CODEORIGIN+$00B4\ JSR @PRINTSTRING
  1726 2680 A0 20		 LDY> CODEORIGIN+$00B4
  1726 2682 A9 B4		 LDA< CODEORIGIN+$00B4
  1726 2684 20 EA 2B		 JSR @PRINTSTRING
  1727 2687 20 DC 2B			@printEOL
  1728 268A 20 DC 2B			@printEOL
  1729
  1730 					@printSTRING #CODEORIGIN+$00B4
  1730 				 LDY> CODEORIGIN+$00B4\ LDA< CODEORIGIN+$00B4\ JSR @PRINTSTRING
  1730 268D A0 20		 LDY> CODEORIGIN+$00B4
  1730 268F A9 B4		 LDA< CODEORIGIN+$00B4
  1730 2691 20 EA 2B		 JSR @PRINTSTRING
  1731 2694 20 DC 2B			@printEOL
  1732
  1733 				; --- RepeatUntilProlog
  1734 2697			l_0335
  1735
  1736 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 182
  1737 2697 20 6E 22			jsr CRT.KEYPRESSED
  1738 					.ifdef IFTMP_24
  1739 					lda :STACKORIGIN,x
  1740 					sta IFTMP_24
  1741 					eif
  1742 269A CA				dex
  1743 269B B5 99			lda :STACKORIGIN+1,x
  1744 269D D0 03			bne *+5
  1745 269F 4C C3 26			jmp l_033F
  1746
  1747 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 183
  1748 26A2 20 D9 21			jsr CRT.READKEY
  1749 26A5 B5 98 8D 17 2F		mva :STACKORIGIN,x KEYVAL
  1750 26AA CA				dex
  1751
  1752 				; -----------------------------------------------------------
  1753
  1754 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1755 				; as Pointer
  1756
  1757 26AB E8				inx						; add bx, 1
  1758 26AC AD 17 2F 95 98		mva KEYVAL :STACKORIGIN,x
  1759
  1760 				; GenerateCaseProlog
  1761 26B1 CA				dex						; sub bx, 1
  1762
  1763 				; GenerateCaseEqualityCheck
  1764 26B2 B5 99			lda :STACKORIGIN+1,x
  1765 26B4 C9 62			cmp #98
  1766 26B6 F0 03			beq @+
  1767
  1768 				; GenerateCaseStatementProlog
  1769 26B8 4C C3 26			jmp l_0355
  1770 26BB			@
  1771
  1772 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 185
  1773
  1774 26BB A9 01 8D 20 2F		mva #$01 CURRENT_MENU
  1775
  1776 				; GenerateCaseStatementEpilog
  1777 26C0 4C C3 26			jmp a_0003
  1778 26C3			l_0355
  1779
  1780 				; GenerateIfElseEpilog
  1781
  1782 				; GenerateCaseEpilog
  1783
  1784 				; GenerateIfElseEpilog
  1785 26C3			a_0003
  1786
  1787 				; IfThenEpilog
  1788 26C3			l_033F
  1789
  1790 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 188
  1791
  1792 26C3 A0 01			ldy #1
  1793 26C5 AD 17 2F			lda KEYVAL
  1794 26C8 C9 62			cmp #$62
  1795 26CA F0 01			beq @+
  1796 26CC 88				dey
  1797 26CD			@
  1798 26CD 98				tya
  1799 26CE D0 03			bne *+5
  1800 26D0			c_0335
  1801 26D0 4C 97 26			jmp l_0335
  1802 26D3			b_0335
  1803
  1804 				; -----------------------------------------------------------
  1805
  1806 = 317C			Y	= DATAORIGIN+$0398
  1807 = 317D			adr.UEC	= DATAORIGIN+$0399
  1808 26D3			.var UEC	= adr.UEC .word
  1809 = 0028			@FORTMP_745	= $0028
  1810
  1811 = 317C			@VarData	= Y
  1812 = 0101			@VarDataSize	= 257
  1813
  1814
  1815 26D3			@exit
  1816 					.ifdef @new
  1817 					@FreeMem #@VarData #@VarDataSize
  1818 					eif
  1819 26D3 60				rts						; ret
  1820 = 26D4 7D 31		UEC
  1820 				.endl
  1821
  1822 26D6			.local	MENU						; PROCEDURE
  1823
  1824 					ift l_0374-*>3
  1825 					jmp l_0374
  1826 					eif
  1827
  1828 				; IfThenEpilog
  1829 26D6			l_0374
  1830
  1831 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 193
  1832
  1833 26D6 A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  1834 26DB A9 5F 8D 31 02		mva #$5F ATARI.SDLSTL+1
  1835
  1836 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 195
  1837 26E0 E8				inx
  1838 26E1 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1839 26E5 E8				inx
  1840 26E6 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1841 26EA 20 82 22			jsr CRT.GOTOXY
  1842
  1843 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 195
  1844 26ED 20 72 23			jsr CLRLINE
  1845
  1846 				; Array index STRINGS[0..0]
  1847
  1848 				; -----------------------------------------------------------
  1849
  1850 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1851 				; as Value $00000006 (6)
  1852
  1853 26F0 E8				inx						; add bx, 1
  1854 26F1 A9 06 95 98			mva #$06 :STACKORIGIN,x
  1855 26F5 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1856
  1857 				; -----------------------------------------------------------
  1858
  1859 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1860 				; as Pointer to Array Origin
  1861
  1862
  1863 26F9 AD 30 2B			lda STRINGS
  1864 26FC 18 75 98			add :STACKORIGIN,x
  1865 26FF 85 90			sta :bp2
  1866 2701 AD 31 2B			lda STRINGS+1
  1867 2704 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1868 2706 85 91			sta :bp2+1
  1869 2708 A0 00			ldy #$00
  1870 270A B1 90			lda (:bp2),y
  1871 270C 95 98			sta :STACKORIGIN,x
  1872 270E C8				iny
  1873 270F B1 90			lda (:bp2),y
  1874 2711 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1875
  1876 2713 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1877
  1878
  1879 2716 B5 98			lda :STACKORIGIN,x
  1880 2718 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1881 271A 20 EA 2B			jsr @printSTRING
  1882 271D CA				dex						; sub bx, 1
  1883 271E 20 DC 2B			@printEOL
  1884
  1885 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 197
  1886 2721 E8				inx
  1887 2722 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1888 2726 E8				inx
  1889 2727 A9 02 95 98			mva #$02 :STACKORIGIN,x
  1890 272B 20 82 22			jsr CRT.GOTOXY
  1891
  1892 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 197
  1893 272E 20 72 23			jsr CLRLINE
  1894
  1895 				; Array index STRINGS[0..0]
  1896
  1897 				; -----------------------------------------------------------
  1898
  1899 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1900 				; as Value $00000008 (8)
  1901
  1902 2731 E8				inx						; add bx, 1
  1903 2732 A9 08 95 98			mva #$08 :STACKORIGIN,x
  1904 2736 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1905
  1906 				; -----------------------------------------------------------
  1907
  1908 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1909 				; as Pointer to Array Origin
  1910
  1911
  1912 273A AD 30 2B			lda STRINGS
  1913 273D 18 75 98			add :STACKORIGIN,x
  1914 2740 85 90			sta :bp2
  1915 2742 AD 31 2B			lda STRINGS+1
  1916 2745 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1917 2747 85 91			sta :bp2+1
  1918 2749 A0 00			ldy #$00
  1919 274B B1 90			lda (:bp2),y
  1920 274D 95 98			sta :STACKORIGIN,x
  1921 274F C8				iny
  1922 2750 B1 90			lda (:bp2),y
  1923 2752 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1924
  1925 2754 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1926
  1927
  1928 2757 B5 98			lda :STACKORIGIN,x
  1929 2759 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1930 275B 20 EA 2B			jsr @printSTRING
  1931 275E CA				dex						; sub bx, 1
  1932 275F 20 DC 2B			@printEOL
  1933
  1934 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 199
  1935 2762 E8				inx
  1936 2763 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1937 2767 E8				inx
  1938 2768 A9 03 95 98			mva #$03 :STACKORIGIN,x
  1939 276C 20 82 22			jsr CRT.GOTOXY
  1940
  1941 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 199
  1942 276F 20 72 23			jsr CLRLINE
  1943
  1944 				; Array index STRINGS[0..0]
  1945
  1946 				; -----------------------------------------------------------
  1947
  1948 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1949 				; as Value $0000000C (12)
  1950
  1951 2772 E8				inx						; add bx, 1
  1952 2773 A9 0C 95 98			mva #$0C :STACKORIGIN,x
  1953 2777 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1954
  1955 				; -----------------------------------------------------------
  1956
  1957 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  1958 				; as Pointer to Array Origin
  1959
  1960
  1961 277B AD 30 2B			lda STRINGS
  1962 277E 18 75 98			add :STACKORIGIN,x
  1963 2781 85 90			sta :bp2
  1964 2783 AD 31 2B			lda STRINGS+1
  1965 2786 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  1966 2788 85 91			sta :bp2+1
  1967 278A A0 00			ldy #$00
  1968 278C B1 90			lda (:bp2),y
  1969 278E 95 98			sta :STACKORIGIN,x
  1970 2790 C8				iny
  1971 2791 B1 90			lda (:bp2),y
  1972 2793 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1973
  1974 2795 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  1975
  1976
  1977 2798 B5 98			lda :STACKORIGIN,x
  1978 279A B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  1979 279C 20 EA 2B			jsr @printSTRING
  1980 279F CA				dex						; sub bx, 1
  1981 27A0 20 DC 2B			@printEOL
  1982
  1983 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 201
  1984 27A3 E8				inx
  1985 27A4 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1986 27A8 E8				inx
  1987 27A9 A9 04 95 98			mva #$04 :STACKORIGIN,x
  1988 27AD 20 82 22			jsr CRT.GOTOXY
  1989
  1990 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 201
  1991 27B0 20 72 23			jsr CLRLINE
  1992
  1993 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 202
  1994 27B3 E8				inx
  1995 27B4 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1996 27B8 E8				inx
  1997 27B9 A9 05 95 98			mva #$05 :STACKORIGIN,x
  1998 27BD 20 82 22			jsr CRT.GOTOXY
  1999
  2000 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 202
  2001 27C0 20 72 23			jsr CLRLINE
  2002
  2003 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 203
  2004 27C3 E8				inx
  2005 27C4 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2006 27C8 E8				inx
  2007 27C9 A9 06 95 98			mva #$06 :STACKORIGIN,x
  2008 27CD 20 82 22			jsr CRT.GOTOXY
  2009
  2010 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 203
  2011 27D0 20 72 23			jsr CLRLINE
  2012
  2013 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 204
  2014 27D3 E8				inx
  2015 27D4 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2016 27D8 E8				inx
  2017 27D9 A9 07 95 98			mva #$07 :STACKORIGIN,x
  2018 27DD 20 82 22			jsr CRT.GOTOXY
  2019
  2020 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 204
  2021 27E0 20 72 23			jsr CLRLINE
  2022
  2023 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 205
  2024
  2025 27E3 A9 00 8D 17 2F		mva #$00 KEYVAL
  2026
  2027 				; --- RepeatUntilProlog
  2028 27E8			l_03B7
  2029
  2030 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 209
  2031 27E8 20 6E 22			jsr CRT.KEYPRESSED
  2032 					.ifdef IFTMP_25
  2033 					lda :STACKORIGIN,x
  2034 					sta IFTMP_25
  2035 					eif
  2036 27EB CA				dex
  2037 27EC B5 99			lda :STACKORIGIN+1,x
  2038 27EE D0 03			bne *+5
  2039 27F0 4C 36 28			jmp l_03C1
  2040
  2041 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 210
  2042 27F3 20 D9 21			jsr CRT.READKEY
  2043 27F6 B5 98 8D 17 2F		mva :STACKORIGIN,x KEYVAL
  2044 27FB CA				dex
  2045
  2046 				; -----------------------------------------------------------
  2047
  2048 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2049 				; as Pointer
  2050
  2051 27FC E8				inx						; add bx, 1
  2052 27FD AD 17 2F 95 98		mva KEYVAL :STACKORIGIN,x
  2053
  2054 				; GenerateCaseProlog
  2055 2802 CA				dex						; sub bx, 1
  2056
  2057 				; GenerateCaseEqualityCheck
  2058 2803 B5 99			lda :STACKORIGIN+1,x
  2059 2805 C9 31			cmp #49
  2060 2807 F0 03			beq @+
  2061
  2062 				; GenerateCaseStatementProlog
  2063 2809 4C 14 28			jmp l_03D7
  2064 280C			@
  2065
  2066 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 212
  2067
  2068 280C A9 02 8D 20 2F		mva #$02 CURRENT_MENU
  2069
  2070 				; GenerateCaseStatementEpilog
  2071 2811 4C 36 28			jmp a_0004
  2072 2814			l_03D7
  2073
  2074 				; GenerateIfElseEpilog
  2075
  2076 				; GenerateCaseEqualityCheck
  2077 2814 B5 99			lda :STACKORIGIN+1,x
  2078 2816 C9 32			cmp #50
  2079 2818 F0 03			beq @+
  2080
  2081 				; GenerateCaseStatementProlog
  2082 281A 4C 25 28			jmp l_03E9
  2083 281D			@
  2084
  2085 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 213
  2086
  2087 281D A9 03 8D 20 2F		mva #$03 CURRENT_MENU
  2088
  2089 				; GenerateCaseStatementEpilog
  2090 2822 4C 36 28			jmp a_0004
  2091 2825			l_03E9
  2092
  2093 				; GenerateIfElseEpilog
  2094
  2095 				; GenerateCaseEqualityCheck
  2096 2825 B5 99			lda :STACKORIGIN+1,x
  2097 2827 C9 62			cmp #98
  2098 2829 F0 03			beq @+
  2099
  2100 				; GenerateCaseStatementProlog
  2101 282B 4C 36 28			jmp l_03FB
  2102 282E			@
  2103
  2104 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 214
  2105
  2106 282E A9 00 8D 20 2F		mva #$00 CURRENT_MENU
  2107
  2108 				; GenerateCaseStatementEpilog
  2109 2833 4C 36 28			jmp a_0004
  2110 2836			l_03FB
  2111
  2112 				; GenerateIfElseEpilog
  2113
  2114 				; GenerateCaseEpilog
  2115
  2116 				; GenerateIfElseEpilog
  2117
  2118 				; GenerateIfElseEpilog
  2119
  2120 				; GenerateIfElseEpilog
  2121 2836			a_0004
  2122
  2123 				; IfThenEpilog
  2124 2836			l_03C1
  2125
  2126 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 217
  2127
  2128 2836 A0 01			ldy #1
  2129 2838 AD 17 2F			lda KEYVAL
  2130 283B C9 62			cmp #$62
  2131 283D F0 01			beq @+
  2132 283F 88				dey
  2133 2840			@
  2134 2840 84 A1			sty :STACKORIGIN+9
  2135 2842 A0 01			ldy #1
  2136 2844 AD 17 2F			lda KEYVAL
  2137 2847 C9 31			cmp #$31
  2138 2849 F0 01			beq @+
  2139 284B 88				dey
  2140 284C			@
  2141 284C 98				tya
  2142 284D 05 A1			ora :STACKORIGIN+9
  2143 284F 85 A1			sta :STACKORIGIN+9
  2144 2851 A0 01			ldy #1
  2145 2853 AD 17 2F			lda KEYVAL
  2146 2856 C9 32			cmp #$32
  2147 2858 F0 01			beq @+
  2148 285A 88				dey
  2149 285B			@
  2150 285B 98				tya
  2151 285C 05 A1			ora :STACKORIGIN+9
  2152 285E D0 03			bne *+5
  2153 2860			c_03B7
  2154 2860 4C E8 27			jmp l_03B7
  2155 2863			b_03B7
  2156
  2157 2863			@exit
  2158 					.ifdef @new
  2159 					@FreeMem #@VarData #@VarDataSize
  2160 					eif
  2161 2863 60				rts						; ret
  2162 				.endl
  2163
  2164 2864			.local	TITLE						; PROCEDURE
  2165
  2166 					ift l_0434-*>3
  2167 					jmp l_0434
  2168 					eif
  2169
  2170 				; IfThenEpilog
  2171 2864			l_0434
  2172
  2173 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 225
  2174
  2175 2864 A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  2176 2869 A9 5F 8D 31 02		mva #$5F ATARI.SDLSTL+1
  2177
  2178 				; Array index STRINGS[0..0]
  2179
  2180 				; -----------------------------------------------------------
  2181
  2182 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2183 				; as Value $00000002 (2)
  2184
  2185 286E E8				inx						; add bx, 1
  2186 286F A9 02 95 98			mva #$02 :STACKORIGIN,x
  2187 2873 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2188
  2189 				; -----------------------------------------------------------
  2190
  2191 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2192 				; as Pointer to Array Origin
  2193
  2194
  2195 2877 AD 30 2B			lda STRINGS
  2196 287A 18 75 98			add :STACKORIGIN,x
  2197 287D 85 90			sta :bp2
  2198 287F AD 31 2B			lda STRINGS+1
  2199 2882 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2200 2884 85 91			sta :bp2+1
  2201 2886 A0 00			ldy #$00
  2202 2888 B1 90			lda (:bp2),y
  2203 288A 95 98			sta :STACKORIGIN,x
  2204 288C C8				iny
  2205 288D B1 90			lda (:bp2),y
  2206 288F 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2207
  2208 2891 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2209
  2210
  2211 					@moveSTRING STR
  2211 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2211 2894 AC 04 2A		 LDY STR+1
  2211 2897 AD 03 2A		 LDA STR
  2211 289A 20 FE 2C		 JSR @MOVESTRING
  2212 289D CA				dex						; sub bx, 1
  2213
  2214 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 233
  2215 289E E8				inx
  2216 289F A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2217 28A3 E8				inx
  2218 28A4 A9 01 95 98			mva #$01 :STACKORIGIN,x
  2219 28A8 20 82 22			jsr CRT.GOTOXY
  2220
  2221 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 233
  2222 28AB 20 72 23			jsr CLRLINE
  2223
  2224 				; -----------------------------------------------------------
  2225
  2226 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2227 				; as Pointer
  2228
  2229 28AE E8				inx						; add bx, 1
  2230 28AF AD 03 2A 95 98		mva STR :STACKORIGIN,x
  2231 28B4 AD 04 2A 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2232
  2233 28B9 B5 98			lda :STACKORIGIN,x
  2234 28BB B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2235 28BD 20 EA 2B			jsr @printSTRING
  2236 28C0 CA				dex						; sub bx, 1
  2237 28C1 20 DC 2B			@printEOL
  2238
  2239 				; Array index STRINGS[0..0]
  2240
  2241 				; -----------------------------------------------------------
  2242
  2243 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2244 				; as Value $00000004 (4)
  2245
  2246 28C4 E8				inx						; add bx, 1
  2247 28C5 A9 04 95 98			mva #$04 :STACKORIGIN,x
  2248 28C9 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2249
  2250 				; -----------------------------------------------------------
  2251
  2252 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2253 				; as Pointer to Array Origin
  2254
  2255
  2256 28CD AD 30 2B			lda STRINGS
  2257 28D0 18 75 98			add :STACKORIGIN,x
  2258 28D3 85 90			sta :bp2
  2259 28D5 AD 31 2B			lda STRINGS+1
  2260 28D8 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2261 28DA 85 91			sta :bp2+1
  2262 28DC A0 00			ldy #$00
  2263 28DE B1 90			lda (:bp2),y
  2264 28E0 95 98			sta :STACKORIGIN,x
  2265 28E2 C8				iny
  2266 28E3 B1 90			lda (:bp2),y
  2267 28E5 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2268
  2269 28E7 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2270
  2271
  2272 					@moveSTRING STR
  2272 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2272 28EA AC 04 2A		 LDY STR+1
  2272 28ED AD 03 2A		 LDA STR
  2272 28F0 20 FE 2C		 JSR @MOVESTRING
  2273 28F3 CA				dex						; sub bx, 1
  2274
  2275 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 236
  2276 28F4 E8				inx
  2277 28F5 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  2278 28F9 E8				inx
  2279 28FA A9 02 95 98			mva #$02 :STACKORIGIN,x
  2280 28FE 20 82 22			jsr CRT.GOTOXY
  2281
  2282 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 236
  2283 2901 20 72 23			jsr CLRLINE
  2284
  2285 				; -----------------------------------------------------------
  2286
  2287 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2288 				; as Pointer
  2289
  2290 2904 E8				inx						; add bx, 1
  2291 2905 AD 03 2A 95 98		mva STR :STACKORIGIN,x
  2292 290A AD 04 2A 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2293
  2294 290F B5 98			lda :STACKORIGIN,x
  2295 2911 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2296 2913 20 EA 2B			jsr @printSTRING
  2297 2916 CA				dex						; sub bx, 1
  2298 2917 20 DC 2B			@printEOL
  2299
  2300 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 238
  2301 291A E8				inx
  2302 291B A9 01 95 98			mva #$01 :STACKORIGIN,x
  2303 291F E8				inx
  2304 2920 A9 03 95 98			mva #$03 :STACKORIGIN,x
  2305 2924 20 82 22			jsr CRT.GOTOXY
  2306
  2307 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 238
  2308 2927 20 72 23			jsr CLRLINE
  2309
  2310 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 239
  2311 292A E8				inx
  2312 292B A9 01 95 98			mva #$01 :STACKORIGIN,x
  2313 292F E8				inx
  2314 2930 A9 04 95 98			mva #$04 :STACKORIGIN,x
  2315 2934 20 82 22			jsr CRT.GOTOXY
  2316
  2317 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 239
  2318 2937 20 72 23			jsr CLRLINE
  2319
  2320 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 240
  2321 293A E8				inx
  2322 293B A9 01 95 98			mva #$01 :STACKORIGIN,x
  2323 293F E8				inx
  2324 2940 A9 05 95 98			mva #$05 :STACKORIGIN,x
  2325 2944 20 82 22			jsr CRT.GOTOXY
  2326
  2327 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 240
  2328 2947 20 72 23			jsr CLRLINE
  2329
  2330 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 241
  2331 294A E8				inx
  2332 294B A9 01 95 98			mva #$01 :STACKORIGIN,x
  2333 294F E8				inx
  2334 2950 A9 06 95 98			mva #$06 :STACKORIGIN,x
  2335 2954 20 82 22			jsr CRT.GOTOXY
  2336
  2337 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 241
  2338 2957 20 72 23			jsr CLRLINE
  2339
  2340 				; Array index STRINGS[0..0]
  2341
  2342 				; -----------------------------------------------------------
  2343
  2344 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2345 				; as Value $00000000 (0)
  2346
  2347 295A E8				inx						; add bx, 1
  2348 295B A9 00 95 98			mva #$00 :STACKORIGIN,x
  2349 295F A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2350
  2351 				; -----------------------------------------------------------
  2352
  2353 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2354 				; as Pointer to Array Origin
  2355
  2356
  2357 2963 AD 30 2B			lda STRINGS
  2358 2966 18 75 98			add :STACKORIGIN,x
  2359 2969 85 90			sta :bp2
  2360 296B AD 31 2B			lda STRINGS+1
  2361 296E 75 A8			adc :STACKORIGIN+STACKWIDTH,x
  2362 2970 85 91			sta :bp2+1
  2363 2972 A0 00			ldy #$00
  2364 2974 B1 90			lda (:bp2),y
  2365 2976 95 98			sta :STACKORIGIN,x
  2366 2978 C8				iny
  2367 2979 B1 90			lda (:bp2),y
  2368 297B 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  2369
  2370 297D 20 AC 22			jsr B_UTILS.NULLTERMTOSTRING			; call Entry
  2371
  2372
  2373 					@moveSTRING STR
  2373 				 LDY STR+1\ LDA STR\ JSR @MOVESTRING
  2373 2980 AC 04 2A		 LDY STR+1
  2373 2983 AD 03 2A		 LDA STR
  2373 2986 20 FE 2C		 JSR @MOVESTRING
  2374 2989 CA				dex						; sub bx, 1
  2375
  2376 				; optimize FAIL ('CRT.GOTOXY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 243
  2377 298A E8				inx
  2378 298B A9 15 95 98			mva #$15 :STACKORIGIN,x
  2379 298F E8				inx
  2380 2990 A9 07 95 98			mva #$07 :STACKORIGIN,x
  2381 2994 20 82 22			jsr CRT.GOTOXY
  2382
  2383 				; optimize FAIL ('CLRLINE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 243
  2384 2997 20 72 23			jsr CLRLINE
  2385
  2386 				; -----------------------------------------------------------
  2387
  2388 				; Push WORD / SMALLINT / SHORTREAL / POINTER
  2389 				; as Pointer
  2390
  2391 299A E8				inx						; add bx, 1
  2392 299B AD 03 2A 95 98		mva STR :STACKORIGIN,x
  2393 29A0 AD 04 2A 95 A8		mva STR+1 :STACKORIGIN+STACKWIDTH,x
  2394
  2395 29A5 B5 98			lda :STACKORIGIN,x
  2396 29A7 B4 A8			ldy :STACKORIGIN+STACKWIDTH,x
  2397 29A9 20 EA 2B			jsr @printSTRING
  2398 29AC CA				dex						; sub bx, 1
  2399 29AD 20 DC 2B			@printEOL
  2400
  2401 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 248
  2402
  2403 29B0 A9 00 8D 17 2F		mva #$00 KEYVAL
  2404
  2405 				; --- RepeatUntilProlog
  2406 29B5			l_047D
  2407
  2408 				; optimize FAIL ('CRT.KEYPRESSED', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 252
  2409 29B5 20 6E 22			jsr CRT.KEYPRESSED
  2410 					.ifdef IFTMP_26
  2411 					lda :STACKORIGIN,x
  2412 					sta IFTMP_26
  2413 					eif
  2414 29B8 CA				dex
  2415 29B9 B5 99			lda :STACKORIGIN+1,x
  2416 29BB D0 03			bne *+5
  2417 29BD 4C E4 29			jmp l_0487
  2418
  2419 				; optimize FAIL ('CRT.READKEY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 253
  2420 29C0 20 D9 21			jsr CRT.READKEY
  2421 29C3 B5 98 8D 17 2F		mva :STACKORIGIN,x KEYVAL
  2422 29C8 CA				dex
  2423
  2424 				; -----------------------------------------------------------
  2425
  2426 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2427 				; as Pointer
  2428
  2429 29C9 E8				inx						; add bx, 1
  2430 29CA AD 17 2F 95 98		mva KEYVAL :STACKORIGIN,x
  2431
  2432 				; GenerateCaseProlog
  2433 29CF CA				dex						; sub bx, 1
  2434
  2435 				; GenerateCaseEqualityCheck
  2436 29D0 B5 99			lda :STACKORIGIN+1,x
  2437 29D2 C9 6E			cmp #110
  2438 29D4 F0 03			beq @+
  2439
  2440 				; GenerateCaseStatementProlog
  2441 29D6 4C E4 29			jmp l_049D
  2442 29D9			@
  2443
  2444 				; optimize FAIL ('START', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 256
  2445 29D9 20 82 24			jsr START
  2446
  2447 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 257
  2448
  2449 29DC A9 01 8D 20 2F		mva #$01 CURRENT_MENU
  2450
  2451 				; GenerateCaseStatementEpilog
  2452 29E1 4C E4 29			jmp a_0005
  2453 29E4			l_049D
  2454
  2455 				; GenerateIfElseEpilog
  2456
  2457 				; GenerateCaseEpilog
  2458
  2459 				; GenerateIfElseEpilog
  2460 29E4			a_0005
  2461
  2462 				; IfThenEpilog
  2463 29E4			l_0487
  2464
  2465 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 275
  2466
  2467 29E4 A0 01			ldy #1
  2468 29E6 AD 17 2F			lda KEYVAL
  2469 29E9 C9 71			cmp #$71
  2470 29EB F0 01			beq @+
  2471 29ED 88				dey
  2472 29EE			@
  2473 29EE 84 A1			sty :STACKORIGIN+9
  2474 29F0 A0 01			ldy #1
  2475 29F2 AD 17 2F			lda KEYVAL
  2476 29F5 C9 6E			cmp #$6E
  2477 29F7 F0 01			beq @+
  2478 29F9 88				dey
  2479 29FA			@
  2480 29FA 98				tya
  2481 29FB 05 A1			ora :STACKORIGIN+9
  2482 29FD D0 03			bne *+5
  2483 29FF			c_047D
  2484 29FF 4C B5 29			jmp l_047D
  2485 2A02			b_047D
  2486
  2487 				; -----------------------------------------------------------
  2488
  2489 = 327D			adr.STR	= DATAORIGIN+$0499
  2490 2A02			.var STR	= adr.STR .word
  2491
  2492 = 2A03			@VarData	= STR
  2493 = 0100			@VarDataSize	= 256
  2494
  2495
  2496 2A02			@exit
  2497 					.ifdef @new
  2498 					@FreeMem #@VarData #@VarDataSize
  2499 					eif
  2500 2A02 60				rts						; ret
  2501 = 2A03 7D 32		STR
  2501 				.endl
  2502
  2503 2A05			.local	FADE						; PROCEDURE
  2504
  2505 					ift l_04C9-*>3
  2506 					jmp l_04C9
  2507 					eif
  2508
  2509 				; IfThenEpilog
  2510 2A05			l_04C9
  2511 				; For
  2512
  2513 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 288
  2514
  2515 2A05 A9 00 8D 84 33		mva #$00 I
  2516
  2517 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 288
  2518
  2519 				; To
  2520 2A0A			l_04D8
  2521
  2522 				; ForToDoCondition
  2523
  2524 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 288
  2525
  2526 2A0A AD 84 33			lda I
  2527 2A0D C9 06			cmp #$06
  2528 2A0F 90 05			bcc *+7
  2529 2A11 F0 03			beq *+5
  2530
  2531 				; ForToDoProlog
  2532 2A13 4C 36 2A			jmp l_04E6
  2533
  2534 				; optimize FAIL ('CRT.TEXTBACKGROUND', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 290
  2535 2A16 E8				inx
  2536 2A17 AC 84 33			ldy I 
  2537 2A1A B9 7D 33 95 98		mva adr.FADECOLORS,y :STACKORIGIN,x
  2538 2A1F 20 EA 21			jsr CRT.TEXTBACKGROUND
  2539
  2540 				; optimize FAIL ('CRT.DELAY', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 291
  2541 2A22 E8				inx
  2542 2A23 A9 23 95 98			mva #$23 :STACKORIGIN,x
  2543 2A27 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2544 2A2B 20 0A 22			jsr CRT.DELAY
  2545
  2546 				; ForToDoEpilog
  2547 2A2E			c_04D8
  2548 2A2E EE 84 33			inc I						; inc ptr byte [CounterAddress]
  2549
  2550 2A31 F0 03			seq
  2551
  2552 				; WhileDoEpilog
  2553 2A33 4C 0A 2A			jmp l_04D8
  2554 2A36			l_04E6
  2555 2A36			b_04D8
  2556
  2557 				; optimize FAIL ('CRT.TEXTCOLOR', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 294
  2558 2A36 E8				inx
  2559 2A37 A9 06 95 98			mva #$06 :STACKORIGIN,x
  2560 2A3B 20 FD 21			jsr CRT.TEXTCOLOR
  2561
  2562 				; -----------------------------------------------------------
  2563
  2564 = 337D			adr.FADECOLORS	= DATAORIGIN+$0599
  2565 2A3E			.var FADECOLORS	= adr.FADECOLORS .word
  2566 = 3384			I	= DATAORIGIN+$05A0
  2567 = 3385			@FORTMP_1234	= DATAORIGIN+$05A1
  2568
  2569 = 2A3F			@VarData	= FADECOLORS
  2570 = 0009			@VarDataSize	= 9
  2571
  2572
  2573 2A3E			@exit
  2574 					.ifdef @new
  2575 					@FreeMem #@VarData #@VarDataSize
  2576 					eif
  2577 2A3E 60				rts						; ret
  2578 = 2A3F 7D 33		FADECOLORS
  2578 				.endl
  2579
  2580 				; IfThenEpilog
  2581 2A41			l_00E5
  2582
  2583 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 308
  2584
  2585 2A41 A9 00 85 58			mva #$00 ATARI.SAVMSC
  2586 2A45 A9 61 85 59			mva #$61 ATARI.SAVMSC+1
  2587
  2588 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 310
  2589
  2590 2A49 A9 00 85 52			mva #$00 ATARI.LMARGIN
  2591
  2592 				; optimize FAIL ('FADE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 311
  2593 2A4D 20 05 2A			jsr FADE
  2594
  2595 				; optimize FAIL ('CRT.CURSOROFF', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 312
  2596 2A50 20 A9 21			jsr CRT.CURSOROFF
  2597
  2598 2A53 AD 24 02			lda VVBLKD
  2599 2A56 8D 1C 2F			sta OLDVBL
  2600 2A59 AD 25 02			lda VVBLKD+1
  2601 2A5C 8D 1D 2F			sta OLDVBL+1
  2602
  2603 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 322
  2604
  2605 2A5F A9 64			lda <VBL
  2606 2A61 A0 05			ldy #5
  2607 2A63 8D 0A D4			sta wsync
  2608 2A66 88				dey
  2609 2A67 D0 FD			rne
  2610 2A69 8D 24 02			sta VVBLKD
  2611 2A6C A9 23			lda >VBL
  2612 2A6E 8D 25 02			sta VVBLKD+1
  2613
  2614 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 323
  2615
  2616 2A71 A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
  2617
  2618 2A76 AD 00 02			lda VDSLST
  2619 2A79 8D 1E 2F			sta OLDDLI
  2620 2A7C AD 01 02			lda VDSLST+1
  2621 2A7F 8D 1F 2F			sta OLDDLI+1
  2622
  2623 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 327
  2624
  2625 2A82 A9 03 8D 00 02		mva <DLI1 VDSLST
  2626 2A87 A9 23 8D 01 02		mva >DLI1 VDSLST+1
  2627
  2628 				; optimize FAIL ('LOADLOCATIONS', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 333
  2629 2A8C 20 1D 24			jsr LOADLOCATIONS
  2630
  2631 				; optimize FAIL ('LOADITEMS', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 334
  2632 2A8F 20 B8 23			jsr LOADITEMS
  2633
  2634 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 336
  2635
  2636 2A92 A9 00 8D 20 2F		mva #$00 CURRENT_MENU
  2637
  2638 				; --- RepeatUntilProlog
  2639 2A97			l_0518
  2640
  2641 				; -----------------------------------------------------------
  2642
  2643 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  2644 				; as Pointer
  2645
  2646 2A97 E8				inx						; add bx, 1
  2647 2A98 AD 20 2F 95 98		mva CURRENT_MENU :STACKORIGIN,x
  2648
  2649 				; GenerateCaseProlog
  2650 2A9D CA				dex						; sub bx, 1
  2651
  2652 				; GenerateCaseEqualityCheck
  2653 2A9E B5 99			lda :STACKORIGIN+1,x
  2654 2AA0 F0 03			beq @+
  2655
  2656 				; GenerateCaseStatementProlog
  2657 2AA2 4C AB 2A			jmp l_0526
  2658 2AA5			@
  2659
  2660 				; optimize FAIL ('TITLE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 340
  2661 2AA5 20 64 28			jsr TITLE
  2662
  2663 				; GenerateCaseStatementEpilog
  2664 2AA8 4C D8 2A			jmp a_0006
  2665 2AAB			l_0526
  2666
  2667 				; GenerateIfElseEpilog
  2668
  2669 				; GenerateCaseEqualityCheck
  2670 2AAB B5 99			lda :STACKORIGIN+1,x
  2671 2AAD C9 01			cmp #1
  2672 2AAF F0 03			beq @+
  2673
  2674 				; GenerateCaseStatementProlog
  2675 2AB1 4C BA 2A			jmp l_0532
  2676 2AB4			@
  2677
  2678 				; optimize FAIL ('MENU', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 342
  2679 2AB4 20 D6 26			jsr MENU
  2680
  2681 				; GenerateCaseStatementEpilog
  2682 2AB7 4C D8 2A			jmp a_0006
  2683 2ABA			l_0532
  2684
  2685 				; GenerateIfElseEpilog
  2686
  2687 				; GenerateCaseEqualityCheck
  2688 2ABA B5 99			lda :STACKORIGIN+1,x
  2689 2ABC C9 02			cmp #2
  2690 2ABE F0 03			beq @+
  2691
  2692 				; GenerateCaseStatementProlog
  2693 2AC0 4C C9 2A			jmp l_053E
  2694 2AC3			@
  2695
  2696 				; optimize FAIL ('CONSOLE_NAVIGATION', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 343
  2697 2AC3 20 9A 24			jsr CONSOLE_NAVIGATION
  2698
  2699 				; GenerateCaseStatementEpilog
  2700 2AC6 4C D8 2A			jmp a_0006
  2701 2AC9			l_053E
  2702
  2703 				; GenerateIfElseEpilog
  2704
  2705 				; GenerateCaseEqualityCheck
  2706 2AC9 B5 99			lda :STACKORIGIN+1,x
  2707 2ACB C9 03			cmp #3
  2708 2ACD F0 03			beq @+
  2709
  2710 				; GenerateCaseStatementProlog
  2711 2ACF 4C D8 2A			jmp l_054A
  2712 2AD2			@
  2713
  2714 				; optimize FAIL ('CONSOLE_TRADE', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 344
  2715 2AD2 20 AC 25			jsr CONSOLE_TRADE
  2716
  2717 				; GenerateCaseStatementEpilog
  2718 2AD5 4C D8 2A			jmp a_0006
  2719 2AD8			l_054A
  2720
  2721 				; GenerateIfElseEpilog
  2722
  2723 				; GenerateCaseEpilog
  2724
  2725 				; GenerateIfElseEpilog
  2726
  2727 				; GenerateIfElseEpilog
  2728
  2729 				; GenerateIfElseEpilog
  2730
  2731 				; GenerateIfElseEpilog
  2732 2AD8			a_0006
  2733
  2734 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 347
  2735
  2736 2AD8 A0 01			ldy #1
  2737 2ADA AD 17 2F			lda KEYVAL
  2738 2ADD C9 71			cmp #$71
  2739 2ADF F0 01			beq @+
  2740 2AE1 88				dey
  2741 2AE2			@
  2742 					.ifdef IFTMP_27
  2743 					sty IFTMP_27
  2744 					eif
  2745 2AE2 98				tya
  2746 2AE3 D0 03			bne *+5
  2747 2AE5 4C EB 2A			jmp l_0565
  2748
  2749 2AE8 4C F2 2A			jmp b_0518					; break
  2750
  2751 				; IfThenEpilog
  2752 2AEB			l_0565
  2753
  2754 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 348
  2755
  2756 2AEB A9 00			lda #$00
  2757 2AED D0 03			bne *+5
  2758 2AEF			c_0518
  2759 2AEF 4C 97 2A			jmp l_0518
  2760 2AF2			b_0518
  2761
  2762 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 351
  2763
  2764 2AF2 AD 1C 2F			lda OLDVBL
  2765 2AF5 A0 05			ldy #5
  2766 2AF7 8D 0A D4			sta wsync
  2767 2AFA 88				dey
  2768 2AFB D0 FD			rne
  2769 2AFD 8D 24 02			sta VVBLKD
  2770 2B00 AD 1D 2F			lda OLDVBL+1
  2771 2B03 8D 25 02			sta VVBLKD+1
  2772
  2773 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 352
  2774
  2775 2B06 AD 1E 2F 8D 00 02		mva OLDDLI VDSLST
  2776 2B0C AD 1F 2F 8D 01 02		mva OLDDLI+1 VDSLST+1
  2777
  2778 				; optimize OK (C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 353
  2779
  2780 2B12 A9 40 8D 0E D4		mva #$40 ATARI.NMIEN
  2781
  2782 				; optimize FAIL ('CRT.CURSORON', C:\Users\MADRAFi\Dropbox\Atari\DEV\StarVagrant\starvagrant.pas), line = 356
  2783 2B17 20 C1 21			jsr CRT.CURSORON
  2784
  2785 				; -----------------------------------------------------------
  2786
  2787 = 5B00			FREE_BOTTOM	= $5B00
  2788 = 5B00			STRINGS_ADDRESS	= $5B00
  2789 = 5C00			LOCATIONS_ADDRESS	= $5C00
  2790 = 5E00			ITEMS_ADDRESS	= $5E00
  2791 = 5F00			DISPLAY_LIST_ADDRESS_MENU	= $5F00
  2792 = 6000			DISPLAY_LIST_ADDRESS_CONSOLE	= $6000
  2793 = 6100			VIDEO_RAM_ADDRESS	= $6100
  2794 = 7000			GFX_ADDRESS	= $7000
  2795 = 8A00			RMT_PLAYER_ADDRESS	= $8A00
  2796 = 9200			RMT_MODULE_ADDRESS	= $9200
  2797 = 000F			NUMBEROFLOCATIONS	= $000F
  2798 = 0016			NUMBEROFITEMS	= $0016
  2799 = 0028			TXTCOL	= $0028
  2800 = 0031			KEY_OPTION1	= $0031
  2801 = 0032			KEY_OPTION2	= $0032
  2802 = 0033			KEY_OPTION3	= $0033
  2803 = 0034			KEY_OPTION4	= $0034
  2804 = 0062			KEY_BACK	= $0062
  2805 = 0071			KEY_QUIT	= $0071
  2806 = 006E			KEY_NEW	= $006E
  2807 = 0000			MENU_TITLE	= $0000
  2808 = 0001			MENU_MAIN	= $0001
  2809 = 0002			MENU_NAV	= $0002
  2810 = 0003			MENU_TRADE	= $0003
  2811 = 0004			MENU_MAINT	= $0004
  2812 = 2F17			KEYVAL	= DATAORIGIN+$0133
  2813 = 2F18			adr.MSX	= DATAORIGIN+$0134
  2814 2B1A			.var MSX	= adr.MSX .word
  2815 = 2F18			MSX.PLAYER	= DATAORIGIN+$0134
  2816 = 2F1A			MSX.MODUL	= DATAORIGIN+$0136
  2817 = 2F1C			OLDVBL	= DATAORIGIN+$0138
  2818 = 2F1E			OLDDLI	= DATAORIGIN+$013A
  2819 = 5B00			adr.STRINGS	= $5B00
  2820 2B1A			.var STRINGS	= adr.STRINGS .word
  2821 = 2F20			CURRENT_MENU	= DATAORIGIN+$013C
  2822 = 2F21			adr.PLAYER	= DATAORIGIN+$013D
  2823 2B1A			.var PLAYER	= adr.PLAYER .word
  2824 = 2F21			PLAYER.UEC	= DATAORIGIN+$013D
  2825 = 2F25			PLAYER.LOC	= DATAORIGIN+$0141
  2826 = 2F26			adr.PLAYER.SHIP	= DATAORIGIN+$0142
  2827 2B1A			.var PLAYER.SHIP	= adr.PLAYER.SHIP .word
  2828 = 2F26			PLAYER.SHIP.SNAME	= DATAORIGIN+$0142
  2829 = 2F28			PLAYER.SHIP.SCU_MAX	= DATAORIGIN+$0144
  2830 = 2F2A			PLAYER.SHIP.SCU	= DATAORIGIN+$0146
  2831 = 2F2C			adr.LOCATIONS	= DATAORIGIN+$0148
  2832 2B1A			.var LOCATIONS	= adr.LOCATIONS .word
  2833 = 2F4C			adr.ITEMS	= DATAORIGIN+$0168
  2834 2B1A			.var ITEMS	= adr.ITEMS .word
  2835
  2836 2B1A			@exit
  2837
  2838 2B1A A2 00		@halt	ldx #0
  2839 2B1C 9A				txs
  2840
  2841 2B1D 60				rts
  2842
  2843 2B1E 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  2844
  2845 2B2E			.local	@DEFINES
  2846 2B2E			ATARI
  2847 				.endl
  2848
  2849 = 2B2E 18 2F		MSX
  2849 = 2B30 00 5B		STRINGS
  2849 = 2B32 21 2F		PLAYER
  2849 = 2B34 26 2F		PLAYER.SHIP
  2849 = 2B36 2C 2F		LOCATIONS
  2849 = 2B38 4C 2F		ITEMS
  2849 				.endl
  2850
  2851 				; -----------------------------------------------------------
  2852
  2853 2B3A				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   224 					opt l+
   225
   226 				/* ----------------------------------------------------------------------- */
   227
   228
   229 2B3A			.proc	hiBYTE
   230 					lda :STACKORIGIN,x
   231 2B3A				:4 lsr @
   232 					sta :STACKORIGIN,x
   233 					rts
   234 				.endp
   235
   236 2B3A			.proc	hiWORD
   237 					lda :STACKORIGIN+STACKWIDTH,x
   238 					sta :STACKORIGIN,x
   239 					rts
   240 				.endp
   241
   242 2B3A			.proc	hiCARD
   243 					lda :STACKORIGIN+STACKWIDTH*3,x
   244 					sta :STACKORIGIN+STACKWIDTH,x
   245
   246 					lda :STACKORIGIN+STACKWIDTH*2,x
   247 					sta :STACKORIGIN,x
   248 					rts
   249 				.endp
   250
   251
   252 2B3A			.proc	movaBX_EAX		; mov [BX], EAX
   253 2B3A A5 82 95 97 A5 83 + 	:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   254 2B4A 60				rts
   255 				.endp
   256
   257 				/*
   258 				.proc	@pushBYTE
   259 					adc :STACKORIGIN+STACKWIDTH,x
   260 					sta bp+1
   261
   262 					mva (bp),y :STACKORIGIN,x
   263
   264 				;	lda #$00
   265 				;	sta :STACKORIGIN+STACKWIDTH,x
   266 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   267 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   268
   269 					rts
   270 				.endp
   271
   272
   273 				.proc	@pullWORD (.word ya) .reg
   274 					add :STACKORIGIN-1,x
   275 					sta bp2
   276 					tya
   277 					adc :STACKORIGIN-1+STACKWIDTH,x
   278 					sta bp2+1
   279
   280 					ldy #$00
   281
   282 					mva :STACKORIGIN,x (bp2),y
   283 					iny
   284 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   285
   286 					rts
   287 				.endp
   288
   289
   290 				.proc	@pullCARD (.word ya) .reg
   291 					add :STACKORIGIN-1,x
   292 					sta bp2
   293 					tya
   294 					adc :STACKORIGIN-1+STACKWIDTH,x
   295 					sta bp2+1
   296
   297 					ldy #$00
   298
   299 					mva :STACKORIGIN,x (bp2),y
   300 					iny
   301 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   302 					iny
   303 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   304 					iny
   305 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   306
   307 					rts
   308 				.endp
   309
   310
   311 				.proc	@pushWORD (.word ya) .reg
   312 					add :STACKORIGIN,x
   313 					sta bp2
   314 					tya
   315 					adc :STACKORIGIN+STACKWIDTH,x
   316 					sta bp2+1
   317
   318 					ldy #$00
   319
   320 					mva (bp2),y :STACKORIGIN,x
   321 					iny
   322 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   323
   324 					rts
   325 				.endp
   326
   327
   328 				.proc	@pushCARD (.word ya) .reg
   329 					add :STACKORIGIN,x
   330 					sta bp2
   331 					tya
   332 					adc :STACKORIGIN+STACKWIDTH,x
   333 					sta bp2+1
   334
   335 					ldy #$00
   336
   337 					mva (bp2),y :STACKORIGIN,x
   338 					iny
   339 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   340 					iny
   341 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   342 					iny
   343 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   344
   345 					rts
   346 				.endp
   347 				*/
   347
   348
   349 2B4B			.proc	shlEAX_CL
   350
   351 				;SHORT	jsr @expandToCARD1.SHORT
   352 				;	jmp CARD
   353
   354 				;SMALL	jsr @expandToCARD1.SMALL
   355 				;	jmp CARD
   356
   357 2B4B			BYTE	lda #0
   358 					sta :STACKORIGIN-1+STACKWIDTH,x
   359
   360 2B4B			WORD	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   362 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   363
   364 2B4B			CARD	clc
   365 					ldy :STACKORIGIN,x	; cl
   366 					beq stop
   367 2B4B			@	asl :STACKORIGIN-1,x	; eax
   368 					rol :STACKORIGIN-1+STACKWIDTH,x
   369 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   370 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   371 					dey
   372 					bne @-
   373
   374 2B4B			stop	rts
   375 				.endp
   376
   377
   378 2B4B			.proc	shrAL_CL
   379
   380 				;SHORT	jsr @expandToCARD1.SHORT
   381 				;	jmp shrEAX_CL
   382
   383 2B4B			BYTE	ldy :STACKORIGIN,x	; cl
   384 					beq stop
   385 2B4B			@	lsr :STACKORIGIN-1,x
   386 					dey
   387 					bne @-
   388
   389 2B4B			stop	lda #0
   390 					sta :STACKORIGIN-1+STACKWIDTH,x
   391 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   392 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   393
   394 					rts
   395 				.endp
   396
   397 2B4B			.proc	shrAX_CL
   398
   399 				;SMALL	jsr @expandToCARD1.SMALL
   400 				;	jmp shrEAX_CL
   401
   402 2B4B			WORD	ldy :STACKORIGIN,x	; cl
   403 					beq stop
   404 2B4B			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   405 					ror :STACKORIGIN-1,x
   406 					dey
   407 					bne @-
   408
   409 2B4B			stop	lda #0
   410 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   411 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   412
   413 					rts
   414 				.endp
   415
   416 2B4B			.proc	shrEAX_CL
   417
   418 					ldy :STACKORIGIN,x	; cl
   419 					beq stop
   420 2B4B			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   421 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   422 					ror :STACKORIGIN-1+STACKWIDTH,x
   423 					ror :STACKORIGIN-1,x
   424 					dey
   425 					bne @-
   426
   427 2B4B			stop	rts
   428 				.endp
   429
   430 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   431 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   432 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   433
   434 2B4B			.proc	addAL_CL
   435
   436 					ldy #0
   437
   438 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   439 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   440
   441 					lda :STACKORIGIN-1,x
   442 					add :STACKORIGIN,x
   443 					sta :STACKORIGIN-1,x
   444 					scc
   445 					iny
   446
   447 					sty :STACKORIGIN-1+STACKWIDTH,x
   448
   449 					rts
   450 				.endp
   451
   452 2B4B			.proc	addAX_CX
   453
   454 2B4B A0 00			ldy #0
   455
   456 2B4D 94 C7			sty :STACKORIGIN-1+STACKWIDTH*3,x
   457
   458 2B4F B5 97			lda :STACKORIGIN-1,x
   459 2B51 18 75 98			add :STACKORIGIN,x
   460 2B54 95 97			sta :STACKORIGIN-1,x
   461
   462 2B56 B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   463 2B58 75 A8			adc :STACKORIGIN+STACKWIDTH,x
   464 2B5A 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   465 2B5C 90 01			scc
   466 2B5E C8				iny
   467
   468 2B5F 94 B7			sty :STACKORIGIN-1+STACKWIDTH*2,x
   469
   470 2B61 60				rts
   471 				.endp
   472
   473
   474 2B62			.proc	addEAX_ECX
   475 				/*
   476 				SHORT	jsr @expandToCARD.SHORT
   477 					jsr @expandToCARD1.SHORT
   478 					jmp CARD
   479
   480 				SMALL	jsr @expandToCARD.SMALL
   481 					jsr @expandToCARD1.SMALL
   482 				*/
   482
   483 2B62			CARD	lda :STACKORIGIN-1,x
   484 					add :STACKORIGIN,x
   485 					sta :STACKORIGIN-1,x
   486
   487 					lda :STACKORIGIN-1+STACKWIDTH,x
   488 					adc :STACKORIGIN+STACKWIDTH,x
   489 					sta :STACKORIGIN-1+STACKWIDTH,x
   490
   491 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   492 					adc :STACKORIGIN+STACKWIDTH*2,x
   493 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   494
   495 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   496 					adc :STACKORIGIN+STACKWIDTH*3,x
   497 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   498
   499 					rts
   500 				.endp
   501
   502
   503 2B62			.proc	subAL_CL
   504
   505 					ldy #0
   506
   507 					lda :STACKORIGIN-1,x
   508 					sub :STACKORIGIN,x
   509 					sta :STACKORIGIN-1,x
   510 					scs
   511 					dey
   512
   513 					sty :STACKORIGIN-1+STACKWIDTH,x
   514 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   515 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   516
   517 					rts
   518 				.endp
   519
   520 2B62			.proc	subAX_CX
   521
   522 					ldy #0
   523
   524 					lda :STACKORIGIN-1,x		; ax
   525 					sub :STACKORIGIN,x		; cx
   526 					sta :STACKORIGIN-1,x
   527
   528 					lda :STACKORIGIN-1+STACKWIDTH,x
   529 					sbc :STACKORIGIN+STACKWIDTH,x
   530 					sta :STACKORIGIN-1+STACKWIDTH,x
   531 					scs
   532 					dey
   533
   534 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   535 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   536
   537 					rts
   538 				.endp
   539
   540 2B62			.proc	subEAX_ECX
   541
   542 2B62 B5 97			lda :STACKORIGIN-1,x
   543 2B64 38 F5 98			sub :STACKORIGIN,x
   544 2B67 95 97			sta :STACKORIGIN-1,x
   545
   546 2B69 B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   547 2B6B F5 A8			sbc :STACKORIGIN+STACKWIDTH,x
   548 2B6D 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   549
   550 2B6F B5 B7			lda :STACKORIGIN-1+STACKWIDTH*2,x
   551 2B71 F5 B8			sbc :STACKORIGIN+STACKWIDTH*2,x
   552 2B73 95 B7			sta :STACKORIGIN-1+STACKWIDTH*2,x
   553
   554 2B75 B5 C7			lda :STACKORIGIN-1+STACKWIDTH*3,x
   555 2B77 F5 C8			sbc :STACKORIGIN+STACKWIDTH*3,x
   556 2B79 95 C7			sta :STACKORIGIN-1+STACKWIDTH*3,x
   557
   558 2B7B 60				rts
   559 				.endp
   560
   561
   562 2B7C			.proc	@expandSHORT2SMALL
   563 					ldy #$00
   564 					lda :STACKORIGIN,x
   565 					spl
   566 					dey
   567 					sty :STACKORIGIN+STACKWIDTH,x
   568
   569 					rts
   570 				.endp
   571
   572 2B7C			.proc	@expandSHORT2SMALL1
   573 					ldy #$00
   574 					lda :STACKORIGIN-1,x
   575 					spl
   576 					dey
   577 					sty :STACKORIGIN-1+STACKWIDTH,x
   578
   579 					rts
   580 				.endp
   581
   582
   583 2B7C			.proc	@expandToCARD
   584
   585 2B7C B5 A8		SMALL	lda :STACKORIGIN+STACKWIDTH,x
   586 2B7E 10 04			bpl WORD
   587
   588 2B80 A9 FF			lda #$ff
   589 2B82 D0 10			bne _wo
   590
   591 2B84 A9 00		WORD	lda #$00
   592 2B86 F0 0C			beq _wo
   593
   594 2B88 B5 98		SHORT	lda :STACKORIGIN,x
   595 2B8A 10 04			bpl BYTE
   596
   597 2B8C A9 FF			lda #$ff
   598 2B8E D0 02			bne _by
   599
   600 2B90 A9 00		BYTE	lda #$00
   601
   602 2B92 95 A8		_by	sta :STACKORIGIN+STACKWIDTH,x
   603 2B94 95 B8		_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   604 2B96 95 C8		_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   605 2B98 60				rts
   606 				.endp
   607
   608
   609 2B99			.proc	@expandToCARD1
   610
   611 2B99			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   612 					bpl WORD
   613
   614 					lda #$ff
   615 					bne _wo
   616
   617 2B99			WORD	lda #$00
   618 					beq _wo
   619
   620 2B99			SHORT	lda :STACKORIGIN-1,x
   621 					bpl BYTE
   622
   623 					lda #$ff
   624 					bne _by
   625
   626 2B99			BYTE	lda #$00
   627
   628 2B99			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   629 2B99			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   630 2B99			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   631 					rts
   632 				.endp
   633
   634 				/*
   635 				.proc	@cmpFor_WORD (.word ya) .reg
   636 					sta ztmp
   637 					sty ztmp+1
   638
   639 					ldy #1
   640 					lda (ztmp),y
   641 					cmp :STACKORIGIN+1+STACKWIDTH,x
   642 					bne stop
   643 					dey
   644 					lda (ztmp),y
   645 					cmp :STACKORIGIN+1,x
   646 				stop	rts
   647 				.endp
   648
   649
   650 				.proc	@cmpFor_CARD (.word ya) .reg
   651 					sta ztmp
   652 					sty ztmp+1
   653
   654 					ldy #3
   655 					lda (ztmp),y
   656 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   657 					bne stop
   658 					dey
   659 					lda (ztmp),y
   660 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   661 					bne stop
   662 					dey
   663 					lda (ztmp),y
   664 					cmp :STACKORIGIN+1+STACKWIDTH,x
   665 					bne stop
   666 					dey
   667 					lda (ztmp),y
   668 					cmp :STACKORIGIN+1,x
   669
   670 				stop	rts
   671 				.endp
   672
   673
   674 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   675 					sta ztmp
   676 					sty ztmp+1
   677
   678 					ldy	#0
   679 					lda	(ztmp),y
   680 					sec
   681 					sbc	:STACKORIGIN+1,x
   682 					bne	@cmpFor_INT.L4
   683
   684 					jmp	@cmpFor_INT.L1
   685 				.endp
   686
   687
   688 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   689 					sta ztmp
   690 					sty ztmp+1
   691
   692 					ldy	#1
   693 					lda	(ztmp),y
   694 					sec
   695 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   696 					bne	@cmpFor_INT.L4
   697
   698 					dey
   699 					lda	(ztmp),y
   700 					cmp	:STACKORIGIN+1,x
   701
   702 					jmp	@cmpFor_INT.L1
   703 				.endp
   704
   705
   706 				.proc	@cmpFor_INT(.word ya) .reg
   707 					sta ztmp
   708 					sty ztmp+1
   709
   710 					ldy	#3
   711 					lda	(ztmp),y
   712 					sec
   713 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   714 					bne	L4
   715
   716 					dey
   717 					lda	(ztmp),y
   718 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   719 					bne	L1
   720
   721 					dey
   722 					lda	(ztmp),y
   723 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   724 					bne	L1
   725
   726 					dey
   727 					lda	(ztmp),y
   728 					cmp	:STACKORIGIN+1,x
   729
   730 				L1	beq	L2
   731 					bcs	L3
   732
   733 					lda	#$FF	; Set the N flag
   734 				L2	rts
   735
   736 				L3	lda	#$01	; Clear the N flag
   737 					rts
   738
   739 				L4	bvc	L5
   740 					eor	#$FF	; Fix the N flag if overflow
   741 					ora	#$01	; Clear the Z flag
   742 				L5	rts
   743 				.endp
   744 				*/
   744
   745
   746 				; Piotr Fusik, 15.04.2002
   747 				; originally by Ullrich von Bassewitz
   748
   749 2B99			.proc	cmpSHORTINT
   750 					lda	:STACKORIGIN-1,x
   751 					clv:sec
   752 					sbc	:STACKORIGIN,x
   753 					bne	cmpINT.L4
   754
   755 					jmp	cmpINT.L1
   756 				.endp
   757
   758
   759 2B99			.proc	cmpSMALLINT
   760 					lda	:STACKORIGIN-1+STACKWIDTH,x
   761 					clv:sec
   762 					sbc	:STACKORIGIN+STACKWIDTH,x
   763 					bne	cmpINT.L4
   764
   765 					lda	:STACKORIGIN-1,x
   766 					cmp	:STACKORIGIN,x
   767
   768 					jmp	cmpINT.L1
   769 				.endp
   770
   771
   772 2B99			.proc	cmpINT
   773 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   774 					clv:sec
   775 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   776 					bne	L4
   777
   778 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   779 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   780 					bne	L1
   781
   782 					lda	:STACKORIGIN-1+STACKWIDTH,x
   783 					cmp	:STACKORIGIN+STACKWIDTH,x
   784 					bne	L1
   785
   786 					lda	:STACKORIGIN-1,x
   787 					cmp	:STACKORIGIN,x
   788
   789 2B99			L1	beq	L2
   790 					bcs	L3
   791
   792 					lda	#$FF	; Set the N flag
   793 2B99			L2	rts
   794
   795 2B99			L3	lda	#$01	; Clear the N flag
   796 					rts
   797
   798 2B99			L4	bvc	L5
   799 					eor	#$FF	; Fix the N flag if overflow
   800 					ora	#$01	; Clear the Z flag
   801 2B99			L5	rts
   802 				.endp
   803
   804
   805 2B99			.proc	cmpEAX_ECX
   806 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   807 					cmp :STACKORIGIN+STACKWIDTH*3,x
   808 					bne _done
   809 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   810 					cmp :STACKORIGIN+STACKWIDTH*2,x
   811 					bne _done
   812 2B99			AX_CX
   813 					lda :STACKORIGIN-1+STACKWIDTH,x
   814 					cmp :STACKORIGIN+STACKWIDTH,x
   815 					bne _done
   816 					lda :STACKORIGIN-1,x
   817 					cmp :STACKORIGIN,x
   818
   819 2B99			_done	rts
   820 				.endp
   821
   822
   823 2B99			.proc	cmpSTRING2CHAR
   824
   825 					lda :STACKORIGIN-1,x
   826 					sta ztmp8
   827 					lda :STACKORIGIN-1+STACKWIDTH,x
   828 					sta ztmp8+1
   829
   830 					lda :STACKORIGIN,x
   831 					sta ztmp10
   832
   833 					ldy #0
   834
   835 					lda (ztmp8),y		; if length <> 1
   836 					cmp #1
   837 					bne fail
   838
   839 					iny
   840
   841 2B99			loop	lda (ztmp8),y
   842 					cmp ztmp10
   843 					bne fail
   844
   845 					lda #0
   846 					seq
   847
   848 2B99			fail	lda #$ff
   849
   850 					ldy #1
   851
   852 					cmp #0
   853 					rts
   854 				.endp
   855
   856
   857
   858 2B99			.proc	cmpCHAR2STRING
   859
   860 					lda :STACKORIGIN-1,x
   861 					sta ztmp8
   862
   863 					lda :STACKORIGIN,x
   864 					sta ztmp10
   865 					lda :STACKORIGIN+STACKWIDTH,x
   866 					sta ztmp10+1
   867
   868 					ldy #0
   869
   870 					lda (ztmp10),y		; if length <> 1
   871 					cmp #1
   872 					bne fail
   873
   874 					iny
   875
   876 2B99			loop	lda (ztmp10),y
   877 					cmp ztmp8
   878 					bne fail
   879
   880 					lda #0
   881 					seq
   882
   883 2B99			fail	lda #$ff
   884
   885 					ldy #1
   886
   887 					cmp #0
   888 					rts
   889 				.endp
   890
   891
   892 2B99			.proc	cmpSTRING
   893
   894 					lda :STACKORIGIN-1,x
   895 					sta ztmp8
   896 					lda :STACKORIGIN-1+STACKWIDTH,x
   897 					sta ztmp8+1
   898
   899 					lda :STACKORIGIN,x
   900 					sta ztmp10
   901 					lda :STACKORIGIN+STACKWIDTH,x
   902 					sta ztmp10+1
   903
   904 					ldy #0
   905
   906 					lda (ztmp8),y		; if length1 = 0
   907 					beq fail
   908 					lda (ztmp10),y		; if length2 = 0
   909 					beq fail
   910
   911 					lda (ztmp8),y		; if length1 <> length2
   912 					cmp (ztmp10),y
   913 					bne fail
   914
   915 					sta max
   916
   917 					inw ztmp8
   918 					inw ztmp10
   919
   920 2B99			loop	lda (ztmp8),y
   921 					cmp (ztmp10),y
   922 					bne fail
   923
   924 					iny
   925
   926 					cpy #0
   927 2B99			max	equ *-1
   928 					bne loop
   929
   930 					lda #0
   931 					seq
   932
   933 2B99			fail	lda #$ff
   934
   935 					ldy #1
   936
   937 					cmp #0
   938 					rts
   939 				.endp
   940
   941
   942 2B99			.proc	notaBX
   943
   944 					.rept MAXSIZE
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   946 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					.ENDR
   948 					.endr
Source: REPT
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   949
   950 					rts
   951 				.endp
   952
   953
   954 2B99			.proc	notBOOLEAN
   955 					lda :STACKORIGIN,x
   956 					bne _0
   957
   958 					lda #true
   959 					sne
   960
   961 2B99			_0	lda #false
   962 					sta :STACKORIGIN,x
   963
   964 					rts
   965 				.endp
   966
   967
   968 2B99			.proc	negBYTE
   969 					lda #$00
   970 					sub :STACKORIGIN,x
   971 					sta :STACKORIGIN,x
   972
   973 					lda #$00
   974 					sbc #$00
   975 					sta :STACKORIGIN+STACKWIDTH,x
   976
   977 					lda #$00
   978 					sbc #$00
   979 					sta :STACKORIGIN+STACKWIDTH*2,x
   980
   981 					lda #$00
   982 					sbc #$00
   983 					sta :STACKORIGIN+STACKWIDTH*3,x
   984
   985 					rts
   986 				.endp
   987
   988 2B99			.proc	negWORD
   989 					lda #$00
   990 					sub :STACKORIGIN,x
   991 					sta :STACKORIGIN,x
   992
   993 					lda #$00
   994 					sbc :STACKORIGIN+STACKWIDTH,x
   995 					sta :STACKORIGIN+STACKWIDTH,x
   996
   997 					lda #$00
   998 					sbc #$00
   999 					sta :STACKORIGIN+STACKWIDTH*2,x
  1000
  1001 					lda #$00
  1002 					sbc #$00
  1003 					sta :STACKORIGIN+STACKWIDTH*3,x
  1004
  1005 					rts
  1006 				.endp
  1007
  1008 2B99			.proc	negCARD
  1009 2B99 A9 00			lda #$00
  1010 2B9B 38 F5 98			sub :STACKORIGIN,x
  1011 2B9E 95 98			sta :STACKORIGIN,x
  1012
  1013 2BA0 A9 00			lda #$00
  1014 2BA2 F5 A8			sbc :STACKORIGIN+STACKWIDTH,x
  1015 2BA4 95 A8			sta :STACKORIGIN+STACKWIDTH,x
  1016
  1017 2BA6 A9 00			lda #$00
  1018 2BA8 F5 B8			sbc :STACKORIGIN+STACKWIDTH*2,x
  1019 2BAA 95 B8			sta :STACKORIGIN+STACKWIDTH*2,x
  1020
  1021 2BAC A9 00			lda #$00
  1022 2BAE F5 C8			sbc :STACKORIGIN+STACKWIDTH*3,x
  1023 2BB0 95 C8			sta :STACKORIGIN+STACKWIDTH*3,x
  1024
  1025 2BB2 60				rts
  1026 				.endp
  1027
  1028
  1029 2BB3			.proc	negBYTE1
  1030 					lda #$00
  1031 					sub :STACKORIGIN-1,x
  1032 					sta :STACKORIGIN-1,x
  1033
  1034 					lda #$00
  1035 					sbc #$00
  1036 					sta :STACKORIGIN-1+STACKWIDTH,x
  1037
  1038 					lda #$00
  1039 					sbc #$00
  1040 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1041
  1042 					lda #$00
  1043 					sbc #$00
  1044 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1045
  1046 					rts
  1047 				.endp
  1048
  1049 2BB3			.proc	negWORD1
  1050 					lda #$00
  1051 					sub :STACKORIGIN-1,x
  1052 					sta :STACKORIGIN-1,x
  1053
  1054 					lda #$00
  1055 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1056 					sta :STACKORIGIN-1+STACKWIDTH,x
  1057
  1058 					lda #$00
  1059 					sbc #$00
  1060 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1061
  1062 					lda #$00
  1063 					sbc #$00
  1064 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1065
  1066 					rts
  1067 				.endp
  1068
  1069 2BB3			.proc	negCARD1
  1070 					lda #$00
  1071 					sub :STACKORIGIN-1,x
  1072 					sta :STACKORIGIN-1,x
  1073
  1074 					lda #$00
  1075 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1076 					sta :STACKORIGIN-1+STACKWIDTH,x
  1077
  1078 					lda #$00
  1079 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1080 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1081
  1082 					lda #$00
  1083 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1084 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1085
  1086 					rts
  1087 				.endp
  1088
  1089
  1090 2BB3			.proc	andAL_CL
  1091
  1092 					lda :STACKORIGIN-1,x
  1093 					and :STACKORIGIN,x
  1094 					sta :STACKORIGIN-1,x
  1095
  1096 					rts
  1097 				.endp
  1098
  1099 2BB3			.proc	andAX_CX
  1100
  1101 					.rept 2
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1103 					AND :STACKORIGIN+#*STACKWIDTH,X
  1104 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					.ENDR
  1105 					.endr
Source: REPT
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1106
  1107 					rts
  1108 				.endp
  1109
  1110 2BB3			.proc	andEAX_ECX
  1111
  1112 					.rept MAXSIZE
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1114 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					.ENDR
  1116 					.endr
Source: REPT
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1117
  1118 					rts
  1119 				.endp
  1120
  1121
  1122 2BB3			.proc	orAL_CL
  1123
  1124 					lda :STACKORIGIN-1,x
  1125 					ora :STACKORIGIN,x
  1126 					sta :STACKORIGIN-1,x
  1127
  1128 					rts
  1129 				.endp
  1130
  1131 2BB3			.proc	orAX_CX
  1132
  1133 					.rept 2
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1135 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1136 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					.ENDR
  1137 					.endr
Source: REPT
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1138
  1139 					rts
  1140 				.endp
  1141
  1142 2BB3			.proc	orEAX_ECX
  1143
  1144 					.rept MAXSIZE
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1146 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					.ENDR
  1148 					.endr
Source: REPT
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1149
  1150 					rts
  1151 				.endp
  1152
  1153
  1154 2BB3			.proc	xorAL_CL
  1155
  1156 					lda :STACKORIGIN-1,x
  1157 					eor :STACKORIGIN,x
  1158 					sta :STACKORIGIN-1,x
  1159
  1160 					rts
  1161 				.endp
  1162
  1163 2BB3			.proc	xorAX_CX
  1164
  1165 					.rept 2
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1167 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1168 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					.ENDR
  1169 					.endr
Source: REPT
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1170
  1171 					rts
  1172 				.endp
  1173
  1174 2BB3			.proc	xorEAX_ECX
  1175
  1176 					.rept MAXSIZE
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1178 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					.ENDR
  1180 					.endr
Source: REPT
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1181
  1182 					rts
  1183 				.endp
  1184
  1185
  1186 				/*
  1187 				.proc	iniEAX_ECX_BYTE
  1188
  1189 					mva :STACKORIGIN,x ecx
  1190 					mva :STACKORIGIN-1,x eax
  1191
  1192 					rts
  1193 				.endp
  1194 				*/
  1194
  1195
  1196
  1197 2BB3			.proc	iniEAX_ECX_WORD
  1198
  1199 					mva :STACKORIGIN,x ecx
  1200 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1201
  1202 					mva :STACKORIGIN-1,x eax
  1203 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1204
  1205 					mva #$00 ecx+2
  1206 					sta ecx+3
  1207
  1208 					sta eax+2
  1209 					sta eax+3
  1210
  1211 					rts
  1212 				.endp
  1213
  1214
  1215 2BB3			.proc	iniEAX_ECX_CARD
  1216 					mva :STACKORIGIN,x ecx
  1217 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1218 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1219 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1220
  1221 					mva :STACKORIGIN-1,x eax
  1222 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1223 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1224 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1225
  1226 					rts
  1227 				.endp
  1228
  1229 2BB3			.proc	movZTMP_aBX
  1230 					mva ZTMP8 :STACKORIGIN-1,x
  1231 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1232 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1233 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1234
  1235 					rts
  1236 				.endp
  1237
  1238
  1239 2BB3				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 2BB3			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 2BB3			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 2BB3			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 2BB3			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 2BB3			lsector	:8 dta l(256)
    55 2BB3			hsector	:8 dta h(256)
    56
    57 				.endp
  1240 2BB3				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 2BB3			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 2BB3			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 2BB3			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 2BB3			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 2BB3			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 2BB3			msg	lda #true
    64 2BB3			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 2BB3			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 2BB3			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 2BB3			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 2BB3			lookup	ldx #$00
   110 					ldy #$01
   111 2BB3			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 2BB3			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 2BB3			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 2BB3			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 2BB3			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 2BB3			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 2BB3			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 2BB3			done	jsr eof
   247
   248 2BB3			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 2BB3			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 2BB3			quit	rts
   265
   266 2BB3			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 2BB3			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 2BB3			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 2BB3			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 2BB3			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 2BB3			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 2BB3			stp2
   336 					dey
   337 					tya
   338 2BB3			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 2BB3			attr	equ *-1
   343 					rts
   344
   345 2BB3			cpName	sta ln
   346 2BB3			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 2BB3			ln	equ *-1
   354 					bne cp
   355 2BB3			stp	rts
   356 				.endp
   357
  1241
  1242 2BB3				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 2BB3			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 2BB3			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 2BB3			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 2BB3			.proc	divmulSHORTINT
    31
    32 2BB3			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 2BB3			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 2BB3			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 2BB3			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 2BB3			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 2BB3			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 2BB3			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1243 2BB3				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 2BB3			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 2BB3			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 2BB3			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 2BB3			.proc	divmulSMALLINT
    37
    38 2BB3			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 2BB3			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 2BB3			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 2BB3			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 2BB3			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 2BB3			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 2BB3			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 2BB3			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1244 2BB3				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 2BB3			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 2BB3			.proc	divmulINT
    16
    17 2BB3			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 2BB3			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 2BB3			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 2BB3			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 2BB3			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 2BB3			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 2BB3			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 2BB3			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1245
  1246 2BB3				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 2BB3			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 2BB3			sm1:		lda square1_lo,x
    49 2BB3			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 2BB3			sm3:		lda square1_hi,x
    52 2BB3			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 2BB3			.proc	imulCL
    75
    76 2BB3 A9 00			lda #$00
    77
    78 2BB5 A0 09			LDY #$09
    79 2BB7 18				CLC
    80 2BB8 6A			LOOP	ROR @
    81 2BB9 66 82			ROR eax
    82 2BBB 90 03			BCC MUL2
    83 2BBD 18				CLC		;DEC AUX above to remove CLC
    84 2BBE 65 8A			ADC ecx
    85 2BC0 88			MUL2	DEY
    86 2BC1 D0 F5			BNE LOOP
    87
    88 2BC3 85 83			STA eax+1
    89
    90 2BC5 60				RTS
    91 				.endp
    92
    93
    94 2BC6			.proc	imulBYTE
    95
    96 2BC6 B5 98 85 8A			mva :STACKORIGIN,x ecx
    97 2BCA B5 97 85 82			mva :STACKORIGIN-1,x eax
    98
    99 2BCE A9 00			lda #$00
   100
   101 2BD0 85 84			sta eax+2
   102 2BD2 85 85			sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 2BD4 4C B3 2B			jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 2BD7			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 2BD7			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 2BD7			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 2BD7			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1247 2BD7				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 2BD7			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 2BD7			sm1a:		lda square1_lo,x
    78 2BD7			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 2BD7			sm3a:		lda square1_hi,x
    81 2BD7			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 2BD7			sm1b:		lda square1_lo,x
    88 2BD7			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 2BD7			sm3b:		lda square1_hi,x
    91 2BD7			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 2BD7			sm5a:		lda square1_lo,x
    98 2BD7			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 2BD7			sm7a:		lda square1_hi,x
   101 2BD7			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 2BD7			sm5b:		lda square1_lo,x
   107 2BD7			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 2BD7			sm7b:		lda square1_hi,x
   110 2BD7			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 2BD7			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 2BD7			_BB_:		lda #0
   122 2BD7			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 2BD7			@
   129 						tya
   130 2BD7			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 2BD7			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 2BD7			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 2BD7			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 2BD7			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 2BD7			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 2BD7			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 2BD7			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 2BD7			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 2BD7			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 2BD7			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1248 2BD7				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 2BD7			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 2BD7			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 2BD7			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 2BD7			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 2BD7			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 2BD7			.proc	idivEAX_ECX
    74
    75 2BD7			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 2BD7			CARD	;jsr iniEAX_ECX_CARD
    81
    82 2BD7			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 2BD7			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 2BD7			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1249
  1250 2BD7				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 2BD7			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 2BD7			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 2BD7			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 2BD7			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1251 2BD7				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 2BD7			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 2BD7			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 2BD7			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 2BD7			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 2BD7			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 2BD7			ecx3	equ *-1
    59 2BD7			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 2BD7			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 2BD7			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 2BD7			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 2BD7			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 2BD7			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 2BD7			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 2BD7			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 2BD7			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 2BD7			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 2BD7			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 2BD7			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 2BD7			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1252 2BD7				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 2BD7			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 2BD7			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 2BD7			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 2BD7			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 2BD7			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 2BD7			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 2BD7			FADD:	LDA	#$00
   159 2BD7			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 2BD7			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 2BD7			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 2BD7			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 2BD7			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 2BD7			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 2BD7			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 2BD7			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 2BD7			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 2BD7			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 2BD7			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 2BD7			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 2BD7			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 2BD7			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 2BD7			FPNORMLEFT1:	BMI	FPNORMDONE
   367 2BD7			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 2BD7			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 2BD7			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 2BD7			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 2BD7			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 2BD7			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 2BD7			@	EOR	#$FF
   480 					LDX	#$08
   481 2BD7			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 2BD7			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 2BD7			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 2BD7			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 2BD7			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 2BD7			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 2BD7			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 2BD7			.proc	FCMPL
   605 2BD7			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 2BD7			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 2BD7			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 2BD7			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 2BD7			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 2BD7			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 2BD7			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 2BD7			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 2BD7			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 2BD7			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 2BD7			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 2BD7			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 2BD7			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 2BD7			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 2BD7			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 2BD7			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 2BD7			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 2BD7			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 2BD7			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 2BD7			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 2BD7			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 2BD7			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 2BD7			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 2BD7			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1253
  1254
  1255 2BD7			.proc	@printCHAR
  1256 2BD7 B4 98			ldy :STACKORIGIN,x
  1257 2BD9 4C E1 2B			jmp @print
  1258 				.endp
  1259
  1260
  1261 2BDC			.proc	@printEOL
  1262 2BDC A0 9B			ldy #eol
  1263 2BDE 4C E1 2B			jmp @print
  1264 				.endp
  1265
  1266
  1267 2BE1			.proc	@print (.byte y) .reg
  1268 2BE1 8A 48			txa:pha
  1269
  1270 2BE3 98				tya
  1271 2BE4 20 DB 2C			jsr @putchar
  1272
  1273 2BE7 68 AA			pla:tax
  1274 2BE9 60				rts
  1275 				.endp
  1276
  1277
  1278 2BEA			.proc	@printPCHAR (.word ya) .reg
  1279 					sta addr
  1280 					sty addr+1
  1281
  1282 					stx @sp
  1283
  1284 					lda #0
  1285 					sta loop+1
  1286
  1287 2BEA			loop	ldy #0
  1288 					lda $ffff,y
  1289 2BEA			addr	equ *-2
  1290 					beq stop
  1291
  1292 					inc loop+1
  1293 					beq stop
  1294
  1295 					jsr @putchar
  1296
  1297 					jmp loop
  1298
  1299 2BEA			stop	ldx #0
  1300 2BEA			@sp	equ *-1
  1301 					rts
  1302 				.endp
  1303
  1304
  1305 2BEA			.proc	@printSTRING (.word ya) .reg
  1306 2BEA 85 92			sta ztmp
  1307 2BEC 84 93			sty ztmp+1
  1308
  1309 2BEE 8E 13 2C			stx @sp
  1310
  1311 2BF1 A0 00			ldy #0
  1312 2BF3 8C 02 2C			sty loop+1
  1313 2BF6 B1 92			lda (ztmp),y
  1314 2BF8 8D 06 2C			sta ln
  1315
  1316 2BFB E6 92 D0 02 E6 93		inw ztmp
  1317
  1318 2C01 A0 00		loop	ldy #0
  1319 2C03 B1 92			lda (ztmp),y
  1320 				;	beq stop
  1321
  1322 2C05 C0 00			cpy #0
  1323 = 2C06			ln	equ *-1
  1324 2C07 F0 09			beq stop
  1325
  1326 2C09 EE 02 2C			inc loop+1
  1327
  1328 2C0C 20 DB 2C			jsr @putchar
  1329
  1330 2C0F 4C 01 2C			jmp loop
  1331
  1332 2C12 A2 00		stop	ldx #0
  1333 = 2C13			@sp	equ *-1
  1334 2C14 60				rts
  1335 				.endp
  1336
  1337
  1338 2C15			.proc	@printBOOLEAN
  1339 					lda :STACKORIGIN,x
  1340 					beq _0
  1341
  1342 2C15			_1	lda <_true
  1343 					ldy >_true
  1344 					jmp @printSTRING
  1345
  1346 2C15			_0	lda <_false
  1347 					ldy >_false
  1348 					jmp @printSTRING
  1349
  1350 2C15			_true	dta 4,c'TRUE'
  1351 2C15			_false	dta 5,c'FALSE'
  1352 				.endp
  1353
  1354
  1355 2C15			.proc	mov_BYTE_DX
  1356 					mva :STACKORIGIN,x dx
  1357 					mva #$00 dx+1
  1358 					sta dx+2
  1359 					sta dx+3
  1360
  1361 					rts
  1362 				.endp
  1363
  1364 2C15			.proc	mov_WORD_DX
  1365 					mva :STACKORIGIN,x dx
  1366 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1367 					mva #$00 dx+2
  1368 					sta dx+3
  1369
  1370 					rts
  1371 				.endp
  1372
  1373 2C15			.proc	mov_CARD_DX
  1374 2C15 B5 98 85 86			mva :STACKORIGIN,x dx
  1375 2C19 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x dx+1
  1376 2C1D B5 B8 85 88			mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1377 2C21 B5 C8 85 89			mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1378
  1379 2C25 60				rts
  1380 				.endp
  1381
  1382
  1383 2C26			.proc	@printMINUS
  1384 2C26 A0 2D			ldy #'-'
  1385 2C28 20 94 2C			jsr @printVALUE.pout
  1386
  1387 2C2B 4C 99 2B			jmp negCARD
  1388 				.endp
  1389
  1390
  1391 2C2E			.proc	@printSHORTREAL
  1392 					jsr @expandToCARD.SMALL
  1393 					jmp @printREAL
  1394 				.endp
  1395
  1396
  1397 2C2E			.proc	@FTOA
  1398
  1399 = 0086			i	= edx
  1400 = 008A			fra	= ecx
  1401 = 0082			hlp	= eax
  1402
  1403 = 0092			exp	= ztmp
  1404 = 0093			b	= ztmp+1
  1405 = 0094			sht	= ztmp+2
  1406
  1407 = 0440			bit	= @buf+64
  1408
  1409 					stx @sp
  1410
  1411 					mva :STACKORIGIN,x I
  1412 					sta :STACKORIGIN+9
  1413 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1414 					sta :STACKORIGIN+STACKWIDTH+9
  1415 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1416 					sta :STACKORIGIN+STACKWIDTH*2+9
  1417 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1418 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1419
  1420 					bpl skp
  1421
  1422 					ldy #'-'
  1423 					jsr @printVALUE.pout
  1424
  1425 2C2E			skp
  1426 				; optimize OK (test_3.pas), line = 32
  1427
  1428 					lda :STACKORIGIN+STACKWIDTH*3+9
  1429 					asl :STACKORIGIN+9
  1430 					rol :STACKORIGIN+STACKWIDTH+9
  1431 					rol :STACKORIGIN+STACKWIDTH*2+9
  1432 					rol @
  1433 					sta EXP				; Exponent
  1434
  1435 				; optimize OK (test_3.pas), line = 33
  1436
  1437 					lda I
  1438 					sta FRA
  1439 					lda I+1
  1440 					sta FRA+1
  1441 					lda I+2
  1442 					sta FRA+2
  1443 					lda I+3
  1444 					sta FRA+3
  1445 					asl FRA
  1446 					rol FRA+1
  1447 					rol FRA+2
  1448 					rol FRA+3
  1449
  1450 				; optimize OK (test_3.pas), line = 35
  1451
  1452 					lda EXP
  1453 					sub #$7F
  1454 					sta SHT
  1455
  1456 				; optimize OK (test_3.pas), line = 37
  1457
  1458 					ldx #$3f
  1459 					lda #0
  1460 					sta:rpl bit,x-
  1461
  1462 				; For
  1463
  1464 				; optimize OK (test_3.pas), line = 39
  1465
  1466 				;	sta B
  1467 					tax
  1468
  1469 				; optimize OK (test_3.pas), line = 39
  1470
  1471 2C2E			l_01D4
  1472 				;	lda B
  1473 				;	cmp #$17
  1474 					cpx #$17
  1475 					bcc *+7
  1476 					beq *+5
  1477
  1478 				; ForToDoProlog
  1479 					jmp l_01EE
  1480
  1481 				; optimize OK (test_3.pas), line = 40
  1482
  1483 				;	lda #$20
  1484 				;	add B
  1485 				;	tax
  1486
  1487 					lda FRA+2
  1488 					sta BIT+$20,x
  1489
  1490 				; optimize OK (test_3.pas), line = 41
  1491
  1492 					asl FRA
  1493 					rol FRA+1
  1494 					rol FRA+2
  1495 					rol FRA+3
  1496
  1497 				; ForToDoEpilog
  1498 2C2E			c_01D4
  1499 				;	inc B
  1500 					inx
  1501
  1502 					seq
  1503
  1504 				; WhileDoEpilog
  1505 					jmp l_01D4
  1506 2C2E			l_01EE
  1507 2C2E			b_01D4
  1508
  1509 				; optimize OK (test_3.pas), line = 44
  1510
  1511 					mva #$80 BIT+$1f
  1512
  1513 				; optimize OK (test_3.pas), line = 46
  1514
  1515 					mva #$00 I
  1516 					sta I+1
  1517 					sta I+2
  1518 					sta I+3
  1519
  1520 				; optimize OK (test_3.pas), line = 47
  1521
  1522 					sta FRA+1
  1523 					sta FRA+2
  1524 					sta FRA+3
  1525
  1526 					mva #$01 FRA
  1527
  1528 				; For
  1529
  1530 				; optimize OK (test_3.pas), line = 49
  1531
  1532 					lda SHT
  1533 					add #$1F
  1534 					sta B
  1535
  1536 				; optimize OK (test_3.pas), line = 49
  1537
  1538 					tay
  1539
  1540 2C2E			l_035B
  1541 				;	lda B
  1542 				;	cmp #$00
  1543 				;	bcs *+5
  1544
  1545 				; ForToDoProlog
  1546 				;	jmp l_0375
  1547
  1548 				; optimize OK (test_3.pas), line = 50
  1549
  1550 				;	ldy B
  1551 					lda BIT,y
  1552 					bpl l_03D7
  1553
  1554 				; optimize OK (test_3.pas), line = 50
  1555
  1556 					lda I				; Mantissa
  1557 					add FRA
  1558 					sta I
  1559 					lda I+1
  1560 					adc FRA+1
  1561 					sta I+1
  1562 					lda I+2
  1563 					adc FRA+2
  1564 					sta I+2
  1565 					lda I+3
  1566 					adc FRA+3
  1567 					sta I+3
  1568
  1569 				; IfThenEpilog
  1570 2C2E			l_03D7
  1571
  1572 				; optimize OK (test_3.pas), line = 52
  1573
  1574 					asl FRA
  1575 					rol FRA+1
  1576 					rol FRA+2
  1577 					rol FRA+3
  1578
  1579 				; ForToDoEpilog
  1580 2C2E			c_035B
  1581 				;	dec B
  1582 					dey
  1583
  1584 				;	lda B
  1585 				;	cmp #$ff
  1586 					cpy #$ff
  1587 					seq
  1588
  1589 				; WhileDoEpilog
  1590 					jmp l_035B
  1591 2C2E			l_0375
  1592 2C2E			b_035B
  1593
  1594 				; optimize OK (test_3.pas), line = 55
  1595
  1596 					mva #$00 FRA
  1597 					sta FRA+1
  1598 					sta FRA+2
  1599 					sta FRA+3
  1600
  1601 				; optimize OK (test_3.pas), line = 56
  1602
  1603 					sta EXP
  1604
  1605 					sta hlp
  1606 					sta hlp+1
  1607
  1608 					lda #$80
  1609 					sta hlp+2
  1610 				; For
  1611
  1612 				; optimize OK (test_3.pas), line = 58
  1613
  1614 					lda SHT
  1615 					add #$20
  1616 				;	sta B
  1617
  1618 					tay
  1619
  1620 				; optimize OK (test_3.pas), line = 58
  1621
  1622 					add #23
  1623 					sta FORTMP_1273
  1624 				; To
  1625 2C2E			l_0508
  1626
  1627 				; ForToDoCondition
  1628
  1629 				; optimize OK (test_3.pas), line = 58
  1630
  1631 				;	lda B
  1632 				;	cmp #0
  1633 					cpy #0
  1634 2C2E			FORTMP_1273	equ *-1
  1635 					bcc *+7
  1636 					beq *+5
  1637
  1638 				; ForToDoProlog
  1639 					jmp l_0534
  1640
  1641 				; optimize OK (test_3.pas), line = 59
  1642
  1643 				;	ldy B
  1644 					lda BIT,y
  1645 					bpl l_0596
  1646
  1647 				; optimize OK (test_3.pas), line = 59
  1648
  1649 					lda FRA
  1650 					add hlp
  1651 					sta FRA
  1652 					lda FRA+1
  1653 					adc hlp+1
  1654 					sta FRA+1
  1655 					lda FRA+2
  1656 					adc hlp+2
  1657 					sta FRA+2
  1658
  1659 				; IfThenEpilog
  1660 2C2E			l_0596
  1661
  1662 					lsr hlp+2
  1663 					ror hlp+1
  1664 					ror hlp
  1665
  1666 				; ForToDoEpilog
  1667 2C2E			c_0508
  1668 				;	inc B						; inc ptr byte [CounterAddress]
  1669 					iny
  1670
  1671 					seq
  1672
  1673 				; WhileDoEpilog
  1674 					jmp l_0508
  1675 2C2E			l_0534
  1676 2C2E			b_0508
  1677 2C2E				:3 mva fra+# fracpart+#
  1678
  1679 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1680 					@float #500000
  1681
  1682 					ldx #0
  1683 2C2E			@sp	equ *-1
  1684
  1685 					rts
  1686 				.endp
  1687
  1688
  1689 2C2E			.proc	@printREAL
  1690
  1691 					stx @sp
  1692
  1693 					lda :STACKORIGIN+STACKWIDTH*3,x
  1694 					spl
  1695 					jsr @printMINUS
  1696
  1697 					jsr mov_CARD_DX
  1698
  1699 					mva dx+1 intpart		; intpart := uvalue shr 8
  1700 					mva dx+2 intpart+1
  1701 					mva dx+3 intpart+2
  1702 					mva #$00 intpart+3
  1703
  1704 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1705 					sta dx+2
  1706 					sta dx+1
  1707
  1708 					sta fracpart
  1709 					sta fracpart+1
  1710
  1711 					lda dx
  1712 					sta fracpart+2
  1713
  1714 2C2E				:4 mva intpart+# dx+#		; integer part
  1715
  1716 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1717 					@float #5000
  1718
  1719 					ldx #0
  1720 2C2E			@sp	equ *-1
  1721 					rts
  1722
  1723 2C2E 00 00 00 00		intpart		.dword
  1724
  1725 				.endp
  1726
  1727
  1728 2C32			.proc	@float (.long axy) .reg
  1729
  1730 					sty cx
  1731 					stx cx+1
  1732 					sta cx+2
  1733
  1734 					lda @printVALUE.pout		; print integer part
  1735 					pha
  1736 					jsr @printVALUE
  1737 					pla
  1738 					sta @printVALUE.pout
  1739
  1740 					lda #0
  1741 					sta dx
  1742 					sta dx+1
  1743 					sta dx+2
  1744 					sta dx+3
  1745
  1746 2C32			loop	lda fracpart+2
  1747 					bpl skp
  1748
  1749 					clc
  1750 				;	lda cx
  1751 				;	spl
  1752 				;	sec
  1753
  1754 					lda dx
  1755 					adc cx
  1756 					sta dx
  1757 					lda dx+1
  1758 					adc cx+1
  1759 					sta dx+1
  1760 					lda dx+2
  1761 					adc cx+2
  1762 					sta dx+2
  1763 				;	lda dx+3
  1764 				;	adc #0
  1765 				;	sta dx+3
  1766
  1767 2C32			skp	lsr cx+2
  1768 					ror cx+1
  1769 					ror cx
  1770
  1771 					asl fracpart
  1772 					rol fracpart+1
  1773 					rol fracpart+2
  1774
  1775 					lda cx
  1776 					ora cx+1
  1777 					ora cx+2
  1778
  1779 					bne loop
  1780
  1781 					ldy #'.'
  1782 					jsr @printVALUE.pout
  1783
  1784 2C32				:4 mva dx+# fracpart+#
  1785
  1786 					lda @printVALUE.pout
  1787 					pha
  1788
  1789 					lda #{rts}
  1790 					sta @printVALUE.pout
  1791 					jsr @printVALUE			; floating part length
  1792
  1793 					sta cnt
  1794
  1795 					pla
  1796 					sta @printVALUE.pout
  1797
  1798 2C32			lp	lda #0
  1799 2C32			cnt	equ *-1
  1800 					cmp #4				; N miejsc po przecinku
  1801 2C32			afterpoint equ *-1
  1802 					bcs ok
  1803
  1804 					ldy #'0'
  1805 					jsr @printVALUE.pout
  1806
  1807 					inc cnt
  1808 					bne lp
  1809
  1810 2C32			ok	:4 mva fracpart+# dx+#
  1811 					jmp @printVALUE			; print floating part
  1812
  1813 				.endp
  1814
  1815
  1816 2C32			.proc	@printSHORTINT
  1817
  1818 					lda :STACKORIGIN,x
  1819 					spl
  1820 					jsr @printMINUS
  1821
  1822 					jmp @printBYTE
  1823 				.endp
  1824
  1825
  1826 2C32			.proc	@printSMALLINT
  1827
  1828 					lda :STACKORIGIN+STACKWIDTH,x
  1829 					spl
  1830 					jsr @printMINUS
  1831
  1832 					jmp @printWORD
  1833 				.endp
  1834
  1835
  1836 2C32			.proc	@printINT
  1837
  1838 2C32 B5 C8			lda :STACKORIGIN+STACKWIDTH*3,x
  1839 2C34 10 03			spl
  1840 2C36 20 26 2C			jsr @printMINUS
  1841
  1842 2C39 4C 3C 2C			jmp @printCARD
  1843 				.endp
  1844
  1845
  1846 2C3C			.proc	@printCARD
  1847 2C3C 20 15 2C			jsr mov_CARD_DX
  1848 2C3F 4C 42 2C			jmp @printVALUE
  1849 				.endp
  1850
  1851
  1852 2C42			.proc	@printWORD
  1853 					jsr mov_WORD_DX
  1854 					jmp @printVALUE
  1855 				.endp
  1856
  1857
  1858 2C42			.proc	@printBYTE
  1859 					jsr mov_BYTE_DX
  1860 					jmp @printVALUE
  1861 				.endp
  1862
  1863
  1864 2C42			.proc	@printVALUE
  1865
  1866 2C42 A5 89			lda dx+3
  1867 2C44 D0 14			bne _32bit
  1868
  1869 2C46 A5 88			lda dx+2
  1870 2C48 D0 0C			bne _24bit
  1871
  1872 2C4A A5 87			lda dx+1
  1873 2C4C D0 04			bne _16bit
  1874
  1875 2C4E A9 03		_8bit	lda #3
  1876 2C50 D0 0A			bne l3
  1877
  1878 2C52 A9 05		_16bit	lda #5
  1879 2C54 D0 06			bne l3
  1880
  1881 2C56 A9 08		_24bit	lda #8
  1882 2C58 D0 02			bne l3
  1883
  1884 					; prints a 32 bit value to the screen (Graham)
  1885
  1886 2C5A A9 0A		_32bit	lda #10
  1887
  1888 2C5C 8D 6F 2C		l3	sta limit
  1889
  1890 2C5F 8E 92 2C			stx @sp
  1891
  1892 2C62 A2 00			ldx #0
  1893 2C64 8E 90 2C			stx cnt
  1894
  1895 2C67 20 A8 2C		lp	jsr div10
  1896
  1897 2C6A 9D 9E 2C			sta tmp,x
  1898 2C6D E8				inx
  1899 2C6E E0 0A			cpx #10
  1900 = 2C6F			limit	equ *-1
  1901 2C70 D0 F5			bne lp
  1902
  1903 					;ldx #9
  1904 2C72 CA				dex
  1905
  1906 2C73 BD 9E 2C		l1	lda tmp,x
  1907 2C76 D0 03			bne l2
  1908 2C78 CA				dex		; skip leading zeros
  1909 2C79 D0 F8			bne l1
  1910
  1911 2C7B BD 9E 2C		l2	lda tmp,x
  1912 2C7E 09 30			ora #$30
  1913 2C80 A8				tay
  1914
  1915 2C81 20 94 2C			jsr pout
  1916 2C84 EE 90 2C			inc cnt
  1917
  1918 2C87 CA				dex
  1919 2C88 10 F1			bpl l2
  1920
  1921 2C8A A9 4C 8D 94 2C		mva #{jmp*} pout
  1922
  1923 2C8F A9 00			lda #0
  1924 = 2C90			cnt	equ *-1
  1925
  1926 2C91 A2 00			ldx #0
  1927 = 2C92			@sp	equ *-1
  1928 2C93 60				rts
  1929
  1930 2C94 4C E1 2B		pout	jmp @print
  1931
  1932 2C97 8C 01 04			sty @buf+1
  1933 = 2C98			pbuf	equ *-2
  1934 2C9A EE 98 2C			inc pbuf
  1935
  1936 2C9D 60				rts
  1937
  1938 2C9E 00 00 00 00 00 00 + tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1939
  1940 				.endp
  1941
  1942
  1943 				; divides a 32 bit value by 10
  1944 				; remainder is returned in akku
  1945
  1946 2CA8			.proc	div10
  1947 2CA8 A0 20		        ldy #32		; 32 bits
  1948 2CAA A9 00		        lda #0
  1949 2CAC 18			        clc
  1950 2CAD 2A			l4      rol @
  1951 2CAE C9 0A		        cmp #10
  1952 2CB0 90 02		        bcc skip
  1953 2CB2 E9 0A		        sbc #10
  1954 2CB4 26 86		skip    rol dx
  1955 2CB6 26 87		        rol dx+1
  1956 2CB8 26 88		        rol dx+2
  1957 2CBA 26 89		        rol dx+3
  1958 2CBC 88			        dey
  1959 2CBD 10 EE		        bpl l4
  1960
  1961 2CBF 60				rts
  1962 				.endp
  1963
  1964
  1965 2CC0			.proc	@hexStr
  1966
  1967 = 0086			Value	= edx
  1968 = 008A			Digits	= ecx
  1969
  1970 					ldx Digits
  1971 					cpx #32
  1972 					scc
  1973 					ldx #32
  1974
  1975 					stx Digits
  1976
  1977 					lda Value
  1978 					jsr hex
  1979 					lda Value+1
  1980 					jsr hex
  1981 					lda Value+2
  1982 					jsr hex
  1983 					lda Value+3
  1984 					jsr hex
  1985
  1986 					lda Digits
  1987 					sta @buf
  1988 					rts
  1989
  1990 2CC0			hex	pha
  1991 					and #$f
  1992 					jsr put
  1993 					pla
  1994 2CC0				:4 lsr @
  1995 2CC0			put	tay
  1996 					lda thex,y
  1997 					sta @buf,x
  1998 					dex
  1999 					rts
  2000
  2001 2CC0			thex	dta c'0123456789ABCDEF'
  2002 				.endp
  2003
  2004
  2005 2CC0			.proc	@ValueToStr (.word ya) .reg
  2006
  2007 2CC0 8D D1 2C			sta adr
  2008 2CC3 8C D2 2C			sty adr+1
  2009
  2010 2CC6 A9 2C 8D 94 2C		mva #{bit*} @printVALUE.pout
  2011 2CCB A9 01 8D 98 2C		mva <@buf+1 @printVALUE.pbuf
  2012
  2013 2CD0 20 FF FF			jsr $ffff
  2014 = 2CD1			adr	equ *-2
  2015
  2016 2CD3 AC 98 2C			ldy @printVALUE.pbuf
  2017 2CD6 88				dey
  2018 2CD7 8C 00 04			sty @buf
  2019
  2020 2CDA 60				rts
  2021 				.endp
  2022
  2023
  2024 				;	ecx	isSign
  2025 				;	edx	Result
  2026
  2027 2CDB			.proc	@StrToInt (.word ya) .reg
  2028
  2029 					sta bp2
  2030 					sty bp2+1
  2031
  2032 					ldy #0
  2033 					sty MAIN.SYSTEM.IOResult
  2034 					sty edx
  2035 					sty edx+1
  2036 					sty edx+2
  2037 					sty edx+3
  2038
  2039 					lda (bp2),y
  2040 					beq stop
  2041 					sta len
  2042
  2043 					inw bp2
  2044
  2045 					lda (bp2),y
  2046 					cmp #'-'
  2047 					sne
  2048 					iny
  2049
  2050 					sty ecx
  2051
  2052 2CDB			l1	lda (bp2),y
  2053
  2054 					CLC
  2055 					ADC #$FF-'9'	; make m = $FF
  2056 					ADC #'9'-'0'+1	; carry set if in range n to m
  2057 					bcs ok
  2058
  2059 					lda #106	; Invalid numeric format
  2060 					sta MAIN.SYSTEM.IOResult
  2061
  2062 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2063
  2064 2CDB			ok	jsr fmul10
  2065
  2066 					lda (bp2),y
  2067 					sub #$30
  2068 					sta ztmp
  2069
  2070 					lda #$00
  2071 					sta ztmp+1
  2072 					sta ztmp+2
  2073 					sta ztmp+3
  2074
  2075 					jsr fmul10.add32bit
  2076
  2077 					iny
  2078 					cpy #0
  2079 2CDB			len	equ *-1
  2080 					bne l1
  2081
  2082 					lda ecx
  2083 					beq stop
  2084
  2085 					jsr negEDX
  2086
  2087 2CDB			stop	ldy #0		; reg Y = 0 conversion successful
  2088 					rts
  2089 				.endp
  2090
  2091
  2092 2CDB			.proc	negEDX
  2093 					lda #$00	; minus
  2094 					sub edx
  2095 					sta edx
  2096
  2097 					lda #$00
  2098 					sbc edx+1
  2099 					sta edx+1
  2100
  2101 					lda #$00
  2102 					sbc edx+2
  2103 					sta edx+2
  2104
  2105 					lda #$00
  2106 					sbc edx+3
  2107 					sta edx+3
  2108
  2109 					rts
  2110 				.endp
  2111
  2112
  2113 2CDB			.proc	fmul10
  2114 					asl edx		;multiply by 2
  2115 					rol edx+1	;temp store in ZTMP
  2116 					rol edx+2
  2117 					rol edx+3
  2118
  2119 					lda edx
  2120 					sta ztmp
  2121 					lda edx+1
  2122 					sta ztmp+1
  2123 					lda edx+2
  2124 					sta ztmp+2
  2125 					lda edx+3
  2126 					sta ztmp+3
  2127
  2128 					asl edx
  2129 					rol edx+1
  2130 					rol edx+2
  2131 					rol edx+3
  2132
  2133 					asl edx
  2134 					rol edx+1
  2135 					rol edx+2
  2136 					rol edx+3
  2137
  2138 2CDB			add32bit
  2139 					lda edx
  2140 					add ztmp
  2141 					sta edx
  2142 					lda edx+1
  2143 					adc ztmp+1
  2144 					sta edx+1
  2145 					lda edx+2
  2146 					adc ztmp+2
  2147 					sta edx+2
  2148 					lda edx+3
  2149 					adc ztmp+3
  2150 					sta edx+3
  2151
  2152 					rts
  2153 				.endp
  2154
  2155
  2156 2CDB			.proc	@trunc
  2157
  2158 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2159 					spl
  2160 					jsr negCARD
  2161
  2162 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2163 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2164 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2165 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2166
  2167 					tya
  2168 					spl
  2169 					jsr negCARD
  2170
  2171 					rts
  2172 				.endp
  2173
  2174
  2175 2CDB			.proc	@round
  2176
  2177 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2178 					spl
  2179 					jsr negCARD
  2180
  2181 					lda :STACKORIGIN,x
  2182 				//	add #$80
  2183 					cmp #$80
  2184 					lda :STACKORIGIN+STACKWIDTH,x
  2185 					adc #0
  2186 					sta :STACKORIGIN,x
  2187 					lda :STACKORIGIN+STACKWIDTH*2,x
  2188 					adc #0
  2189 					sta :STACKORIGIN+STACKWIDTH,x
  2190 					lda :STACKORIGIN+STACKWIDTH*3,x
  2191 					adc #0
  2192 					sta :STACKORIGIN+STACKWIDTH*2,x
  2193
  2194 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2195
  2196 					tya
  2197 					spl
  2198 					jsr negCARD
  2199
  2200 					rts
  2201 				.endp
  2202
  2203
  2204 2CDB			.proc	@frac
  2205
  2206 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2207 					spl
  2208 					jsr negCARD
  2209
  2210 					lda #$00
  2211 					sta :STACKORIGIN+STACKWIDTH,x
  2212 					sta :STACKORIGIN+STACKWIDTH*2,x
  2213 					sta :STACKORIGIN+STACKWIDTH*3,x
  2214
  2215 					tya
  2216 					spl
  2217 					jsr negCARD
  2218
  2219 					rts
  2220 				.endp
  2221
  2222
  2223 2CDB			.proc	@int
  2224
  2225 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2226 					spl
  2227 					jsr negCARD
  2228
  2229 					lda #$00
  2230 					sta :STACKORIGIN,x
  2231
  2232 					tya
  2233 					spl
  2234 					jsr negCARD
  2235
  2236 					rts
  2237 				.endp
  2238
  2239
  2240 				;----------------------------;
  2241 				; Biblioteka procedur        ;
  2242 				; graficznych                ;
  2243 				;----------------------------;
  2244 				; Autorzy:                   ;
  2245 				;  Slawomir 'SERO' Ritter,   ;
  2246 				;  Jakub Cebula,             ;
  2247 				;  Winfried Hofacker         ;
  2248 				;----------------------------;
  2249 				; Wersja:1.1 DATA:09.01.2008 ;
  2250 				;----------------------------;
  2251
  2252 = 0003			@open	= $03		; Otworz kanal
  2253 = 000C			@close	= $0c		; Zamknij kanal
  2254
  2255 = 0007			@IDget	= $07		; Narysuj punkt
  2256 = 0009			@IDput	= $09		; Narysuj punkt
  2257 = 0011			@IDdraw	= $11		; Narysuj linie
  2258 = 0012			@IDfill	= $12		; Wypelnij obszar
  2259
  2260
  2261 				;------------------------;
  2262 				;Wy:.Y-numer bledu (1-OK);
  2263 				;   f(N)=1-wystapil blad ;
  2264 				;------------------------;
  2265 2CDB			.proc	@COMMAND
  2266
  2267 					ldx	#$00
  2268 2CDB			scrchn	equ *-1
  2269
  2270 					sta	iocom,x
  2271
  2272 					lda	#$00
  2273 2CDB			colscr	equ *-1
  2274 					sta	atachr
  2275
  2276 					jmp	ciov
  2277 				.endp
  2278
  2279 				;------------------------;
  2280 				; Ustaw tryb ekranu      ;
  2281 				;------------------------;
  2282 				;We:.X-numer kanalu      ;
  2283 				;      (normalnie 0)     ;
  2284 				;   .Y-numer trybu (O.S.);
  2285 				;   .A-Ustawiony bit nr :;
  2286 				;     5-Nie kasowanie    ;
  2287 				;       pamieci ekranu   ;
  2288 				;     4-Obecnosc okna    ;
  2289 				;       tekstowego       ;
  2290 				;     2-Odczyt z ekranu  ;
  2291 				;------------------------;
  2292 				;Wy:SCRCHN-numer kanalu  ;
  2293 				;  .Y-numer bledu (1-OK) ;
  2294 				;   f(N)=1 wystapil blad ;
  2295 				;------------------------;
  2296 2CDB			@GRAPHICS .proc (.byte x,y,a) .reg
  2297
  2298 					sta	byte1
  2299 					sty	byte2
  2300
  2301 					stx	@COMMAND.scrchn
  2302
  2303 					lda	#@close
  2304 					jsr	xcio
  2305
  2306 					lda	#0		; =opcje
  2307 2CDB			byte1	equ	*-1
  2308 					ora	#8		; +zapis na ekranie
  2309 					sta	ioaux1,x
  2310
  2311 					lda	#0
  2312 2CDB			byte2	equ	*-1
  2313 					sta	ioaux2,x	;=nr.trybu
  2314
  2315 					mwa	#sname	ioadr,x
  2316
  2317 					lda	#@open
  2318
  2319 2CDB			xcio	sta iocom,x
  2320 					jmp ciov
  2321
  2322 2CDB			sname	dta c'S:',$9b
  2323
  2324 					.endp
  2325
  2326
  2327 2CDB			.proc	@ata2int
  2328 				        asl
  2329 				        php
  2330 				        cmp #2*$60
  2331 				        bcs @+
  2332 				        sbc #2*$20-1
  2333 				        bcs @+
  2334 				        adc #2*$60
  2335 2CDB			@       plp
  2336 				        ror
  2337 					rts
  2338 				.endp
  2339
  2340
  2341 				/*
  2342 				  PUT CHAR
  2343
  2344 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2345 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2346 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2347
  2348 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2349 				  JSR PUTCHR.
  2350 				*/
  2350
  2351
  2352 2CDB			.proc	@putchar (.byte a) .reg
  2353
  2354 2CDB 2C DB 2C		vbxe	bit *
  2355
  2356 2CDE A2 00			ldx #$00
  2357 					.ifdef MAIN.CRT.TextAttr
  2358 2CE0 0D F7 2D			ora MAIN.CRT.TextAttr
  2359 					.endif
  2360 2CE3 A8				tay
  2361 2CE4 BD 47 03			lda icputb+1,x
  2362 2CE7 48				pha
  2363 2CE8 BD 46 03			lda icputb,x
  2364 2CEB 48				pha
  2365 2CEC 98				tya
  2366
  2367 2CED 60				rts
  2368
  2369 				.endp
  2370
  2371
  2372 				/*
  2373 				  GETLINE
  2374
  2375 				  Program czeka, az uzytkownik wpisze ciag znakï¿½w z klawiatury i nacisnie klawisz RETURN.
  2376 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2377 				  (odczyt jest robiony z edytora ekranowego).
  2378
  2379 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2380 				  do rejestrï¿½w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2381
  2382 				*/
  2382
  2383
  2384 2CEE			.proc	@GetLine
  2385
  2386 					stx @sp
  2387
  2388 					ldx #0
  2389
  2390 					stx MAIN.SYSTEM.EoLn
  2391
  2392 					mwa	#@buf+1	icbufa,x
  2393
  2394 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2395
  2396 					mva	#$05	iccmd,x
  2397
  2398 					jsr	ciov
  2399
  2400 					dew icbufl
  2401 					mva icbufl @buf			; length
  2402
  2403 					ldx @buf+1
  2404 					cpx #EOL
  2405 					bne skp
  2406
  2407 					ldx #TRUE
  2408 					stx MAIN.SYSTEM.EoLn
  2409 2CEE			skp
  2410 					ldx #0
  2411 2CEE			@sp	equ *-1
  2412
  2413 					rts
  2414 				.endp
  2415
  2416
  2417 2CEE			.proc	@GetKey
  2418
  2419 2CEE AD FC 02		getk	lda kbcodes	; odczytaj kbcodes
  2420 2CF1 C9 FF			cmp #255		; czy jest znak?
  2421 2CF3 F0 F9			beq getk	; nie: czekaj
  2422 2CF5 A0 FF			ldy #255		; daj znaï¿½, ï¿½e klawisz
  2423 2CF7 8C FC 02			sty kbcodes	; zostaï¿½ odebrany
  2424 2CFA A8				tay		; kod klawisza jako indeks
  2425 2CFB B1 79			lda (keydef),y	; do tablicy w ROM-ie
  2426
  2427 2CFD 60				rts
  2428 				.endp
  2429
  2430
  2431 2CFE			.proc	@moveSTRING (.word ya) .reg
  2432
  2433 2CFE 85 8A			sta @move.dst
  2434 2D00 84 8B			sty @move.dst+1
  2435
  2436 2D02 B5 98 85 86			mva :STACKORIGIN,x @move.src
  2437 2D06 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2438
  2439 2D0A A0 00			ldy #$00
  2440 2D0C B1 86			lda (@move.src),y
  2441 2D0E 18 69 01			add #1
  2442 2D11 85 82			sta @move.cnt
  2443 2D13 90 01			scc
  2444 2D15 C8				iny
  2445 2D16 84 83			sty @move.cnt+1
  2446
  2447 2D18 4C 46 2D			jmp @move
  2448 				.endp
  2449
  2450
  2451 2D1B			.proc	@moveSTRING_1 (.word ya) .reg
  2452
  2453 					sta @move.dst
  2454 					sty @move.dst+1
  2455
  2456 					mva :STACKORIGIN,x @move.src
  2457 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2458
  2459 					ldy #$00
  2460 					lda (@move.src),y
  2461 				;	add #1
  2462 					sta @move.cnt
  2463 					sty @move.cnt+1
  2464
  2465 					inw @move.src
  2466
  2467 					jmp @move
  2468 				.endp
  2469
  2470
  2471 				; Ullrich von Bassewitz, 2003-08-20
  2472 				; Performance increase (about 20%) by
  2473 				; Christian Krueger, 2009-09-13
  2474
  2475 2D1B			.proc	@moveu		; assert Y = 0
  2476
  2477 = 0086			ptr1	= edx
  2478 = 008A			ptr2	= ecx
  2479 = 0082			ptr3	= eax
  2480
  2481 2D1B 8E 44 2D			stx @sp
  2482
  2483 2D1E A0 00			ldy	#0
  2484
  2485 2D20 A6 83			ldx     ptr3+1		; Get high byte of n
  2486 2D22 F0 13			beq     L2		; Jump if zero
  2487
  2488 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2489 					LDA     (PTR1),Y	
  2490 					STA     (PTR2),Y
  2491 					INY
  2492 					.ENDR
  2492 					.endr
Source: REPT
  2489 2D24 B1 86			LDA     (PTR1),Y	
  2489 2D26 91 8A			STA     (PTR2),Y
  2489 2D28 C8				INY
  2489 2D29 B1 86			LDA     (PTR1),Y	
  2489 2D2B 91 8A			STA     (PTR2),Y
  2489 2D2D C8				INY
Source: cpu6502.asm
  2493
  2494 2D2E D0 F4			bne     L1
  2495 2D30 E6 87			inc     ptr1+1
  2496 2D32 E6 8B			inc     ptr2+1
  2497 2D34 CA				dex			; Next 256 byte block
  2498 2D35 D0 ED			bne	L1		; Repeat if any
  2499
  2500 					; the following section could be 10% faster if we were able to copy
  2501 					; back to front - unfortunately we are forced to copy strict from
  2502 					; low to high since this function is also used for
  2503 					; memmove and blocks could be overlapping!
  2504 					; {
  2505 2D37			L2:				; assert Y = 0
  2506 2D37 A6 82			ldx     ptr3		; Get the low byte of n
  2507 2D39 F0 08			beq     done		; something to copy
  2508
  2509 2D3B B1 86		L3:     lda     (ptr1),Y	; copy a byte
  2510 2D3D 91 8A			sta     (ptr2),Y
  2511 2D3F C8				iny
  2512 2D40 CA				dex
  2513 2D41 D0 F8			bne     L3
  2514
  2515 					; }
  2516
  2517 2D43 A2 00		done	ldx #0
  2518 = 2D44			@sp	equ *-1
  2519 2D45 60				rts
  2520 				.endp
  2521
  2522
  2523 2D46			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2524
  2525 = 0086			ptr1	= edx
  2526 = 008A			ptr2	= ecx
  2527 = 0082			ptr3	= eax
  2528
  2529 = 0086			src	= ptr1
  2530 = 008A			dst	= ptr2
  2531 = 0082			cnt	= ptr3
  2532
  2533 2D46 A5 8B C5 87 D0 04 + 	cpw ptr2 ptr1
  2534 2D50 B0 03			scs
  2535 2D52 4C 1B 2D			jmp @moveu
  2536
  2537 2D55 8E 99 2D			stx @sp
  2538
  2539 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2540
  2541 2D58 A5 87			lda     ptr1+1
  2542 2D5A 18 65 83			add     ptr3+1
  2543 2D5D 85 87			sta     ptr1+1
  2544
  2545 2D5F A5 8B			lda     ptr2+1
  2546 2D61 18 65 83			add     ptr3+1
  2547 2D64 85 8B			sta     ptr2+1
  2548
  2549 				; handle fractions of a page size first
  2550
  2551 2D66 A4 82			ldy     ptr3		; count, low byte
  2552 2D68 D0 06			bne     @entry		; something to copy?
  2553 2D6A F0 0B			beq     PageSizeCopy	; here like bra...
  2554
  2555 2D6C			@copyByte:
  2556 2D6C B1 86			lda     (ptr1),y
  2557 2D6E 91 8A			sta     (ptr2),y
  2558 2D70			@entry:
  2559 2D70 88				dey
  2560 2D71 D0 F9			bne     @copyByte
  2561 2D73 B1 86			lda     (ptr1),y	; copy remaining byte
  2562 2D75 91 8A			sta     (ptr2),y
  2563
  2564 2D77			PageSizeCopy:			; assert Y = 0
  2565 2D77 A6 83			ldx     ptr3+1		; number of pages
  2566 2D79 F0 1D			beq     done		; none? -> done
  2567
  2568 2D7B			@initBase:
  2569 2D7B C6 87			dec     ptr1+1		; adjust base...
  2570 2D7D C6 8B			dec     ptr2+1
  2571 2D7F 88				dey			; in entry case: 0 -> FF
  2572 2D80 B1 86			lda     (ptr1),y	; need to copy this 'intro byte'
  2573 2D82 91 8A			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2574 2D84 88				dey			; FF ->FE
  2575 2D85			@copyBytes:
  2576 					.rept 2		; Unroll this a bit to make it faster...
  2577 					LDA     (PTR1),Y
  2578 					STA     (PTR2),Y
  2579 					DEY
  2580 					.ENDR
  2580 					.endr
Source: REPT
  2577 2D85 B1 86			LDA     (PTR1),Y
  2577 2D87 91 8A			STA     (PTR2),Y
  2577 2D89 88				DEY
  2577 2D8A B1 86			LDA     (PTR1),Y
  2577 2D8C 91 8A			STA     (PTR2),Y
  2577 2D8E 88				DEY
Source: cpu6502.asm
  2581 2D8F			@copyEntry:			; in entry case: 0 -> FF
  2582 2D8F D0 F4			bne     @copyBytes
  2583 2D91 B1 86			lda     (ptr1),y	; Y = 0, copy last byte
  2584 2D93 91 8A			sta     (ptr2),y
  2585 2D95 CA				dex			; one page to copy less
  2586 2D96 D0 E3			bne     @initBase	; still a page to copy?
  2587
  2588 2D98 A2 00		done	ldx #0
  2589 = 2D99			@sp	equ *-1
  2590 2D9A 60				rts
  2591 				.endp
  2592
  2593
  2594 				; Ullrich von Bassewitz, 29.05.1998
  2595 				; Performance increase (about 20%) by
  2596 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2597
  2598 2D9B			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2599
  2600 = 0086			ptr1 = edx
  2601 = 008A			ptr3 = ecx
  2602 = 0082			ptr2 = eax
  2603
  2604 2D9B 8E E2 2D			stx @sp
  2605
  2606 2D9E A6 82			ldx ptr2
  2607
  2608 2DA0 A0 00			ldy #0
  2609
  2610 2DA2 46 8B		        lsr	ptr3+1          ; divide number of
  2611 2DA4 66 8A		        ror	ptr3            ; bytes by two to increase
  2612 2DA6 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2613 2DA8			oddCount:
  2614 								; y is still 0 here
  2615 2DA8 8A			        txa			; restore fill value
  2616 2DA9 91 86		        sta	(ptr1),y	; save value and increase
  2617 2DAB E6 86		        inc	ptr1		; dest. pointer
  2618 2DAD D0 02		        bne	evenCount
  2619 2DAF E6 87		        inc	ptr1+1
  2620 2DB1			evenCount:
  2621 2DB1 A5 86			lda	ptr1		; build second pointer section
  2622 2DB3 18				clc
  2623 2DB4 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2624 2DB6 85 82			sta     ptr2
  2625 2DB8 A5 87			lda     ptr1+1
  2626 2DBA 65 8B			adc     ptr3+1
  2627 2DBC 85 83			sta     ptr2+1
  2628
  2629 2DBE 8A			        txa			; restore fill value
  2630 2DBF A6 8B		        ldx	ptr3+1		; Get high byte of n
  2631 2DC1 F0 13		        beq	L2		; Jump if zero
  2632
  2633 				; Set 256/512 byte blocks
  2634 								; y is still 0 here
  2635 				L1:	.rept 2		; Unroll this a bit to make it faster
  2636 					STA	(PTR1),Y	
  2637 					STA	(PTR2),Y	
  2638 					INY
  2639 					.ENDR
  2639 					.endr
Source: REPT
  2636 2DC3 91 86			STA	(PTR1),Y	
  2636 2DC5 91 82			STA	(PTR2),Y	
  2636 2DC7 C8				INY
  2636 2DC8 91 86			STA	(PTR1),Y	
  2636 2DCA 91 82			STA	(PTR2),Y	
  2636 2DCC C8				INY
Source: cpu6502.asm
  2640 2DCD D0 F4		        bne	L1
  2641 2DCF E6 87		        inc	ptr1+1
  2642 2DD1 E6 83		        inc	ptr2+1
  2643 2DD3 CA			        dex                     ; Next 256 byte block
  2644 2DD4 D0 ED		        bne	L1              ; Repeat if any
  2645
  2646 				; Set the remaining bytes if any
  2647
  2648 2DD6 A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2649 2DD8 F0 07			beq	leave           ; something to set? No -> leave
  2650
  2651 2DDA 88			L3:	dey
  2652 2DDB 91 86			sta	(ptr1),y	; set bytes in low
  2653 2DDD 91 82			sta	(ptr2),y	; and high section
  2654 2DDF D0 F9			bne     L3		; flags still up to date from dey!
  2655
  2656 2DE1 A2 00		leave	ldx #0
  2657 = 2DE2			@sp	equ *-1
  2658 2DE3 60				rts			; return
  2659 				.endp
  2660
  2661
  2662 				/*
  2663 				 add strings
  2664 				 result -> @buf
  2665 				*/
  2665
  2666 2DE4			.proc	@addString(.word ya) .reg
  2667
  2668 					sta ztmp
  2669 					sty ztmp+1
  2670
  2671 					stx @sp
  2672
  2673 					ldx @buf
  2674 					inx
  2675 					beq stop
  2676
  2677 					ldy #0
  2678 					lda (ztmp),y
  2679 					sta ile
  2680 					beq stop
  2681
  2682 					iny
  2683
  2684 2DE4			load	lda (ztmp),y
  2685 					sta @buf,x
  2686
  2687 					iny
  2688 					inx
  2689 					beq stop
  2690 					dec ile
  2691 					bne load
  2692
  2693 2DE4			stop	dex
  2694 					stx @buf
  2695
  2696 					ldx #0
  2697 2DE4			@sp	equ *-1
  2698 					rts
  2699
  2700 2DE4			ile	brk
  2701 				.endp
  2702
  2703
  2704 				/* ----------------------------------------------------------------------- */
  2705
  2706
  2707 2DE4			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2708
  2709 					jsr swap
  2710
  2711 					adw spoint ztmp+2
  2712
  2713 					rts
  2714
  2715 2DE4			swap	txa:pha
  2716
  2717 					mwa spoint bp2
  2718
  2719 					ldx #0
  2720 					ldy #0
  2721
  2722 2DE4			loop	cpy ztmp+2
  2723 					bne @+
  2724 					cpx ztmp+3
  2725 					beq stop
  2726
  2727 2DE4			@	lda (bp2),y
  2728 					pha
  2729
  2730 					lda (ztmp),y
  2731 					sta (bp2),y
  2732
  2733 					pla
  2734 					sta (ztmp),y
  2735
  2736 					iny
  2737 					bne loop
  2738
  2739 					inc ztmp+1
  2740 					inc bp2+1
  2741 					inx
  2742
  2743 					jmp loop
  2744
  2745 2DE4			stop	pla:tax
  2746
  2747 					rts
  2748
  2749 2DE4			spoint	dta a(PROGRAMSTACK)
  2750 				.endp
  2751
  2752
  2753 2DE4			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2754
  2755 					sbw @AllocMem.spoint ztmp+2
  2756
  2757 					jmp @AllocMem.swap
  2758 				.endp
  2759
  2760
  2761 				/* ----------------------------------------------------------------------- */
  2762
  2763
  2764 2DE4			.proc	@vbxe_detect
  2765
  2766 					ldy #.sizeof(detect)-1
  2767 					mva:rpl copy,y detect,y-
  2768
  2769 					jmp detect
  2770
  2771 2DE4			copy
  2772 0400				.local	detect,@buf
  2773 				;
  2774 				; 2009 by KMK/DLT
  2775 				;
  2776 					lda #0
  2777 					sta fxptr
  2778
  2779 				        lda #$d6
  2780 				        sta fxptr+1
  2781 				        ldy #FX_MEMB
  2782 				        jsr ?clr
  2783
  2784 				        jsr ?try
  2785 				        bcc ok
  2786
  2787 				        inc fxptr+1
  2788
  2789 					jsr ?try
  2790 					bcc ok
  2791
  2792 					lda #0
  2793 					sta fxptr+1
  2794 					rts
  2795
  2796 0400			?try    ldx $4000
  2797 				        jsr ?chk
  2798 				        bcc ?ret
  2799 				        inx
  2800 				        stx $4000
  2801 				        jsr ?chk
  2802 				        dec $4000
  2803 0400			?ret    rts
  2804
  2805 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2806 					lda	(fxptr),y
  2807 					rts
  2808
  2809 0400			?chk    lda #$80
  2810 				        jsr _vbxe_write
  2811 				        cpx $4000
  2812 				        bne ?fnd
  2813 				        sec
  2814 0400			        .byte $24
  2815 0400			?fnd    clc
  2816 0400			?clr    lda #$00
  2817 0400			_vbxe_write
  2818 				        sta (fxptr),y
  2819 				        rts
  2820
  2821 				/*
  2822 					lda	#0
  2823 					ldx	#0xd6
  2824 					sta	0xd640			; make sure it isn't coincidence
  2825 					lda	0xd640
  2826 					cmp	#0x10			; do we have major version here?
  2827 					beq	VBXE_Detected		; if so, then VBXE is detected
  2828 					lda	#0
  2829 					inx
  2830 					sta	0xd740			; no such luck, try other location
  2831 					lda	0xd740
  2832 					cmp	#0x10
  2833 					beq	VBXE_Detected
  2834 					ldx 	#0  			; not here, so not present or FX core version too low
  2835 					stx	fxptr+1
  2836 					stx	fxptr
  2837
  2838 					sec
  2839 					rts
  2840
  2841 				VBXE_Detected
  2842 					stx	fxptr+1
  2843 					lda	#0
  2844 					sta	fxptr
  2845
  2846 					ldy	#VBXE_MINOR		; get core minor version
  2847 					lda	(fxptr),y
  2848
  2849 					clc
  2850 					rts	 			; x - page of vbxe
  2851 				*/
  2851
  2852
  2853 					.endl
  2854
  2855 				.endp
  2856
  2857
  2858 2DE4			.proc	@setxdl(.byte a) .reg
  2859
  2860 					asl @
  2861 					sta idx
  2862
  2863 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2864
  2865 					ldy #0
  2866 2DE4			idx	equ *-1
  2867
  2868 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2869 					and msk,y
  2870 					ora val,y
  2871 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2872
  2873 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2874 					and msk+1,y
  2875 					ora val+1,y
  2876 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2877
  2878 					fxs FX_MEMS #0
  2879 					rts
  2880
  2881 2DE4			msk	.array [6] .word
  2882 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2883 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2884 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2885 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2886 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2887 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2888 					.enda
  2889
  2890 2DE4			val	.array [6] .word
  2891 					[e@xdl.mapon]  = XDLC_MAPON
  2892 					[e@xdl.mapoff] = XDLC_MAPOFF
  2893 					[e@xdl.ovron]  = XDLC_GMON
  2894 					[e@xdl.ovroff] = XDLC_OVOFF
  2895 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2896 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2897 					.enda
  2898
  2899 				.endp
  2900
  2901
  2902 2DE4			.proc	@vbxe_init
  2903
  2904 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2905 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2906
  2907 					ldx #.sizeof(s@xdl)-1
  2908 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2909
  2910 					jsr cmapini		; init color map
  2911
  2912 					fxsa FX_P1		; A = 0
  2913 					fxsa FX_P2
  2914 					fxsa FX_P3
  2915
  2916 					fxsa FX_IRQ_CONTROL
  2917 					fxsa FX_BLITTER_START
  2918
  2919 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2920 					fxsa FX_XDL_ADR1
  2921 					fxsa FX_XDL_ADR2
  2922
  2923 					sta colpf0s
  2924
  2925 					fxs FX_P0 #$ff
  2926
  2927 					mwa #@vbxe_cmap @putchar.vbxe+1
  2928 					mva #{jsr*} @putchar.vbxe
  2929
  2930 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2931
  2932 					rts
  2933
  2934 2DE4			cmapini	lda colpf1s
  2935 					and #$0f
  2936 					sta colpf1s
  2937
  2938 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2939 					sta ztmp
  2940
  2941 					mva #4 ztmp+1
  2942
  2943 2DE4			loop	fxs FX_MEMS ztmp
  2944
  2945 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2946 					sta bp+1
  2947
  2948 					ldx #16
  2949 					ldy #0
  2950
  2951 2DE4			lop	mva #$00	(bp),y+
  2952 					mva colpf1s	(bp),y+
  2953 					mva colpf2s	(bp),y+
  2954 					mva #%00010000	(bp),y+		; overlay palette #1
  2955 					bne lop
  2956
  2957 					inc bp+1
  2958 					dex
  2959 					bne lop
  2960
  2961 					inc ztmp
  2962
  2963 					dec ztmp+1
  2964 					bne loop
  2965
  2966 					fxs FX_MEMS #$00		; disable VBXE BANK
  2967 					rts
  2968
  2969 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2970 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2971 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2972 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2973 					0, 0, 7, 7, %00010001, $ff)
  2973 2DE4			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2974 				.endp
  2975
  2976
  2977 2DE4			.proc	@vbxe_cmap
  2978
  2979 					pha
  2980
  2981 					cmp #eol
  2982 					beq stop
  2983
  2984 					cmp #$7d		; clrscr
  2985 					bne skp
  2986
  2987 					jsr @vbxe_init.cmapini
  2988 					jmp stop
  2989
  2990 2DE4			skp	lda rowcrs
  2991 					pha
  2992 2DE4				:4 lsr @
  2993 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2994 					fxsa FX_MEMS
  2995
  2996 					pla
  2997 					and #$0f
  2998 					add >MAIN.SYSTEM.VBXE_WINDOW
  2999 					sta bp+1
  3000
  3001 					lda colcrs
  3002 					asl @
  3003 					asl @
  3004 					tay
  3005 					mva colpf0s (bp),y
  3006 					iny
  3007 					mva colpf1s (bp),y
  3008 					iny
  3009 					mva colpf2s (bp),y
  3010
  3011 					fxs FX_MEMS #$00
  3012
  3013 2DE4			stop	pla
  3014
  3015 					rts
  3016 				.endp
  3017
  3018
  3019 				/* ----------------------------------------------------------------------- */
  3020
  3021
  3022 				/*
  3023 				.proc	@cmdline (.byte a) .reg
  3024
  3025 					stx @sp
  3026
  3027 					sta idpar
  3028
  3029 					lda #0
  3030 					sta parno
  3031
  3032 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3033 					lsr
  3034 					bcc _no_command_line
  3035
  3036 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3037 					cmp #$c0
  3038 					bcs _no_command_line
  3039
  3040 					ldy #$03
  3041 					lda (dosvec),y
  3042 					cmp #{jmp}
  3043 					bne _no_command_line
  3044
  3045 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3046 					lda (dosvec),y
  3047 					sta lbuf
  3048 					iny
  3049 					lda (dosvec),y
  3050 					sta hbuf
  3051
  3052 					adw dosvec #3 zcr
  3053
  3054 				loop	lda #0
  3055 					sta @buf
  3056
  3057 					jsr $ffff
  3058 				zcr	equ *-2
  3059 					beq stop
  3060
  3061 					lda idpar
  3062 					bne skp
  3063
  3064 					ldy #33			; ParamStr(0)
  3065 				_par0	lda (dosvec),y
  3066 					sta @buf-33+1,y
  3067 					iny
  3068 					cpy #36
  3069 					bne _par0
  3070
  3071 					lda #3
  3072 					sta @buf
  3073 					bne stop
  3074
  3075 				skp	ldy #36
  3076 				_cp	lda (dosvec),y
  3077 					sta @buf-36+1,y
  3078 					iny
  3079 					cmp #$9b
  3080 					bne _cp
  3081
  3082 					tya
  3083 					sub #37
  3084 					sta @buf
  3085
  3086 					inc parno
  3087 					lda #0
  3088 				parno	equ *-1
  3089 					cmp #0
  3090 				idpar	equ *-1
  3091
  3092 					bne loop
  3093
  3094 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3095 					lda #0
  3096 				lbuf	equ *-1
  3097 					sta (dosvec),y
  3098 					iny
  3099 					lda #0
  3100 				hbuf	equ *-1
  3101 					sta (dosvec),y
  3102
  3103 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3104
  3105 					lda parno
  3106
  3107 					ldx #0
  3108 				@sp	equ *-1
  3109 					rts
  3110 				.endp
  3111 				*/
  3111
  3112
  3113
  3114 2DE4			.proc	@CmdLine (.byte a) .reg
  3115
  3116 					stx @sp
  3117
  3118 					sta idpar
  3119
  3120 					lda #0
  3121 					sta parno
  3122 					sta loop+1
  3123
  3124 					lda	#{jsr*}
  3125 					sta	res
  3126
  3127 				; Get filename from SpartaDOS...
  3128 2DE4			get_param
  3129 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3130 					lsr
  3131 					bcc no_sparta
  3132
  3133 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3134 					cmp #$c0
  3135 					bcs no_sparta
  3136
  3137 					ldy #$03
  3138 					lda (dosvec),y
  3139 					cmp #{jmp}
  3140 					bne no_sparta
  3141
  3142 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3143 					lda (dosvec),y
  3144 					sta lbuf
  3145 					iny
  3146 					lda (dosvec),y
  3147 					sta hbuf
  3148
  3149 					adw dosvec #33 tmp
  3150
  3151 					ldy #0
  3152 2DE4			fnm	lda (tmp),y
  3153 					iny
  3154 					cmp #$9b
  3155 					bne fnm
  3156
  3157 					tya			; remove .COM
  3158 					sub #5
  3159 					tay
  3160 					lda #0
  3161 					sta (tmp),y
  3162 					tay
  3163
  3164 					lda	#3
  3165 					sta	loop+1
  3166 					add	dosvec
  3167 					sta	get_adr
  3168 					lda	#0
  3169 					adc	dosvec+1
  3170 					sta	get_adr+1
  3171
  3172 					jmp	_ok
  3173
  3174 2DE4			no_sparta
  3175 					mwa #next get_adr
  3176
  3177 					lda	#{bit*}
  3178 					sta	res
  3179
  3180 				; ... or channel #0
  3181 					lda	MAIN.IOCB@COPY+2	; command
  3182 					cmp	#5			; read line
  3183 					bne	_no_command_line
  3184 					lda	MAIN.IOCB@COPY+3	; status
  3185 					bmi	_no_command_line
  3186 				; don't assume the line is EOL-terminated
  3187 				; DOS II+/D overwrites the EOL with ".COM"
  3188 				; that's why we rely on the length
  3189 					lda	MAIN.IOCB@COPY+9	; length hi
  3190 					bne	_no_command_line
  3191 					ldx	MAIN.IOCB@COPY+8	; length lo
  3192 					beq	_no_command_line
  3193 					inx:inx
  3194 					stx	arg_len
  3195 				; give access to three bytes before the input buffer
  3196 				; in DOS II+/D the device prompt ("D1:") is there
  3197 					lda	MAIN.IOCB@COPY+4
  3198 					sub	#3
  3199 					sta	tmp
  3200 					lda	MAIN.IOCB@COPY+5
  3201 					sbc	#0
  3202 					sta	tmp+1
  3203
  3204 					lda	#0
  3205 					ldy	#0
  3206 2DE4			arg_len	equ *-1
  3207 					sta	(tmp),y
  3208
  3209
  3210 2DE4			loop	ldy	#0
  3211
  3212 2DE4			_ok	ldx	#0
  3213
  3214 2DE4			lprea	lda	(tmp),y
  3215 					sta	@buf+1,x
  3216
  3217 					beq	stop
  3218
  3219 					cmp	#$9b
  3220 					beq	stop
  3221 					cmp	#' '
  3222 					beq	stop
  3223
  3224 					iny
  3225 					inx
  3226 					cpx #32
  3227 					bne lprea
  3228
  3229 2DE4			stop	lda #0
  3230 2DE4			parno	equ *-1
  3231 					cmp #0
  3232 2DE4			idpar	equ *-1
  3233 					beq found
  3234
  3235 					jsr $ffff		; sty loop+1
  3236 2DE4			get_adr	equ *-2
  3237 					beq found
  3238
  3239 					inc parno
  3240 					bne loop
  3241
  3242 2DE4			found	lda #0	;+$9b
  3243 					sta @buf+1,x
  3244 					stx @buf
  3245
  3246 2DE4			res	jsr sdxres
  3247
  3248 2DE4			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3249
  3250 					lda parno
  3251
  3252 					ldx #0
  3253 2DE4			@sp	equ *-1
  3254 					rts
  3255
  3256
  3257 2DE4			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3258 					lda #0
  3259 2DE4			lbuf	equ *-1
  3260 					sta (dosvec),y
  3261 					iny
  3262 					lda #0
  3263 2DE4			hbuf	equ *-1
  3264 					sta (dosvec),y
  3265 					rts
  3266
  3267
  3268 2DE4			_next	iny
  3269 2DE4			next	lda (tmp),y
  3270 					beq _eol
  3271 					cmp #' '
  3272 					beq _next
  3273
  3274 					cmp #$9b
  3275 					beq _eol
  3276
  3277 					sty loop+1
  3278 					rts
  3279
  3280 2DE4			_eol	lda #0
  3281 					rts
  3282
  3283 				.endp
  3284
  3285
  3286 				/* ----------------------------------------------------------------------- */
  3287
  3288 				/*
  3289 				.proc	@rstsnd
  3290 					lda #0
  3291 					sta $d208
  3292 					sta $d218
  3293
  3294 					ldy #3
  3295 					sty $d20f
  3296 					sty $d21f
  3297 					rts
  3298 				.endp
  3299 				*/
  3299
  3300
  3301 				;	ert (*>$3fff) .and (*<$8000)
  3302
  3303
  3304 				/* ----------------------------------------------------------------------- */
  3305
  3306
  3307 2DE4			.proc	@xmsBank
  3308
  3309 = 0082			ptr3 = eax			; position	(4)
  3310
  3311 					mva ptr3+3 ztmp+1	; position shr 14
  3312 					mva ptr3+2 ztmp
  3313 					lda ptr3+1
  3314
  3315 					.rept 6
  3316 					LSR ZTMP+1
  3317 					ROR ZTMP
  3318 					ROR @
  3319 					.ENDR
  3319 					.endr
Source: REPT
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
Source: cpu6502.asm
  3320
  3321 					tax			; index to bank
  3322
  3323 					lda portb
  3324 					and #1
  3325 					ora main.misc.adr.banks,x
  3326 					sta portb
  3327
  3328 					lda ptr3 		; offset
  3329 					sta ztmp
  3330 					lda ptr3+1
  3331 					and #$3f
  3332 					ora #$40
  3333 					sta ztmp+1
  3334
  3335 					rts
  3336 				.endp
  3337
  3338
  3339 2DE4			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3340
  3341 = 0086			ptr1 = dx	; buffer	(2)
  3342
  3343 = 008A			ptr2 = cx	; count		(2)
  3344 = 008C			pos = cx+2	; position	(2) pointer
  3345
  3346 = 0082			ptr3 = eax	; position	(4)
  3347
  3348 					txa:pha
  3349
  3350 					ldy #0
  3351 					lda (pos),y
  3352 					sta ptr3
  3353 					iny
  3354 					lda (pos),y
  3355 					sta ptr3+1
  3356 					iny
  3357 					lda (pos),y
  3358 					sta ptr3+2
  3359 					iny
  3360 					lda (pos),y
  3361 					sta ptr3+3
  3362
  3363 					lda ptr2+1
  3364 					beq lp2
  3365
  3366 2DE4			lp1	jsr @xmsBank
  3367
  3368 					lda ztmp+1
  3369 					cmp #$7f
  3370 					bne skp
  3371 					lda ztmp
  3372 					beq skp
  3373
  3374 					lda #0
  3375 					jsr nextBank
  3376 					jmp skp2
  3377
  3378 2DE4			skp	ldy #0
  3379 					mva:rne (ztmp),y @buf,y+
  3380
  3381 2DE4			skp2	lda portb
  3382 					and #1
  3383 					ora #$fe
  3384 					sta portb
  3385
  3386 					ldy #0
  3387 					mva:rne @buf,y (dx),y+
  3388
  3389 					inc dx+1	// inc(dx, $100)
  3390
  3391 					inl ptr3+1	// inc(position, $100)
  3392
  3393 					dec ptr2+1
  3394 					bne lp1
  3395
  3396 2DE4			lp2	jsr @xmsBank
  3397
  3398 					lda ztmp+1		; zakonczenie kopiowania
  3399 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3400 					bne skp_
  3401
  3402 					lda ztmp
  3403 					add ptr2
  3404 					bcc skp_
  3405
  3406 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3407 					jsr nextBank
  3408 					jmp skp3
  3409
  3410 2DE4			skp_	ldy #0
  3411 2DE4			mv	lda (ztmp),y
  3412 					sta @buf,y
  3413 					iny
  3414 					cpy ptr2
  3415 					bne mv
  3416
  3417 2DE4			skp3	lda portb
  3418 					and #1
  3419 					ora #$fe
  3420 					sta portb
  3421
  3422 					ldy #0
  3423 2DE4			lp3	lda @buf,y
  3424 					sta (dx),y
  3425 					iny
  3426 					cpy ptr2
  3427 					bne lp3
  3428
  3429 					jmp @xmsUpdatePosition
  3430
  3431 2DE4			.local	nextBank
  3432
  3433 					sta max
  3434
  3435 					mwa ztmp src
  3436
  3437 					ldy #0
  3438 2DE4			mv0	lda $ffff,y
  3439 2DE4			src	equ *-2
  3440 					sta @buf,y
  3441 					iny
  3442 					inc ztmp
  3443 					bne mv0
  3444
  3445 					lda portb
  3446 					and #1
  3447 					ora main.misc.adr.banks+1,x
  3448 					sta portb
  3449
  3450 					ldx #0
  3451 2DE4			mv1	cpy #0
  3452 2DE4			max	equ *-1
  3453 					beq stp
  3454 					lda $4000,x
  3455 					sta @buf,y
  3456 					inx
  3457 					iny
  3458 					bne mv1
  3459 2DE4			stp	rts
  3460 				.endl
  3461
  3462 				.endp
  3463
  3464
  3465 2DE4			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3466
  3467 = 0086			ptr1 = dx	; buffer	(2)
  3468
  3469 = 008A			ptr2 = cx	; count		(2)
  3470 = 008C			pos = cx+2	; position	(2) pointer
  3471
  3472 = 0082			ptr3 = eax	; position	(4)
  3473
  3474 					txa:pha
  3475
  3476 					ldy #0			; przepisz POSITION spod wskaznika
  3477 					lda (pos),y
  3478 					sta ptr3
  3479 					iny
  3480 					lda (pos),y
  3481 					sta ptr3+1
  3482 					iny
  3483 					lda (pos),y
  3484 					sta ptr3+2
  3485 					iny
  3486 					lda (pos),y
  3487 					sta ptr3+3
  3488
  3489 2DE4			lp1	lda portb		; wylacz dodatkowe banki
  3490 					and #1
  3491 					ora #$fe
  3492 					sta portb
  3493
  3494 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3495 					mva:rne (dx),y @buf,y+
  3496
  3497 					jsr @xmsBank		; wlacz dodatkowy bank
  3498
  3499 					lda ptr2+1
  3500 					beq lp2
  3501
  3502 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3503 					cmp #$7f
  3504 					bne skp
  3505 					lda ztmp
  3506 					beq skp
  3507
  3508 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3509 					jsr nextBank
  3510 					jmp skp2
  3511
  3512 2DE4			skp	mva:rne @buf,y (ztmp),y+
  3513
  3514 2DE4			skp2	inc dx+1		// inc(dx, $100)
  3515
  3516 					inl ptr3+1		// inc(position, $100)
  3517
  3518 					dec ptr2+1
  3519 					bne lp1
  3520
  3521 2DE4			lp2	lda ztmp+1		; zakonczenie kopiowania
  3522 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3523 					bne skp_
  3524
  3525 					lda ztmp
  3526 					add ptr2
  3527 					bcc skp_
  3528
  3529 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3530 					jsr nextBank
  3531 					jmp quit
  3532
  3533 2DE4			skp_	ldy #0
  3534 2DE4			lp3	lda @buf,y
  3535 					sta (ztmp),y
  3536
  3537 					iny
  3538 					cpy ptr2
  3539 					bne lp3
  3540
  3541 2DE4			quit	lda portb
  3542 					and #1
  3543 					ora #$fe
  3544 					sta portb
  3545
  3546 					jmp @xmsUpdatePosition
  3547
  3548 2DE4			.local	nextBank
  3549
  3550 					sta max
  3551
  3552 					mwa ztmp dst
  3553
  3554 					ldy #0
  3555 2DE4			mv0	lda @buf,y
  3556 					sta $ffff,y
  3557 2DE4			dst	equ *-2
  3558 					iny
  3559 					inc ztmp
  3560 					bne mv0
  3561
  3562 					lda portb
  3563 					and #1
  3564 					ora main.misc.adr.banks+1,x
  3565 					sta portb
  3566
  3567 					ldx #0
  3568 2DE4			mv1	cpy #0
  3569 2DE4			max	equ *-1
  3570 					beq stp
  3571 					lda @buf,y
  3572 					sta $4000,x
  3573 					inx
  3574 					iny
  3575 					bne mv1
  3576 2DE4			stp	rts
  3577 				.endl
  3578
  3579 				.endp
  3580
  3581
  3582 2DE4			.proc	@xmsAddPosition
  3583
  3584 2DE4				.use @xmsReadBuf
  3585
  3586 					add ptr3
  3587 					sta ptr3
  3588 					lda #$00
  3589 					adc ptr3+1
  3590 					sta ptr3+1
  3591 					lda #$00
  3592 					adc ptr3+2
  3593 					sta ptr3+2
  3594 					lda #$00
  3595 					adc ptr3+3
  3596 					sta ptr3+3
  3597
  3598 					rts
  3599 				.endp
  3600
  3601
  3602 2DE4			.proc	@xmsUpdatePosition
  3603
  3604 2DE4				.use @xmsReadBuf
  3605
  3606 					tya
  3607 					jsr @xmsAddPosition
  3608
  3609 					ldy #0
  3610 					lda ptr3
  3611 					sta (pos),y
  3612 					iny
  3613 					lda ptr3+1
  3614 					sta (pos),y
  3615 					iny
  3616 					lda ptr3+2
  3617 					sta (pos),y
  3618 					iny
  3619 					lda ptr3+3
  3620 					sta (pos),y
  3621
  3622 					pla:tax
  3623 					rts
  3624 				.endp
  3625
  3626
  3627 				/* ----------------------------------------------------------------------- */
  3628
  3629
  3630 2DE4			.proc	@ClrScr
  3631
  3632 					ldx #$00
  3633 					lda #$0c
  3634 					jsr xcio
  3635
  3636 					mwa #ename ioadr,x
  3637
  3638 					mva #$0c ioaux1,x
  3639 					mva #$00 ioaux2,x
  3640
  3641 					lda #$03
  3642
  3643 2DE4			xcio	sta iocom,x
  3644 					jmp ciov
  3645
  3646 2DE4			ename	.byte 'E:',$9b
  3647
  3648 				.endp
  3649
  3650
  3651 				/* ----------------------------------------------------------------------- */
  3652
  3653
  3654 					opt l+
  2854
  2855 				; -----------------------------------------------------------
  2856
  2857 				.macro UNITINITIALIZATION
  2858 				
  2859 					.ifdef MAIN.SYSTEM.@UnitInit
  2860 					jsr MAIN.SYSTEM.@UnitInit
  2861 					eif
  2862 				
  2863 					.ifdef MAIN.ATARI.@UnitInit
  2864 					jsr MAIN.ATARI.@UnitInit
  2865 					eif
  2866 				
  2867 					.ifdef MAIN..@UnitInit
  2868 					jsr MAIN..@UnitInit
  2869 					eif
  2870 				
  2871 					.ifdef MAIN.CRT.@UnitInit
  2872 					jsr MAIN.CRT.@UnitInit
  2873 					eif
  2874 				
  2875 					.ifdef MAIN.RMT.@UnitInit
  2876 					jsr MAIN.RMT.@UnitInit
  2877 					eif
  2878 				
  2879 					.ifdef MAIN..@UnitInit
  2880 					jsr MAIN..@UnitInit
  2881 					eif
  2882 				
  2883 					.ifdef MAIN.B_UTILS.@UnitInit
  2884 					jsr MAIN.B_UTILS.@UnitInit
  2885 					eif
  2886 				
  2887 					.ifdef MAIN..@UnitInit
  2888 					jsr MAIN..@UnitInit
  2889 					eif
  2890 				
  2891 					.ifdef MAIN.B_DL.@UnitInit
  2892 					jsr MAIN.B_DL.@UnitInit
  2893 					eif
  2894 				
  2895 					.ifdef MAIN..@UnitInit
  2896 					jsr MAIN..@UnitInit
  2897 					eif
  2898 				
  2899 					.ifdef MAIN.B_SYSTEM.@UnitInit
  2900 					jsr MAIN.B_SYSTEM.@UnitInit
  2901 					eif
  2902 				.endm
  2903
  2904 					ift .SIZEOF(MAIN.SYSTEM) > 0
  2905 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  2905 				SYSTEM: $210B..$21A8
  2906 					eif
  2907
  2908 					ift .SIZEOF(MAIN.ATARI) > 0
  2909 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  2910 					eif
  2911
  2912 					ift .SIZEOF(MAIN.CRT) > 0
  2913 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
  2913 				CRT: $21A9..$22AB
  2914 					eif
  2915
  2916 					ift .SIZEOF(MAIN.RMT) > 0
  2917 					.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
  2918 					eif
  2919
  2920 					ift .SIZEOF(MAIN.B_UTILS) > 0
  2921 					.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
  2921 				B_UTILS: $22AC..$2302
  2922 					eif
  2923
  2924 					ift .SIZEOF(MAIN.B_DL) > 0
  2925 					.print 'B_DL: ',MAIN.B_DL,'..',MAIN.B_DL+.SIZEOF(MAIN.B_DL)-1
  2926 					eif
  2927
  2928 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  2929 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  2930 					eif
  2931
  2932 					.print 'CODE: ',CODEORIGIN,'..',*-1
  2932 				CODE: $2000..$2DE3
  2933
  2934 2DE4			DATAORIGIN
  2935
  2936 2DE4 28 00 18 00 0C 00 + .by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2937 2DFC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2938 2E14 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2939 2E2C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2940 2E44 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2941 2E5C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2942 2E74 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2943 2E8C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2944 2EA4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2945 2EBC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2946 2ED4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2947 2EEC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2948 2F04 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2949 2F1C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2950 2F34 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2951 2F4C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2952 2F64 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2953 2F7C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2954 2F94 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2955 2FAC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2956 2FC4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2957 2FDC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2958 2FF4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2959 300C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2960 3024 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2961 303C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2962 3054 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2963 306C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2964 3084 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2965 309C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2966 30B4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2967 30CC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2968 30E4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2969 30FC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2970 3114 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2971 312C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2972 3144 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2973 315C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2974 3174 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2975 318C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2976 31A4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2977 31BC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2978 31D4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2979 31EC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2980 3204 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2981 321C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2982 3234 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2983 324C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2984 3264 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2985 327C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2986 3294 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2987 32AC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2988 32C4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2989 32DC 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2990 32F4 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2991 330C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2992 3324 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2993 333C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2994 3354 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2995 336C 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $95 $94 $93 $92 $91 $90
  2996
  2997 = 059F			VARINITSIZE	= *-DATAORIGIN
  2998 = 05A2			VARDATASIZE	= 1442
  2999
  3000 = 3386			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  3001
  3002 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  3002 				DATA: $2DE4..$3386
  3003
  3004 02E0-02E1> DE 20			run START
  3005
  3006 				; -----------------------------------------------------------
  3007
  3008 				.macro	STATICDATA
  3009 				.by  $00 $00 $03 $4C $3A $20 $00 $19  $23 $23 $23 $23 $23 $23 $23 $23  $23 $23 $23 $23 $23 $23 $23 $23
  3010 				.by  $23 $23 $23 $23 $23 $23 $23 $23  $23 $00 $0C $20 $5B $42 $75 $79  $5D $20 $53 $65 $6C $6C $20 $00
  3011 				.by  $04 $20 $55 $45 $43 $00 $28 $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3012 				.by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $00
  3013 				.by  $28 $2F $44 $65 $6C $69 $76 $65  $72 $79 $5F $4C $6F $63 $61 $74  $69 $6F $6E $73 $20 $7C $20 $2E
  3014 				.by  $2E $2F $41 $76 $61 $69 $6C $61  $62 $6C $65 $5F $49 $74 $65 $6D  $73 $00 $28 $5B $20 $43 $75 $74
  3015 				.by  $74 $6C $65 $73 $20 $42 $6C $61  $63 $6B $20 $5D $20 $20 $20 $7C  $20 $63 $6F $6D $6D $6F $64 $69
  3016 				.by  $74 $79 $20 $20 $20 $20 $70 $72  $69 $63 $65 $00 $28 $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3017 				.by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2B $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
  3018 				.by  $2D $2D $2D $2D $2D $00
  3019 				.endm
  3020
  3021 					end
