mads 2.0.8 build 1 (2 Nov 17)
   290 					opt l+
   224 					opt l+
   225
   226 				/* ----------------------------------------------------------------------- */
   227
   228
   229 20DD			.proc	hiBYTE
   230 					lda :STACKORIGIN,x
   231 20DD				:4 lsr @
   232 					sta :STACKORIGIN,x
   233 					rts
   234 				.endp
   235
   236 20DD			.proc	hiWORD
   237 					lda :STACKORIGIN+STACKWIDTH,x
   238 					sta :STACKORIGIN,x
   239 					rts
   240 				.endp
   241
   242 20DD			.proc	hiCARD
   243 					lda :STACKORIGIN+STACKWIDTH*3,x
   244 					sta :STACKORIGIN+STACKWIDTH,x
   245
   246 					lda :STACKORIGIN+STACKWIDTH*2,x
   247 					sta :STACKORIGIN,x
   248 					rts
   249 				.endp
   250
   251
   252 20DD			.proc	movaBX_EAX		; mov [BX], EAX
   253 20DD				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   254 					rts
   255 				.endp
   256
   257 				/*
   258 				.proc	@pushBYTE
   259 					adc :STACKORIGIN+STACKWIDTH,x
   260 					sta bp+1
   261
   262 					mva (bp),y :STACKORIGIN,x
   263
   264 				;	lda #$00
   265 				;	sta :STACKORIGIN+STACKWIDTH,x
   266 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   267 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   268
   269 					rts
   270 				.endp
   271
   272
   273 				.proc	@pullWORD (.word ya) .reg
   274 					add :STACKORIGIN-1,x
   275 					sta bp2
   276 					tya
   277 					adc :STACKORIGIN-1+STACKWIDTH,x
   278 					sta bp2+1
   279
   280 					ldy #$00
   281
   282 					mva :STACKORIGIN,x (bp2),y
   283 					iny
   284 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   285
   286 					rts
   287 				.endp
   288
   289
   290 				.proc	@pullCARD (.word ya) .reg
   291 					add :STACKORIGIN-1,x
   292 					sta bp2
   293 					tya
   294 					adc :STACKORIGIN-1+STACKWIDTH,x
   295 					sta bp2+1
   296
   297 					ldy #$00
   298
   299 					mva :STACKORIGIN,x (bp2),y
   300 					iny
   301 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   302 					iny
   303 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   304 					iny
   305 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   306
   307 					rts
   308 				.endp
   309
   310
   311 				.proc	@pushWORD (.word ya) .reg
   312 					add :STACKORIGIN,x
   313 					sta bp2
   314 					tya
   315 					adc :STACKORIGIN+STACKWIDTH,x
   316 					sta bp2+1
   317
   318 					ldy #$00
   319
   320 					mva (bp2),y :STACKORIGIN,x
   321 					iny
   322 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   323
   324 					rts
   325 				.endp
   326
   327
   328 				.proc	@pushCARD (.word ya) .reg
   329 					add :STACKORIGIN,x
   330 					sta bp2
   331 					tya
   332 					adc :STACKORIGIN+STACKWIDTH,x
   333 					sta bp2+1
   334
   335 					ldy #$00
   336
   337 					mva (bp2),y :STACKORIGIN,x
   338 					iny
   339 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   340 					iny
   341 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   342 					iny
   343 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   344
   345 					rts
   346 				.endp
   347 				*/
   347
   348
   349 20DD			.proc	shlEAX_CL
   350
   351 				;SHORT	jsr @expandToCARD1.SHORT
   352 				;	jmp CARD
   353
   354 				;SMALL	jsr @expandToCARD1.SMALL
   355 				;	jmp CARD
   356
   357 20DD			BYTE	lda #0
   358 					sta :STACKORIGIN-1+STACKWIDTH,x
   359
   360 20DD			WORD	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   362 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   363
   364 20DD			CARD	clc
   365 					ldy :STACKORIGIN,x	; cl
   366 					beq stop
   367 20DD			@	asl :STACKORIGIN-1,x	; eax
   368 					rol :STACKORIGIN-1+STACKWIDTH,x
   369 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   370 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   371 					dey
   372 					bne @-
   373
   374 20DD			stop	rts
   375 				.endp
   376
   377
   378 20DD			.proc	shrAL_CL
   379
   380 				;SHORT	jsr @expandToCARD1.SHORT
   381 				;	jmp shrEAX_CL
   382
   383 20DD			BYTE	ldy :STACKORIGIN,x	; cl
   384 					beq stop
   385 20DD			@	lsr :STACKORIGIN-1,x
   386 					dey
   387 					bne @-
   388
   389 20DD			stop	lda #0
   390 					sta :STACKORIGIN-1+STACKWIDTH,x
   391 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   392 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   393
   394 					rts
   395 				.endp
   396
   397 20DD			.proc	shrAX_CL
   398
   399 				;SMALL	jsr @expandToCARD1.SMALL
   400 				;	jmp shrEAX_CL
   401
   402 20DD			WORD	ldy :STACKORIGIN,x	; cl
   403 					beq stop
   404 20DD			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   405 					ror :STACKORIGIN-1,x
   406 					dey
   407 					bne @-
   408
   409 20DD			stop	lda #0
   410 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   411 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   412
   413 					rts
   414 				.endp
   415
   416 20DD			.proc	shrEAX_CL
   417
   418 					ldy :STACKORIGIN,x	; cl
   419 					beq stop
   420 20DD			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   421 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   422 					ror :STACKORIGIN-1+STACKWIDTH,x
   423 					ror :STACKORIGIN-1,x
   424 					dey
   425 					bne @-
   426
   427 20DD			stop	rts
   428 				.endp
   429
   430 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   431 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   432 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   433
   434 20DD			.proc	addAL_CL
   435
   436 					ldy #0
   437
   438 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   439 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   440
   441 					lda :STACKORIGIN-1,x
   442 					add :STACKORIGIN,x
   443 					sta :STACKORIGIN-1,x
   444 					scc
   445 					iny
   446
   447 					sty :STACKORIGIN-1+STACKWIDTH,x
   448
   449 					rts
   450 				.endp
   451
   452 20DD			.proc	addAX_CX
   453
   454 					ldy #0
   455
   456 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   457
   458 					lda :STACKORIGIN-1,x
   459 					add :STACKORIGIN,x
   460 					sta :STACKORIGIN-1,x
   461
   462 					lda :STACKORIGIN-1+STACKWIDTH,x
   463 					adc :STACKORIGIN+STACKWIDTH,x
   464 					sta :STACKORIGIN-1+STACKWIDTH,x
   465 					scc
   466 					iny
   467
   468 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   469
   470 					rts
   471 				.endp
   472
   473
   474 20DD			.proc	addEAX_ECX
   475 				/*
   476 				SHORT	jsr @expandToCARD.SHORT
   477 					jsr @expandToCARD1.SHORT
   478 					jmp CARD
   479
   480 				SMALL	jsr @expandToCARD.SMALL
   481 					jsr @expandToCARD1.SMALL
   482 				*/
   482
   483 20DD			CARD	lda :STACKORIGIN-1,x
   484 					add :STACKORIGIN,x
   485 					sta :STACKORIGIN-1,x
   486
   487 					lda :STACKORIGIN-1+STACKWIDTH,x
   488 					adc :STACKORIGIN+STACKWIDTH,x
   489 					sta :STACKORIGIN-1+STACKWIDTH,x
   490
   491 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   492 					adc :STACKORIGIN+STACKWIDTH*2,x
   493 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   494
   495 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   496 					adc :STACKORIGIN+STACKWIDTH*3,x
   497 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   498
   499 					rts
   500 				.endp
   501
   502
   503 20DD			.proc	subAL_CL
   504
   505 					ldy #0
   506
   507 					lda :STACKORIGIN-1,x
   508 					sub :STACKORIGIN,x
   509 					sta :STACKORIGIN-1,x
   510 					scs
   511 					dey
   512
   513 					sty :STACKORIGIN-1+STACKWIDTH,x
   514 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   515 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   516
   517 					rts
   518 				.endp
   519
   520 20DD			.proc	subAX_CX
   521
   522 					ldy #0
   523
   524 					lda :STACKORIGIN-1,x		; ax
   525 					sub :STACKORIGIN,x		; cx
   526 					sta :STACKORIGIN-1,x
   527
   528 					lda :STACKORIGIN-1+STACKWIDTH,x
   529 					sbc :STACKORIGIN+STACKWIDTH,x
   530 					sta :STACKORIGIN-1+STACKWIDTH,x
   531 					scs
   532 					dey
   533
   534 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   535 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   536
   537 					rts
   538 				.endp
   539
   540 20DD			.proc	subEAX_ECX
   541
   542 					lda :STACKORIGIN-1,x
   543 					sub :STACKORIGIN,x
   544 					sta :STACKORIGIN-1,x
   545
   546 					lda :STACKORIGIN-1+STACKWIDTH,x
   547 					sbc :STACKORIGIN+STACKWIDTH,x
   548 					sta :STACKORIGIN-1+STACKWIDTH,x
   549
   550 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   551 					sbc :STACKORIGIN+STACKWIDTH*2,x
   552 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   553
   554 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   555 					sbc :STACKORIGIN+STACKWIDTH*3,x
   556 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   557
   558 					rts
   559 				.endp
   560
   561
   562 20DD			.proc	@expandSHORT2SMALL
   563 					ldy #$00
   564 					lda :STACKORIGIN,x
   565 					spl
   566 					dey
   567 					sty :STACKORIGIN+STACKWIDTH,x
   568
   569 					rts
   570 				.endp
   571
   572 20DD			.proc	@expandSHORT2SMALL1
   573 					ldy #$00
   574 					lda :STACKORIGIN-1,x
   575 					spl
   576 					dey
   577 					sty :STACKORIGIN-1+STACKWIDTH,x
   578
   579 					rts
   580 				.endp
   581
   582
   583 20DD			.proc	@expandToCARD
   584
   585 20DD			SMALL	lda :STACKORIGIN+STACKWIDTH,x
   586 					bpl WORD
   587
   588 					lda #$ff
   589 					bne _wo
   590
   591 20DD			WORD	lda #$00
   592 					beq _wo
   593
   594 20DD			SHORT	lda :STACKORIGIN,x
   595 					bpl BYTE
   596
   597 					lda #$ff
   598 					bne _by
   599
   600 20DD			BYTE	lda #$00
   601
   602 20DD			_by	sta :STACKORIGIN+STACKWIDTH,x
   603 20DD			_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   604 20DD			_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   605 					rts
   606 				.endp
   607
   608
   609 20DD			.proc	@expandToCARD1
   610
   611 20DD			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   612 					bpl WORD
   613
   614 					lda #$ff
   615 					bne _wo
   616
   617 20DD			WORD	lda #$00
   618 					beq _wo
   619
   620 20DD			SHORT	lda :STACKORIGIN-1,x
   621 					bpl BYTE
   622
   623 					lda #$ff
   624 					bne _by
   625
   626 20DD			BYTE	lda #$00
   627
   628 20DD			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   629 20DD			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   630 20DD			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   631 					rts
   632 				.endp
   633
   634 				/*
   635 				.proc	@cmpFor_WORD (.word ya) .reg
   636 					sta ztmp
   637 					sty ztmp+1
   638
   639 					ldy #1
   640 					lda (ztmp),y
   641 					cmp :STACKORIGIN+1+STACKWIDTH,x
   642 					bne stop
   643 					dey
   644 					lda (ztmp),y
   645 					cmp :STACKORIGIN+1,x
   646 				stop	rts
   647 				.endp
   648
   649
   650 				.proc	@cmpFor_CARD (.word ya) .reg
   651 					sta ztmp
   652 					sty ztmp+1
   653
   654 					ldy #3
   655 					lda (ztmp),y
   656 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   657 					bne stop
   658 					dey
   659 					lda (ztmp),y
   660 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   661 					bne stop
   662 					dey
   663 					lda (ztmp),y
   664 					cmp :STACKORIGIN+1+STACKWIDTH,x
   665 					bne stop
   666 					dey
   667 					lda (ztmp),y
   668 					cmp :STACKORIGIN+1,x
   669
   670 				stop	rts
   671 				.endp
   672
   673
   674 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   675 					sta ztmp
   676 					sty ztmp+1
   677
   678 					ldy	#0
   679 					lda	(ztmp),y
   680 					sec
   681 					sbc	:STACKORIGIN+1,x
   682 					bne	@cmpFor_INT.L4
   683
   684 					jmp	@cmpFor_INT.L1
   685 				.endp
   686
   687
   688 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   689 					sta ztmp
   690 					sty ztmp+1
   691
   692 					ldy	#1
   693 					lda	(ztmp),y
   694 					sec
   695 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   696 					bne	@cmpFor_INT.L4
   697
   698 					dey
   699 					lda	(ztmp),y
   700 					cmp	:STACKORIGIN+1,x
   701
   702 					jmp	@cmpFor_INT.L1
   703 				.endp
   704
   705
   706 				.proc	@cmpFor_INT(.word ya) .reg
   707 					sta ztmp
   708 					sty ztmp+1
   709
   710 					ldy	#3
   711 					lda	(ztmp),y
   712 					sec
   713 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   714 					bne	L4
   715
   716 					dey
   717 					lda	(ztmp),y
   718 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   719 					bne	L1
   720
   721 					dey
   722 					lda	(ztmp),y
   723 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   724 					bne	L1
   725
   726 					dey
   727 					lda	(ztmp),y
   728 					cmp	:STACKORIGIN+1,x
   729
   730 				L1	beq	L2
   731 					bcs	L3
   732
   733 					lda	#$FF	; Set the N flag
   734 				L2	rts
   735
   736 				L3	lda	#$01	; Clear the N flag
   737 					rts
   738
   739 				L4	bvc	L5
   740 					eor	#$FF	; Fix the N flag if overflow
   741 					ora	#$01	; Clear the Z flag
   742 				L5	rts
   743 				.endp
   744 				*/
   744
   745
   746 				; Piotr Fusik, 15.04.2002
   747 				; originally by Ullrich von Bassewitz
   748
   749 20DD			.proc	cmpSHORTINT
   750 					lda	:STACKORIGIN-1,x
   751 					clv:sec
   752 					sbc	:STACKORIGIN,x
   753 					bne	cmpINT.L4
   754
   755 					jmp	cmpINT.L1
   756 				.endp
   757
   758
   759 20DD			.proc	cmpSMALLINT
   760 					lda	:STACKORIGIN-1+STACKWIDTH,x
   761 					clv:sec
   762 					sbc	:STACKORIGIN+STACKWIDTH,x
   763 					bne	cmpINT.L4
   764
   765 					lda	:STACKORIGIN-1,x
   766 					cmp	:STACKORIGIN,x
   767
   768 					jmp	cmpINT.L1
   769 				.endp
   770
   771
   772 20DD			.proc	cmpINT
   773 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   774 					clv:sec
   775 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   776 					bne	L4
   777
   778 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   779 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   780 					bne	L1
   781
   782 					lda	:STACKORIGIN-1+STACKWIDTH,x
   783 					cmp	:STACKORIGIN+STACKWIDTH,x
   784 					bne	L1
   785
   786 					lda	:STACKORIGIN-1,x
   787 					cmp	:STACKORIGIN,x
   788
   789 20DD			L1	beq	L2
   790 					bcs	L3
   791
   792 					lda	#$FF	; Set the N flag
   793 20DD			L2	rts
   794
   795 20DD			L3	lda	#$01	; Clear the N flag
   796 					rts
   797
   798 20DD			L4	bvc	L5
   799 					eor	#$FF	; Fix the N flag if overflow
   800 					ora	#$01	; Clear the Z flag
   801 20DD			L5	rts
   802 				.endp
   803
   804
   805 20DD			.proc	cmpEAX_ECX
   806 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   807 					cmp :STACKORIGIN+STACKWIDTH*3,x
   808 					bne _done
   809 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   810 					cmp :STACKORIGIN+STACKWIDTH*2,x
   811 					bne _done
   812 20DD			AX_CX
   813 					lda :STACKORIGIN-1+STACKWIDTH,x
   814 					cmp :STACKORIGIN+STACKWIDTH,x
   815 					bne _done
   816 					lda :STACKORIGIN-1,x
   817 					cmp :STACKORIGIN,x
   818
   819 20DD			_done	rts
   820 				.endp
   821
   822
   823 20DD			.proc	cmpSTRING2CHAR
   824
   825 					lda :STACKORIGIN-1,x
   826 					sta ztmp8
   827 					lda :STACKORIGIN-1+STACKWIDTH,x
   828 					sta ztmp8+1
   829
   830 					lda :STACKORIGIN,x
   831 					sta ztmp10
   832
   833 					ldy #0
   834
   835 					lda (ztmp8),y		; if length <> 1
   836 					cmp #1
   837 					bne fail
   838
   839 					iny
   840
   841 20DD			loop	lda (ztmp8),y
   842 					cmp ztmp10
   843 					bne fail
   844
   845 					lda #0
   846 					seq
   847
   848 20DD			fail	lda #$ff
   849
   850 					ldy #1
   851
   852 					cmp #0
   853 					rts
   854 				.endp
   855
   856
   857
   858 20DD			.proc	cmpCHAR2STRING
   859
   860 					lda :STACKORIGIN-1,x
   861 					sta ztmp8
   862
   863 					lda :STACKORIGIN,x
   864 					sta ztmp10
   865 					lda :STACKORIGIN+STACKWIDTH,x
   866 					sta ztmp10+1
   867
   868 					ldy #0
   869
   870 					lda (ztmp10),y		; if length <> 1
   871 					cmp #1
   872 					bne fail
   873
   874 					iny
   875
   876 20DD			loop	lda (ztmp10),y
   877 					cmp ztmp8
   878 					bne fail
   879
   880 					lda #0
   881 					seq
   882
   883 20DD			fail	lda #$ff
   884
   885 					ldy #1
   886
   887 					cmp #0
   888 					rts
   889 				.endp
   890
   891
   892 20DD			.proc	cmpSTRING
   893
   894 					lda :STACKORIGIN-1,x
   895 					sta ztmp8
   896 					lda :STACKORIGIN-1+STACKWIDTH,x
   897 					sta ztmp8+1
   898
   899 					lda :STACKORIGIN,x
   900 					sta ztmp10
   901 					lda :STACKORIGIN+STACKWIDTH,x
   902 					sta ztmp10+1
   903
   904 					ldy #0
   905
   906 					lda (ztmp8),y		; if length1 = 0
   907 					beq fail
   908 					lda (ztmp10),y		; if length2 = 0
   909 					beq fail
   910
   911 					lda (ztmp8),y		; if length1 <> length2
   912 					cmp (ztmp10),y
   913 					bne fail
   914
   915 					sta max
   916
   917 					inw ztmp8
   918 					inw ztmp10
   919
   920 20DD			loop	lda (ztmp8),y
   921 					cmp (ztmp10),y
   922 					bne fail
   923
   924 					iny
   925
   926 					cpy #0
   927 20DD			max	equ *-1
   928 					bne loop
   929
   930 					lda #0
   931 					seq
   932
   933 20DD			fail	lda #$ff
   934
   935 					ldy #1
   936
   937 					cmp #0
   938 					rts
   939 				.endp
   940
   941
   942 20DD			.proc	notaBX
   943
   944 					.rept MAXSIZE
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   946 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					.ENDR
   948 					.endr
Source: REPT
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
   945 					LDA :STACKORIGIN+#*STACKWIDTH,X
   945 					EOR #$FF
   945 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   949
   950 					rts
   951 				.endp
   952
   953
   954 20DD			.proc	notBOOLEAN
   955 					lda :STACKORIGIN,x
   956 					bne _0
   957
   958 					lda #true
   959 					sne
   960
   961 20DD			_0	lda #false
   962 					sta :STACKORIGIN,x
   963
   964 					rts
   965 				.endp
   966
   967
   968 20DD			.proc	negBYTE
   969 					lda #$00
   970 					sub :STACKORIGIN,x
   971 					sta :STACKORIGIN,x
   972
   973 					lda #$00
   974 					sbc #$00
   975 					sta :STACKORIGIN+STACKWIDTH,x
   976
   977 					lda #$00
   978 					sbc #$00
   979 					sta :STACKORIGIN+STACKWIDTH*2,x
   980
   981 					lda #$00
   982 					sbc #$00
   983 					sta :STACKORIGIN+STACKWIDTH*3,x
   984
   985 					rts
   986 				.endp
   987
   988 20DD			.proc	negWORD
   989 					lda #$00
   990 					sub :STACKORIGIN,x
   991 					sta :STACKORIGIN,x
   992
   993 					lda #$00
   994 					sbc :STACKORIGIN+STACKWIDTH,x
   995 					sta :STACKORIGIN+STACKWIDTH,x
   996
   997 					lda #$00
   998 					sbc #$00
   999 					sta :STACKORIGIN+STACKWIDTH*2,x
  1000
  1001 					lda #$00
  1002 					sbc #$00
  1003 					sta :STACKORIGIN+STACKWIDTH*3,x
  1004
  1005 					rts
  1006 				.endp
  1007
  1008 20DD			.proc	negCARD
  1009 					lda #$00
  1010 					sub :STACKORIGIN,x
  1011 					sta :STACKORIGIN,x
  1012
  1013 					lda #$00
  1014 					sbc :STACKORIGIN+STACKWIDTH,x
  1015 					sta :STACKORIGIN+STACKWIDTH,x
  1016
  1017 					lda #$00
  1018 					sbc :STACKORIGIN+STACKWIDTH*2,x
  1019 					sta :STACKORIGIN+STACKWIDTH*2,x
  1020
  1021 					lda #$00
  1022 					sbc :STACKORIGIN+STACKWIDTH*3,x
  1023 					sta :STACKORIGIN+STACKWIDTH*3,x
  1024
  1025 					rts
  1026 				.endp
  1027
  1028
  1029 20DD			.proc	negBYTE1
  1030 					lda #$00
  1031 					sub :STACKORIGIN-1,x
  1032 					sta :STACKORIGIN-1,x
  1033
  1034 					lda #$00
  1035 					sbc #$00
  1036 					sta :STACKORIGIN-1+STACKWIDTH,x
  1037
  1038 					lda #$00
  1039 					sbc #$00
  1040 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1041
  1042 					lda #$00
  1043 					sbc #$00
  1044 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1045
  1046 					rts
  1047 				.endp
  1048
  1049 20DD			.proc	negWORD1
  1050 					lda #$00
  1051 					sub :STACKORIGIN-1,x
  1052 					sta :STACKORIGIN-1,x
  1053
  1054 					lda #$00
  1055 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1056 					sta :STACKORIGIN-1+STACKWIDTH,x
  1057
  1058 					lda #$00
  1059 					sbc #$00
  1060 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1061
  1062 					lda #$00
  1063 					sbc #$00
  1064 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1065
  1066 					rts
  1067 				.endp
  1068
  1069 20DD			.proc	negCARD1
  1070 					lda #$00
  1071 					sub :STACKORIGIN-1,x
  1072 					sta :STACKORIGIN-1,x
  1073
  1074 					lda #$00
  1075 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1076 					sta :STACKORIGIN-1+STACKWIDTH,x
  1077
  1078 					lda #$00
  1079 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1080 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1081
  1082 					lda #$00
  1083 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1084 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1085
  1086 					rts
  1087 				.endp
  1088
  1089
  1090 20DD			.proc	andAL_CL
  1091
  1092 					lda :STACKORIGIN-1,x
  1093 					and :STACKORIGIN,x
  1094 					sta :STACKORIGIN-1,x
  1095
  1096 					rts
  1097 				.endp
  1098
  1099 20DD			.proc	andAX_CX
  1100
  1101 					.rept 2
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1103 					AND :STACKORIGIN+#*STACKWIDTH,X
  1104 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					.ENDR
  1105 					.endr
Source: REPT
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1102 					AND :STACKORIGIN+#*STACKWIDTH,X
  1102 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1106
  1107 					rts
  1108 				.endp
  1109
  1110 20DD			.proc	andEAX_ECX
  1111
  1112 					.rept MAXSIZE
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1114 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					.ENDR
  1116 					.endr
Source: REPT
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1113 					AND :STACKORIGIN+#*STACKWIDTH,X
  1113 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1117
  1118 					rts
  1119 				.endp
  1120
  1121
  1122 20DD			.proc	orAL_CL
  1123
  1124 					lda :STACKORIGIN-1,x
  1125 					ora :STACKORIGIN,x
  1126 					sta :STACKORIGIN-1,x
  1127
  1128 					rts
  1129 				.endp
  1130
  1131 20DD			.proc	orAX_CX
  1132
  1133 					.rept 2
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1135 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1136 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					.ENDR
  1137 					.endr
Source: REPT
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1134 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1138
  1139 					rts
  1140 				.endp
  1141
  1142 20DD			.proc	orEAX_ECX
  1143
  1144 					.rept MAXSIZE
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1146 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					.ENDR
  1148 					.endr
Source: REPT
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1145 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1145 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1149
  1150 					rts
  1151 				.endp
  1152
  1153
  1154 20DD			.proc	xorAL_CL
  1155
  1156 					lda :STACKORIGIN-1,x
  1157 					eor :STACKORIGIN,x
  1158 					sta :STACKORIGIN-1,x
  1159
  1160 					rts
  1161 				.endp
  1162
  1163 20DD			.proc	xorAX_CX
  1164
  1165 					.rept 2
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1167 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1168 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					.ENDR
  1169 					.endr
Source: REPT
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1166 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1170
  1171 					rts
  1172 				.endp
  1173
  1174 20DD			.proc	xorEAX_ECX
  1175
  1176 					.rept MAXSIZE
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1178 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					.ENDR
  1180 					.endr
Source: REPT
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1177 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1177 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1181
  1182 					rts
  1183 				.endp
  1184
  1185
  1186 				/*
  1187 				.proc	iniEAX_ECX_BYTE
  1188
  1189 					mva :STACKORIGIN,x ecx
  1190 					mva :STACKORIGIN-1,x eax
  1191
  1192 					rts
  1193 				.endp
  1194 				*/
  1194
  1195
  1196
  1197 20DD			.proc	iniEAX_ECX_WORD
  1198
  1199 					mva :STACKORIGIN,x ecx
  1200 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1201
  1202 					mva :STACKORIGIN-1,x eax
  1203 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1204
  1205 					mva #$00 ecx+2
  1206 					sta ecx+3
  1207
  1208 					sta eax+2
  1209 					sta eax+3
  1210
  1211 					rts
  1212 				.endp
  1213
  1214
  1215 20DD			.proc	iniEAX_ECX_CARD
  1216 					mva :STACKORIGIN,x ecx
  1217 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1218 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1219 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1220
  1221 					mva :STACKORIGIN-1,x eax
  1222 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1223 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1224 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1225
  1226 					rts
  1227 				.endp
  1228
  1229 20DD			.proc	movZTMP_aBX
  1230 					mva ZTMP8 :STACKORIGIN-1,x
  1231 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1232 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1233 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1234
  1235 					rts
  1236 				.endp
  1237
  1238
  1239 20DD				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 20DD			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 20DD			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 20DD			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 20DD			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 20DD			lsector	:8 dta l(256)
    55 20DD			hsector	:8 dta h(256)
    56
    57 				.endp
  1240 20DD				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 20DD			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 20DD			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 20DD			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 20DD			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 20DD			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 20DD			msg	lda #true
    64 20DD			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 20DD			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 20DD			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 20DD			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 20DD			lookup	ldx #$00
   110 					ldy #$01
   111 20DD			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 20DD			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 20DD			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 20DD			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 20DD			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 20DD			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 20DD			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 20DD			done	jsr eof
   247
   248 20DD			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 20DD			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 20DD			quit	rts
   265
   266 20DD			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 20DD			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 20DD			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 20DD			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 20DD			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 20DD			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 20DD			stp2
   336 					dey
   337 					tya
   338 20DD			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 20DD			attr	equ *-1
   343 					rts
   344
   345 20DD			cpName	sta ln
   346 20DD			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 20DD			ln	equ *-1
   354 					bne cp
   355 20DD			stp	rts
   356 				.endp
   357
  1241
  1242 20DD				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 20DD			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 20DD			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 20DD			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 20DD			.proc	divmulSHORTINT
    31
    32 20DD			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 20DD			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 20DD			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 20DD			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 20DD			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 20DD			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 20DD			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1243 20DD				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 20DD			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 20DD			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 20DD			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 20DD			.proc	divmulSMALLINT
    37
    38 20DD			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 20DD			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 20DD			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 20DD			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 20DD			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 20DD			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 20DD			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 20DD			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1244 20DD				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 20DD			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 20DD			.proc	divmulINT
    16
    17 20DD			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 20DD			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 20DD			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 20DD			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 20DD			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 20DD			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 20DD			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 20DD			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1245
  1246 20DD				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 20DD			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 20DD			sm1:		lda square1_lo,x
    49 20DD			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 20DD			sm3:		lda square1_hi,x
    52 20DD			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 20DD			.proc	imulCL
    75
    76 					lda #$00
    77
    78 					LDY #$09
    79 					CLC
    80 20DD			LOOP	ROR @
    81 					ROR eax
    82 					BCC MUL2
    83 					CLC		;DEC AUX above to remove CLC
    84 					ADC ecx
    85 20DD			MUL2	DEY
    86 					BNE LOOP
    87
    88 					STA eax+1
    89
    90 					RTS
    91 				.endp
    92
    93
    94 20DD			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 20DD			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 20DD			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 20DD			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 20DD			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1247 20DD				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 20DD			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 20DD			sm1a:		lda square1_lo,x
    78 20DD			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 20DD			sm3a:		lda square1_hi,x
    81 20DD			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 20DD			sm1b:		lda square1_lo,x
    88 20DD			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 20DD			sm3b:		lda square1_hi,x
    91 20DD			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 20DD			sm5a:		lda square1_lo,x
    98 20DD			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 20DD			sm7a:		lda square1_hi,x
   101 20DD			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 20DD			sm5b:		lda square1_lo,x
   107 20DD			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 20DD			sm7b:		lda square1_hi,x
   110 20DD			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 20DD			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 20DD			_BB_:		lda #0
   122 20DD			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 20DD			@
   129 						tya
   130 20DD			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 20DD			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 20DD			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 20DD			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 20DD			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 20DD			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 20DD			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 20DD			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 20DD			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 20DD			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 20DD			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1248 20DD				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 20DD			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 20DD			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 20DD			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 20DD			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 20DD			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 20DD			.proc	idivEAX_ECX
    74
    75 20DD			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 20DD			CARD	;jsr iniEAX_ECX_CARD
    81
    82 20DD			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 20DD			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 20DD			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1249
  1250 20DD				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 20DD			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 20DD			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 20DD			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 20DD			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1251 20DD				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 20DD			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 20DD			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 20DD			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 20DD			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 20DD			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 20DD			ecx3	equ *-1
    59 20DD			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 20DD			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 20DD			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 20DD			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 20DD			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 20DD			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 20DD			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 20DD			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 20DD			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 20DD			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 20DD			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 20DD			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 20DD			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1252 20DD				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 20DD			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 20DD			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 20DD			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 20DD			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 20DD			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 20DD			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 20DD			FADD:	LDA	#$00
   159 20DD			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 20DD			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 20DD			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 20DD			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 20DD			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 20DD			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 20DD			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 20DD			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 20DD			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 20DD			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 20DD			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 20DD			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 20DD			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 20DD			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 20DD			FPNORMLEFT1:	BMI	FPNORMDONE
   367 20DD			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 20DD			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 20DD			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 20DD			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 20DD			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 20DD			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 20DD			@	EOR	#$FF
   480 					LDX	#$08
   481 20DD			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 20DD			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 20DD			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 20DD			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 20DD			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 20DD			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 20DD			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 20DD			.proc	FCMPL
   605 20DD			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 20DD			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 20DD			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 20DD			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 20DD			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 20DD			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 20DD			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 20DD			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 20DD			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 20DD			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 20DD			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 20DD			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 20DD			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 20DD			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 20DD			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 20DD			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 20DD			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 20DD			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 20DD			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 20DD			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 20DD			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 20DD			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 20DD			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 20DD			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1253
  1254
  1255 20DD			.proc	@printCHAR
  1256 					ldy :STACKORIGIN,x
  1257 					jmp @print
  1258 				.endp
  1259
  1260
  1261 20DD			.proc	@printEOL
  1262 20DD A0 9B			ldy #eol
  1263 20DF 4C E2 20			jmp @print
  1264 				.endp
  1265
  1266
  1267 20E2			.proc	@print (.byte y) .reg
  1268 20E2 8A 48			txa:pha
  1269
  1270 20E4 98				tya
  1271 20E5 20 EF 20			jsr @putchar
  1272
  1273 20E8 68 AA			pla:tax
  1274 20EA 60				rts
  1275 				.endp
  1276
  1277
  1278 20EB			.proc	@printPCHAR (.word ya) .reg
  1279 					sta addr
  1280 					sty addr+1
  1281
  1282 					stx @sp
  1283
  1284 					lda #0
  1285 					sta loop+1
  1286
  1287 20EB			loop	ldy #0
  1288 					lda $ffff,y
  1289 20EB			addr	equ *-2
  1290 					beq stop
  1291
  1292 					inc loop+1
  1293 					beq stop
  1294
  1295 					jsr @putchar
  1296
  1297 					jmp loop
  1298
  1299 20EB			stop	ldx #0
  1300 20EB			@sp	equ *-1
  1301 					rts
  1302 				.endp
  1303
  1304
  1305 20EB			.proc	@printSTRING (.word ya) .reg
  1306 					sta ztmp
  1307 					sty ztmp+1
  1308
  1309 					stx @sp
  1310
  1311 					ldy #0
  1312 					sty loop+1
  1313 					lda (ztmp),y
  1314 					sta ln
  1315
  1316 					inw ztmp
  1317
  1318 20EB			loop	ldy #0
  1319 					lda (ztmp),y
  1320 				;	beq stop
  1321
  1322 					cpy #0
  1323 20EB			ln	equ *-1
  1324 					beq stop
  1325
  1326 					inc loop+1
  1327
  1328 					jsr @putchar
  1329
  1330 					jmp loop
  1331
  1332 20EB			stop	ldx #0
  1333 20EB			@sp	equ *-1
  1334 					rts
  1335 				.endp
  1336
  1337
  1338 20EB			.proc	@printBOOLEAN
  1339 					lda :STACKORIGIN,x
  1340 					beq _0
  1341
  1342 20EB			_1	lda <_true
  1343 					ldy >_true
  1344 					jmp @printSTRING
  1345
  1346 20EB			_0	lda <_false
  1347 					ldy >_false
  1348 					jmp @printSTRING
  1349
  1350 20EB			_true	dta 4,c'TRUE'
  1351 20EB			_false	dta 5,c'FALSE'
  1352 				.endp
  1353
  1354
  1355 20EB			.proc	mov_BYTE_DX
  1356 					mva :STACKORIGIN,x dx
  1357 					mva #$00 dx+1
  1358 					sta dx+2
  1359 					sta dx+3
  1360
  1361 					rts
  1362 				.endp
  1363
  1364 20EB			.proc	mov_WORD_DX
  1365 					mva :STACKORIGIN,x dx
  1366 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1367 					mva #$00 dx+2
  1368 					sta dx+3
  1369
  1370 					rts
  1371 				.endp
  1372
  1373 20EB			.proc	mov_CARD_DX
  1374 					mva :STACKORIGIN,x dx
  1375 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1376 					mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1377 					mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1378
  1379 					rts
  1380 				.endp
  1381
  1382
  1383 20EB			.proc	@printMINUS
  1384 					ldy #'-'
  1385 					jsr @printVALUE.pout
  1386
  1387 					jmp negCARD
  1388 				.endp
  1389
  1390
  1391 20EB			.proc	@printSHORTREAL
  1392 					jsr @expandToCARD.SMALL
  1393 					jmp @printREAL
  1394 				.endp
  1395
  1396
  1397 20EB			.proc	@FTOA
  1398
  1399 = 0086			i	= edx
  1400 = 008A			fra	= ecx
  1401 = 0082			hlp	= eax
  1402
  1403 = 0092			exp	= ztmp
  1404 = 0093			b	= ztmp+1
  1405 = 0094			sht	= ztmp+2
  1406
  1407 = 0440			bit	= @buf+64
  1408
  1409 					stx @sp
  1410
  1411 					mva :STACKORIGIN,x I
  1412 					sta :STACKORIGIN+9
  1413 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1414 					sta :STACKORIGIN+STACKWIDTH+9
  1415 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1416 					sta :STACKORIGIN+STACKWIDTH*2+9
  1417 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1418 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1419
  1420 					bpl skp
  1421
  1422 					ldy #'-'
  1423 					jsr @printVALUE.pout
  1424
  1425 20EB			skp
  1426 				; optimize OK (test_3.pas), line = 32
  1427
  1428 					lda :STACKORIGIN+STACKWIDTH*3+9
  1429 					asl :STACKORIGIN+9
  1430 					rol :STACKORIGIN+STACKWIDTH+9
  1431 					rol :STACKORIGIN+STACKWIDTH*2+9
  1432 					rol @
  1433 					sta EXP				; Exponent
  1434
  1435 				; optimize OK (test_3.pas), line = 33
  1436
  1437 					lda I
  1438 					sta FRA
  1439 					lda I+1
  1440 					sta FRA+1
  1441 					lda I+2
  1442 					sta FRA+2
  1443 					lda I+3
  1444 					sta FRA+3
  1445 					asl FRA
  1446 					rol FRA+1
  1447 					rol FRA+2
  1448 					rol FRA+3
  1449
  1450 				; optimize OK (test_3.pas), line = 35
  1451
  1452 					lda EXP
  1453 					sub #$7F
  1454 					sta SHT
  1455
  1456 				; optimize OK (test_3.pas), line = 37
  1457
  1458 					ldx #$3f
  1459 					lda #0
  1460 					sta:rpl bit,x-
  1461
  1462 				; For
  1463
  1464 				; optimize OK (test_3.pas), line = 39
  1465
  1466 				;	sta B
  1467 					tax
  1468
  1469 				; optimize OK (test_3.pas), line = 39
  1470
  1471 20EB			l_01D4
  1472 				;	lda B
  1473 				;	cmp #$17
  1474 					cpx #$17
  1475 					bcc *+7
  1476 					beq *+5
  1477
  1478 				; ForToDoProlog
  1479 					jmp l_01EE
  1480
  1481 				; optimize OK (test_3.pas), line = 40
  1482
  1483 				;	lda #$20
  1484 				;	add B
  1485 				;	tax
  1486
  1487 					lda FRA+2
  1488 					sta BIT+$20,x
  1489
  1490 				; optimize OK (test_3.pas), line = 41
  1491
  1492 					asl FRA
  1493 					rol FRA+1
  1494 					rol FRA+2
  1495 					rol FRA+3
  1496
  1497 				; ForToDoEpilog
  1498 20EB			c_01D4
  1499 				;	inc B
  1500 					inx
  1501
  1502 					seq
  1503
  1504 				; WhileDoEpilog
  1505 					jmp l_01D4
  1506 20EB			l_01EE
  1507 20EB			b_01D4
  1508
  1509 				; optimize OK (test_3.pas), line = 44
  1510
  1511 					mva #$80 BIT+$1f
  1512
  1513 				; optimize OK (test_3.pas), line = 46
  1514
  1515 					mva #$00 I
  1516 					sta I+1
  1517 					sta I+2
  1518 					sta I+3
  1519
  1520 				; optimize OK (test_3.pas), line = 47
  1521
  1522 					sta FRA+1
  1523 					sta FRA+2
  1524 					sta FRA+3
  1525
  1526 					mva #$01 FRA
  1527
  1528 				; For
  1529
  1530 				; optimize OK (test_3.pas), line = 49
  1531
  1532 					lda SHT
  1533 					add #$1F
  1534 					sta B
  1535
  1536 				; optimize OK (test_3.pas), line = 49
  1537
  1538 					tay
  1539
  1540 20EB			l_035B
  1541 				;	lda B
  1542 				;	cmp #$00
  1543 				;	bcs *+5
  1544
  1545 				; ForToDoProlog
  1546 				;	jmp l_0375
  1547
  1548 				; optimize OK (test_3.pas), line = 50
  1549
  1550 				;	ldy B
  1551 					lda BIT,y
  1552 					bpl l_03D7
  1553
  1554 				; optimize OK (test_3.pas), line = 50
  1555
  1556 					lda I				; Mantissa
  1557 					add FRA
  1558 					sta I
  1559 					lda I+1
  1560 					adc FRA+1
  1561 					sta I+1
  1562 					lda I+2
  1563 					adc FRA+2
  1564 					sta I+2
  1565 					lda I+3
  1566 					adc FRA+3
  1567 					sta I+3
  1568
  1569 				; IfThenEpilog
  1570 20EB			l_03D7
  1571
  1572 				; optimize OK (test_3.pas), line = 52
  1573
  1574 					asl FRA
  1575 					rol FRA+1
  1576 					rol FRA+2
  1577 					rol FRA+3
  1578
  1579 				; ForToDoEpilog
  1580 20EB			c_035B
  1581 				;	dec B
  1582 					dey
  1583
  1584 				;	lda B
  1585 				;	cmp #$ff
  1586 					cpy #$ff
  1587 					seq
  1588
  1589 				; WhileDoEpilog
  1590 					jmp l_035B
  1591 20EB			l_0375
  1592 20EB			b_035B
  1593
  1594 				; optimize OK (test_3.pas), line = 55
  1595
  1596 					mva #$00 FRA
  1597 					sta FRA+1
  1598 					sta FRA+2
  1599 					sta FRA+3
  1600
  1601 				; optimize OK (test_3.pas), line = 56
  1602
  1603 					sta EXP
  1604
  1605 					sta hlp
  1606 					sta hlp+1
  1607
  1608 					lda #$80
  1609 					sta hlp+2
  1610 				; For
  1611
  1612 				; optimize OK (test_3.pas), line = 58
  1613
  1614 					lda SHT
  1615 					add #$20
  1616 				;	sta B
  1617
  1618 					tay
  1619
  1620 				; optimize OK (test_3.pas), line = 58
  1621
  1622 					add #23
  1623 					sta FORTMP_1273
  1624 				; To
  1625 20EB			l_0508
  1626
  1627 				; ForToDoCondition
  1628
  1629 				; optimize OK (test_3.pas), line = 58
  1630
  1631 				;	lda B
  1632 				;	cmp #0
  1633 					cpy #0
  1634 20EB			FORTMP_1273	equ *-1
  1635 					bcc *+7
  1636 					beq *+5
  1637
  1638 				; ForToDoProlog
  1639 					jmp l_0534
  1640
  1641 				; optimize OK (test_3.pas), line = 59
  1642
  1643 				;	ldy B
  1644 					lda BIT,y
  1645 					bpl l_0596
  1646
  1647 				; optimize OK (test_3.pas), line = 59
  1648
  1649 					lda FRA
  1650 					add hlp
  1651 					sta FRA
  1652 					lda FRA+1
  1653 					adc hlp+1
  1654 					sta FRA+1
  1655 					lda FRA+2
  1656 					adc hlp+2
  1657 					sta FRA+2
  1658
  1659 				; IfThenEpilog
  1660 20EB			l_0596
  1661
  1662 					lsr hlp+2
  1663 					ror hlp+1
  1664 					ror hlp
  1665
  1666 				; ForToDoEpilog
  1667 20EB			c_0508
  1668 				;	inc B						; inc ptr byte [CounterAddress]
  1669 					iny
  1670
  1671 					seq
  1672
  1673 				; WhileDoEpilog
  1674 					jmp l_0508
  1675 20EB			l_0534
  1676 20EB			b_0508
  1677 20EB				:3 mva fra+# fracpart+#
  1678
  1679 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1680 					@float #500000
  1681
  1682 					ldx #0
  1683 20EB			@sp	equ *-1
  1684
  1685 					rts
  1686 				.endp
  1687
  1688
  1689 20EB			.proc	@printREAL
  1690
  1691 					stx @sp
  1692
  1693 					lda :STACKORIGIN+STACKWIDTH*3,x
  1694 					spl
  1695 					jsr @printMINUS
  1696
  1697 					jsr mov_CARD_DX
  1698
  1699 					mva dx+1 intpart		; intpart := uvalue shr 8
  1700 					mva dx+2 intpart+1
  1701 					mva dx+3 intpart+2
  1702 					mva #$00 intpart+3
  1703
  1704 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1705 					sta dx+2
  1706 					sta dx+1
  1707
  1708 					sta fracpart
  1709 					sta fracpart+1
  1710
  1711 					lda dx
  1712 					sta fracpart+2
  1713
  1714 20EB				:4 mva intpart+# dx+#		; integer part
  1715
  1716 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1717 					@float #5000
  1718
  1719 					ldx #0
  1720 20EB			@sp	equ *-1
  1721 					rts
  1722
  1723 20EB 00 00 00 00		intpart		.dword
  1724
  1725 				.endp
  1726
  1727
  1728 20EF			.proc	@float (.long axy) .reg
  1729
  1730 					sty cx
  1731 					stx cx+1
  1732 					sta cx+2
  1733
  1734 					lda @printVALUE.pout		; print integer part
  1735 					pha
  1736 					jsr @printVALUE
  1737 					pla
  1738 					sta @printVALUE.pout
  1739
  1740 					lda #0
  1741 					sta dx
  1742 					sta dx+1
  1743 					sta dx+2
  1744 					sta dx+3
  1745
  1746 20EF			loop	lda fracpart+2
  1747 					bpl skp
  1748
  1749 					clc
  1750 				;	lda cx
  1751 				;	spl
  1752 				;	sec
  1753
  1754 					lda dx
  1755 					adc cx
  1756 					sta dx
  1757 					lda dx+1
  1758 					adc cx+1
  1759 					sta dx+1
  1760 					lda dx+2
  1761 					adc cx+2
  1762 					sta dx+2
  1763 				;	lda dx+3
  1764 				;	adc #0
  1765 				;	sta dx+3
  1766
  1767 20EF			skp	lsr cx+2
  1768 					ror cx+1
  1769 					ror cx
  1770
  1771 					asl fracpart
  1772 					rol fracpart+1
  1773 					rol fracpart+2
  1774
  1775 					lda cx
  1776 					ora cx+1
  1777 					ora cx+2
  1778
  1779 					bne loop
  1780
  1781 					ldy #'.'
  1782 					jsr @printVALUE.pout
  1783
  1784 20EF				:4 mva dx+# fracpart+#
  1785
  1786 					lda @printVALUE.pout
  1787 					pha
  1788
  1789 					lda #{rts}
  1790 					sta @printVALUE.pout
  1791 					jsr @printVALUE			; floating part length
  1792
  1793 					sta cnt
  1794
  1795 					pla
  1796 					sta @printVALUE.pout
  1797
  1798 20EF			lp	lda #0
  1799 20EF			cnt	equ *-1
  1800 					cmp #4				; N miejsc po przecinku
  1801 20EF			afterpoint equ *-1
  1802 					bcs ok
  1803
  1804 					ldy #'0'
  1805 					jsr @printVALUE.pout
  1806
  1807 					inc cnt
  1808 					bne lp
  1809
  1810 20EF			ok	:4 mva fracpart+# dx+#
  1811 					jmp @printVALUE			; print floating part
  1812
  1813 				.endp
  1814
  1815
  1816 20EF			.proc	@printSHORTINT
  1817
  1818 					lda :STACKORIGIN,x
  1819 					spl
  1820 					jsr @printMINUS
  1821
  1822 					jmp @printBYTE
  1823 				.endp
  1824
  1825
  1826 20EF			.proc	@printSMALLINT
  1827
  1828 					lda :STACKORIGIN+STACKWIDTH,x
  1829 					spl
  1830 					jsr @printMINUS
  1831
  1832 					jmp @printWORD
  1833 				.endp
  1834
  1835
  1836 20EF			.proc	@printINT
  1837
  1838 					lda :STACKORIGIN+STACKWIDTH*3,x
  1839 					spl
  1840 					jsr @printMINUS
  1841
  1842 					jmp @printCARD
  1843 				.endp
  1844
  1845
  1846 20EF			.proc	@printCARD
  1847 					jsr mov_CARD_DX
  1848 					jmp @printVALUE
  1849 				.endp
  1850
  1851
  1852 20EF			.proc	@printWORD
  1853 					jsr mov_WORD_DX
  1854 					jmp @printVALUE
  1855 				.endp
  1856
  1857
  1858 20EF			.proc	@printBYTE
  1859 					jsr mov_BYTE_DX
  1860 					jmp @printVALUE
  1861 				.endp
  1862
  1863
  1864 20EF			.proc	@printVALUE
  1865
  1866 					lda dx+3
  1867 					bne _32bit
  1868
  1869 					lda dx+2
  1870 					bne _24bit
  1871
  1872 					lda dx+1
  1873 					bne _16bit
  1874
  1875 20EF			_8bit	lda #3
  1876 					bne l3
  1877
  1878 20EF			_16bit	lda #5
  1879 					bne l3
  1880
  1881 20EF			_24bit	lda #8
  1882 					bne l3
  1883
  1884 					; prints a 32 bit value to the screen (Graham)
  1885
  1886 20EF			_32bit	lda #10
  1887
  1888 20EF			l3	sta limit
  1889
  1890 					stx @sp
  1891
  1892 					ldx #0
  1893 					stx cnt
  1894
  1895 20EF			lp	jsr div10
  1896
  1897 					sta tmp,x
  1898 					inx
  1899 					cpx #10
  1900 20EF			limit	equ *-1
  1901 					bne lp
  1902
  1903 					;ldx #9
  1904 					dex
  1905
  1906 20EF			l1	lda tmp,x
  1907 					bne l2
  1908 					dex		; skip leading zeros
  1909 					bne l1
  1910
  1911 20EF			l2	lda tmp,x
  1912 					ora #$30
  1913 					tay
  1914
  1915 					jsr pout
  1916 					inc cnt
  1917
  1918 					dex
  1919 					bpl l2
  1920
  1921 					mva #{jmp*} pout
  1922
  1923 					lda #0
  1924 20EF			cnt	equ *-1
  1925
  1926 					ldx #0
  1927 20EF			@sp	equ *-1
  1928 					rts
  1929
  1930 20EF			pout	jmp @print
  1931
  1932 					sty @buf+1
  1933 20EF			pbuf	equ *-2
  1934 					inc pbuf
  1935
  1936 					rts
  1937
  1938 20EF			tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1939
  1940 				.endp
  1941
  1942
  1943 				; divides a 32 bit value by 10
  1944 				; remainder is returned in akku
  1945
  1946 20EF			.proc	div10
  1947 				        ldy #32		; 32 bits
  1948 				        lda #0
  1949 				        clc
  1950 20EF			l4      rol @
  1951 				        cmp #10
  1952 				        bcc skip
  1953 				        sbc #10
  1954 20EF			skip    rol dx
  1955 				        rol dx+1
  1956 				        rol dx+2
  1957 				        rol dx+3
  1958 				        dey
  1959 				        bpl l4
  1960
  1961 					rts
  1962 				.endp
  1963
  1964
  1965 20EF			.proc	@hexStr
  1966
  1967 = 0086			Value	= edx
  1968 = 008A			Digits	= ecx
  1969
  1970 					ldx Digits
  1971 					cpx #32
  1972 					scc
  1973 					ldx #32
  1974
  1975 					stx Digits
  1976
  1977 					lda Value
  1978 					jsr hex
  1979 					lda Value+1
  1980 					jsr hex
  1981 					lda Value+2
  1982 					jsr hex
  1983 					lda Value+3
  1984 					jsr hex
  1985
  1986 					lda Digits
  1987 					sta @buf
  1988 					rts
  1989
  1990 20EF			hex	pha
  1991 					and #$f
  1992 					jsr put
  1993 					pla
  1994 20EF				:4 lsr @
  1995 20EF			put	tay
  1996 					lda thex,y
  1997 					sta @buf,x
  1998 					dex
  1999 					rts
  2000
  2001 20EF			thex	dta c'0123456789ABCDEF'
  2002 				.endp
  2003
  2004
  2005 20EF			.proc	@ValueToStr (.word ya) .reg
  2006
  2007 					sta adr
  2008 					sty adr+1
  2009
  2010 					mva #{bit*} @printVALUE.pout
  2011 					mva <@buf+1 @printVALUE.pbuf
  2012
  2013 					jsr $ffff
  2014 20EF			adr	equ *-2
  2015
  2016 					ldy @printVALUE.pbuf
  2017 					dey
  2018 					sty @buf
  2019
  2020 					rts
  2021 				.endp
  2022
  2023
  2024 				;	ecx	isSign
  2025 				;	edx	Result
  2026
  2027 20EF			.proc	@StrToInt (.word ya) .reg
  2028
  2029 					sta bp2
  2030 					sty bp2+1
  2031
  2032 					ldy #0
  2033 					sty MAIN.SYSTEM.IOResult
  2034 					sty edx
  2035 					sty edx+1
  2036 					sty edx+2
  2037 					sty edx+3
  2038
  2039 					lda (bp2),y
  2040 					beq stop
  2041 					sta len
  2042
  2043 					inw bp2
  2044
  2045 					lda (bp2),y
  2046 					cmp #'-'
  2047 					sne
  2048 					iny
  2049
  2050 					sty ecx
  2051
  2052 20EF			l1	lda (bp2),y
  2053
  2054 					CLC
  2055 					ADC #$FF-'9'	; make m = $FF
  2056 					ADC #'9'-'0'+1	; carry set if in range n to m
  2057 					bcs ok
  2058
  2059 					lda #106	; Invalid numeric format
  2060 					sta MAIN.SYSTEM.IOResult
  2061
  2062 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2063
  2064 20EF			ok	jsr fmul10
  2065
  2066 					lda (bp2),y
  2067 					sub #$30
  2068 					sta ztmp
  2069
  2070 					lda #$00
  2071 					sta ztmp+1
  2072 					sta ztmp+2
  2073 					sta ztmp+3
  2074
  2075 					jsr fmul10.add32bit
  2076
  2077 					iny
  2078 					cpy #0
  2079 20EF			len	equ *-1
  2080 					bne l1
  2081
  2082 					lda ecx
  2083 					beq stop
  2084
  2085 					jsr negEDX
  2086
  2087 20EF			stop	ldy #0		; reg Y = 0 conversion successful
  2088 					rts
  2089 				.endp
  2090
  2091
  2092 20EF			.proc	negEDX
  2093 					lda #$00	; minus
  2094 					sub edx
  2095 					sta edx
  2096
  2097 					lda #$00
  2098 					sbc edx+1
  2099 					sta edx+1
  2100
  2101 					lda #$00
  2102 					sbc edx+2
  2103 					sta edx+2
  2104
  2105 					lda #$00
  2106 					sbc edx+3
  2107 					sta edx+3
  2108
  2109 					rts
  2110 				.endp
  2111
  2112
  2113 20EF			.proc	fmul10
  2114 					asl edx		;multiply by 2
  2115 					rol edx+1	;temp store in ZTMP
  2116 					rol edx+2
  2117 					rol edx+3
  2118
  2119 					lda edx
  2120 					sta ztmp
  2121 					lda edx+1
  2122 					sta ztmp+1
  2123 					lda edx+2
  2124 					sta ztmp+2
  2125 					lda edx+3
  2126 					sta ztmp+3
  2127
  2128 					asl edx
  2129 					rol edx+1
  2130 					rol edx+2
  2131 					rol edx+3
  2132
  2133 					asl edx
  2134 					rol edx+1
  2135 					rol edx+2
  2136 					rol edx+3
  2137
  2138 20EF			add32bit
  2139 					lda edx
  2140 					add ztmp
  2141 					sta edx
  2142 					lda edx+1
  2143 					adc ztmp+1
  2144 					sta edx+1
  2145 					lda edx+2
  2146 					adc ztmp+2
  2147 					sta edx+2
  2148 					lda edx+3
  2149 					adc ztmp+3
  2150 					sta edx+3
  2151
  2152 					rts
  2153 				.endp
  2154
  2155
  2156 20EF			.proc	@trunc
  2157
  2158 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2159 					spl
  2160 					jsr negCARD
  2161
  2162 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2163 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2164 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2165 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2166
  2167 					tya
  2168 					spl
  2169 					jsr negCARD
  2170
  2171 					rts
  2172 				.endp
  2173
  2174
  2175 20EF			.proc	@round
  2176
  2177 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2178 					spl
  2179 					jsr negCARD
  2180
  2181 					lda :STACKORIGIN,x
  2182 				//	add #$80
  2183 					cmp #$80
  2184 					lda :STACKORIGIN+STACKWIDTH,x
  2185 					adc #0
  2186 					sta :STACKORIGIN,x
  2187 					lda :STACKORIGIN+STACKWIDTH*2,x
  2188 					adc #0
  2189 					sta :STACKORIGIN+STACKWIDTH,x
  2190 					lda :STACKORIGIN+STACKWIDTH*3,x
  2191 					adc #0
  2192 					sta :STACKORIGIN+STACKWIDTH*2,x
  2193
  2194 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2195
  2196 					tya
  2197 					spl
  2198 					jsr negCARD
  2199
  2200 					rts
  2201 				.endp
  2202
  2203
  2204 20EF			.proc	@frac
  2205
  2206 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2207 					spl
  2208 					jsr negCARD
  2209
  2210 					lda #$00
  2211 					sta :STACKORIGIN+STACKWIDTH,x
  2212 					sta :STACKORIGIN+STACKWIDTH*2,x
  2213 					sta :STACKORIGIN+STACKWIDTH*3,x
  2214
  2215 					tya
  2216 					spl
  2217 					jsr negCARD
  2218
  2219 					rts
  2220 				.endp
  2221
  2222
  2223 20EF			.proc	@int
  2224
  2225 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2226 					spl
  2227 					jsr negCARD
  2228
  2229 					lda #$00
  2230 					sta :STACKORIGIN,x
  2231
  2232 					tya
  2233 					spl
  2234 					jsr negCARD
  2235
  2236 					rts
  2237 				.endp
  2238
  2239
  2240 				;----------------------------;
  2241 				; Biblioteka procedur        ;
  2242 				; graficznych                ;
  2243 				;----------------------------;
  2244 				; Autorzy:                   ;
  2245 				;  Slawomir 'SERO' Ritter,   ;
  2246 				;  Jakub Cebula,             ;
  2247 				;  Winfried Hofacker         ;
  2248 				;----------------------------;
  2249 				; Wersja:1.1 DATA:09.01.2008 ;
  2250 				;----------------------------;
  2251
  2252 = 0003			@open	= $03		; Otworz kanal
  2253 = 000C			@close	= $0c		; Zamknij kanal
  2254
  2255 = 0007			@IDget	= $07		; Narysuj punkt
  2256 = 0009			@IDput	= $09		; Narysuj punkt
  2257 = 0011			@IDdraw	= $11		; Narysuj linie
  2258 = 0012			@IDfill	= $12		; Wypelnij obszar
  2259
  2260
  2261 				;------------------------;
  2262 				;Wy:.Y-numer bledu (1-OK);
  2263 				;   f(N)=1-wystapil blad ;
  2264 				;------------------------;
  2265 20EF			.proc	@COMMAND
  2266
  2267 					ldx	#$00
  2268 20EF			scrchn	equ *-1
  2269
  2270 					sta	iocom,x
  2271
  2272 					lda	#$00
  2273 20EF			colscr	equ *-1
  2274 					sta	atachr
  2275
  2276 					jmp	ciov
  2277 				.endp
  2278
  2279 				;------------------------;
  2280 				; Ustaw tryb ekranu      ;
  2281 				;------------------------;
  2282 				;We:.X-numer kanalu      ;
  2283 				;      (normalnie 0)     ;
  2284 				;   .Y-numer trybu (O.S.);
  2285 				;   .A-Ustawiony bit nr :;
  2286 				;     5-Nie kasowanie    ;
  2287 				;       pamieci ekranu   ;
  2288 				;     4-Obecnosc okna    ;
  2289 				;       tekstowego       ;
  2290 				;     2-Odczyt z ekranu  ;
  2291 				;------------------------;
  2292 				;Wy:SCRCHN-numer kanalu  ;
  2293 				;  .Y-numer bledu (1-OK) ;
  2294 				;   f(N)=1 wystapil blad ;
  2295 				;------------------------;
  2296 20EF			@GRAPHICS .proc (.byte x,y,a) .reg
  2297
  2298 					sta	byte1
  2299 					sty	byte2
  2300
  2301 					stx	@COMMAND.scrchn
  2302
  2303 					lda	#@close
  2304 					jsr	xcio
  2305
  2306 					lda	#0		; =opcje
  2307 20EF			byte1	equ	*-1
  2308 					ora	#8		; +zapis na ekranie
  2309 					sta	ioaux1,x
  2310
  2311 					lda	#0
  2312 20EF			byte2	equ	*-1
  2313 					sta	ioaux2,x	;=nr.trybu
  2314
  2315 					mwa	#sname	ioadr,x
  2316
  2317 					lda	#@open
  2318
  2319 20EF			xcio	sta iocom,x
  2320 					jmp ciov
  2321
  2322 20EF			sname	dta c'S:',$9b
  2323
  2324 					.endp
  2325
  2326
  2327 20EF			.proc	@ata2int
  2328 				        asl
  2329 				        php
  2330 				        cmp #2*$60
  2331 				        bcs @+
  2332 				        sbc #2*$20-1
  2333 				        bcs @+
  2334 				        adc #2*$60
  2335 20EF			@       plp
  2336 				        ror
  2337 					rts
  2338 				.endp
  2339
  2340
  2341 				/*
  2342 				  PUT CHAR
  2343
  2344 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2345 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2346 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2347
  2348 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2349 				  JSR PUTCHR.
  2350 				*/
  2350
  2351
  2352 20EF			.proc	@putchar (.byte a) .reg
  2353
  2354 20EF 2C EF 20		vbxe	bit *
  2355
  2356 20F2 A2 00			ldx #$00
  2357 					.ifdef MAIN.CRT.TextAttr
  2358 20F4 0D 55 21			ora MAIN.CRT.TextAttr
  2359 					.endif
  2360 20F7 A8				tay
  2361 20F8 BD 47 03			lda icputb+1,x
  2362 20FB 48				pha
  2363 20FC BD 46 03			lda icputb,x
  2364 20FF 48				pha
  2365 2100 98				tya
  2366
  2367 2101 60				rts
  2368
  2369 				.endp
  2370
  2371
  2372 				/*
  2373 				  GETLINE
  2374
  2375 				  Program czeka, az uzytkownik wpisze ciag znak�w z klawiatury i nacisnie klawisz RETURN.
  2376 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2377 				  (odczyt jest robiony z edytora ekranowego).
  2378
  2379 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2380 				  do rejestr�w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2381
  2382 				*/
  2382
  2383
  2384 2102			.proc	@GetLine
  2385
  2386 					stx @sp
  2387
  2388 					ldx #0
  2389
  2390 					stx MAIN.SYSTEM.EoLn
  2391
  2392 					mwa	#@buf+1	icbufa,x
  2393
  2394 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2395
  2396 					mva	#$05	iccmd,x
  2397
  2398 					jsr	ciov
  2399
  2400 					dew icbufl
  2401 					mva icbufl @buf			; length
  2402
  2403 					ldx @buf+1
  2404 					cpx #EOL
  2405 					bne skp
  2406
  2407 					ldx #TRUE
  2408 					stx MAIN.SYSTEM.EoLn
  2409 2102			skp
  2410 					ldx #0
  2411 2102			@sp	equ *-1
  2412
  2413 					rts
  2414 				.endp
  2415
  2416
  2417 2102			.proc	@GetKey
  2418
  2419 2102			getk	lda kbcodes	; odczytaj kbcodes
  2420 					cmp #255		; czy jest znak?
  2421 					beq getk	; nie: czekaj
  2422 					ldy #255		; daj zna�, �e klawisz
  2423 					sty kbcodes	; zosta� odebrany
  2424 					tay		; kod klawisza jako indeks
  2425 					lda (keydef),y	; do tablicy w ROM-ie
  2426
  2427 					rts
  2428 				.endp
  2429
  2430
  2431 2102			.proc	@moveSTRING (.word ya) .reg
  2432
  2433 					sta @move.dst
  2434 					sty @move.dst+1
  2435
  2436 					mva :STACKORIGIN,x @move.src
  2437 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2438
  2439 					ldy #$00
  2440 					lda (@move.src),y
  2441 					add #1
  2442 					sta @move.cnt
  2443 					scc
  2444 					iny
  2445 					sty @move.cnt+1
  2446
  2447 					jmp @move
  2448 				.endp
  2449
  2450
  2451 2102			.proc	@moveSTRING_1 (.word ya) .reg
  2452
  2453 					sta @move.dst
  2454 					sty @move.dst+1
  2455
  2456 					mva :STACKORIGIN,x @move.src
  2457 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2458
  2459 					ldy #$00
  2460 					lda (@move.src),y
  2461 				;	add #1
  2462 					sta @move.cnt
  2463 					sty @move.cnt+1
  2464
  2465 					inw @move.src
  2466
  2467 					jmp @move
  2468 				.endp
  2469
  2470
  2471 				; Ullrich von Bassewitz, 2003-08-20
  2472 				; Performance increase (about 20%) by
  2473 				; Christian Krueger, 2009-09-13
  2474
  2475 2102			.proc	@moveu		; assert Y = 0
  2476
  2477 = 0086			ptr1	= edx
  2478 = 008A			ptr2	= ecx
  2479 = 0082			ptr3	= eax
  2480
  2481 					stx @sp
  2482
  2483 					ldy	#0
  2484
  2485 					ldx     ptr3+1		; Get high byte of n
  2486 					beq     L2		; Jump if zero
  2487
  2488 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2489 					LDA     (PTR1),Y	
  2490 					STA     (PTR2),Y
  2491 					INY
  2492 					.ENDR
  2492 					.endr
Source: REPT
  2489 					LDA     (PTR1),Y	
  2489 					STA     (PTR2),Y
  2489 					INY
  2489 					LDA     (PTR1),Y	
  2489 					STA     (PTR2),Y
  2489 					INY
Source: cpu6502.asm
  2493
  2494 					bne     L1
  2495 					inc     ptr1+1
  2496 					inc     ptr2+1
  2497 					dex			; Next 256 byte block
  2498 					bne	L1		; Repeat if any
  2499
  2500 					; the following section could be 10% faster if we were able to copy
  2501 					; back to front - unfortunately we are forced to copy strict from
  2502 					; low to high since this function is also used for
  2503 					; memmove and blocks could be overlapping!
  2504 					; {
  2505 2102			L2:				; assert Y = 0
  2506 					ldx     ptr3		; Get the low byte of n
  2507 					beq     done		; something to copy
  2508
  2509 2102			L3:     lda     (ptr1),Y	; copy a byte
  2510 					sta     (ptr2),Y
  2511 					iny
  2512 					dex
  2513 					bne     L3
  2514
  2515 					; }
  2516
  2517 2102			done	ldx #0
  2518 2102			@sp	equ *-1
  2519 					rts
  2520 				.endp
  2521
  2522
  2523 2102			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2524
  2525 = 0086			ptr1	= edx
  2526 = 008A			ptr2	= ecx
  2527 = 0082			ptr3	= eax
  2528
  2529 = 0086			src	= ptr1
  2530 = 008A			dst	= ptr2
  2531 = 0082			cnt	= ptr3
  2532
  2533 					cpw ptr2 ptr1
  2534 					scs
  2535 					jmp @moveu
  2536
  2537 					stx @sp
  2538
  2539 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2540
  2541 					lda     ptr1+1
  2542 					add     ptr3+1
  2543 					sta     ptr1+1
  2544
  2545 					lda     ptr2+1
  2546 					add     ptr3+1
  2547 					sta     ptr2+1
  2548
  2549 				; handle fractions of a page size first
  2550
  2551 					ldy     ptr3		; count, low byte
  2552 					bne     @entry		; something to copy?
  2553 					beq     PageSizeCopy	; here like bra...
  2554
  2555 2102			@copyByte:
  2556 					lda     (ptr1),y
  2557 					sta     (ptr2),y
  2558 2102			@entry:
  2559 					dey
  2560 					bne     @copyByte
  2561 					lda     (ptr1),y	; copy remaining byte
  2562 					sta     (ptr2),y
  2563
  2564 2102			PageSizeCopy:			; assert Y = 0
  2565 					ldx     ptr3+1		; number of pages
  2566 					beq     done		; none? -> done
  2567
  2568 2102			@initBase:
  2569 					dec     ptr1+1		; adjust base...
  2570 					dec     ptr2+1
  2571 					dey			; in entry case: 0 -> FF
  2572 					lda     (ptr1),y	; need to copy this 'intro byte'
  2573 					sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2574 					dey			; FF ->FE
  2575 2102			@copyBytes:
  2576 					.rept 2		; Unroll this a bit to make it faster...
  2577 					LDA     (PTR1),Y
  2578 					STA     (PTR2),Y
  2579 					DEY
  2580 					.ENDR
  2580 					.endr
Source: REPT
  2577 					LDA     (PTR1),Y
  2577 					STA     (PTR2),Y
  2577 					DEY
  2577 					LDA     (PTR1),Y
  2577 					STA     (PTR2),Y
  2577 					DEY
Source: cpu6502.asm
  2581 2102			@copyEntry:			; in entry case: 0 -> FF
  2582 					bne     @copyBytes
  2583 					lda     (ptr1),y	; Y = 0, copy last byte
  2584 					sta     (ptr2),y
  2585 					dex			; one page to copy less
  2586 					bne     @initBase	; still a page to copy?
  2587
  2588 2102			done	ldx #0
  2589 2102			@sp	equ *-1
  2590 					rts
  2591 				.endp
  2592
  2593
  2594 				; Ullrich von Bassewitz, 29.05.1998
  2595 				; Performance increase (about 20%) by
  2596 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2597
  2598 2102			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2599
  2600 = 0086			ptr1 = edx
  2601 = 008A			ptr3 = ecx
  2602 = 0082			ptr2 = eax
  2603
  2604 2102 8E 49 21			stx @sp
  2605
  2606 2105 A6 82			ldx ptr2
  2607
  2608 2107 A0 00			ldy #0
  2609
  2610 2109 46 8B		        lsr	ptr3+1          ; divide number of
  2611 210B 66 8A		        ror	ptr3            ; bytes by two to increase
  2612 210D 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2613 210F			oddCount:
  2614 								; y is still 0 here
  2615 210F 8A			        txa			; restore fill value
  2616 2110 91 86		        sta	(ptr1),y	; save value and increase
  2617 2112 E6 86		        inc	ptr1		; dest. pointer
  2618 2114 D0 02		        bne	evenCount
  2619 2116 E6 87		        inc	ptr1+1
  2620 2118			evenCount:
  2621 2118 A5 86			lda	ptr1		; build second pointer section
  2622 211A 18				clc
  2623 211B 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2624 211D 85 82			sta     ptr2
  2625 211F A5 87			lda     ptr1+1
  2626 2121 65 8B			adc     ptr3+1
  2627 2123 85 83			sta     ptr2+1
  2628
  2629 2125 8A			        txa			; restore fill value
  2630 2126 A6 8B		        ldx	ptr3+1		; Get high byte of n
  2631 2128 F0 13		        beq	L2		; Jump if zero
  2632
  2633 				; Set 256/512 byte blocks
  2634 								; y is still 0 here
  2635 				L1:	.rept 2		; Unroll this a bit to make it faster
  2636 					STA	(PTR1),Y	
  2637 					STA	(PTR2),Y	
  2638 					INY
  2639 					.ENDR
  2639 					.endr
Source: REPT
  2636 212A 91 86			STA	(PTR1),Y	
  2636 212C 91 82			STA	(PTR2),Y	
  2636 212E C8				INY
  2636 212F 91 86			STA	(PTR1),Y	
  2636 2131 91 82			STA	(PTR2),Y	
  2636 2133 C8				INY
Source: cpu6502.asm
  2640 2134 D0 F4		        bne	L1
  2641 2136 E6 87		        inc	ptr1+1
  2642 2138 E6 83		        inc	ptr2+1
  2643 213A CA			        dex                     ; Next 256 byte block
  2644 213B D0 ED		        bne	L1              ; Repeat if any
  2645
  2646 				; Set the remaining bytes if any
  2647
  2648 213D A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2649 213F F0 07			beq	leave           ; something to set? No -> leave
  2650
  2651 2141 88			L3:	dey
  2652 2142 91 86			sta	(ptr1),y	; set bytes in low
  2653 2144 91 82			sta	(ptr2),y	; and high section
  2654 2146 D0 F9			bne     L3		; flags still up to date from dey!
  2655
  2656 2148 A2 00		leave	ldx #0
  2657 = 2149			@sp	equ *-1
  2658 214A 60				rts			; return
  2659 				.endp
  2660
  2661
  2662 				/*
  2663 				 add strings
  2664 				 result -> @buf
  2665 				*/
  2665
  2666 214B			.proc	@addString(.word ya) .reg
  2667
  2668 					sta ztmp
  2669 					sty ztmp+1
  2670
  2671 					stx @sp
  2672
  2673 					ldx @buf
  2674 					inx
  2675 					beq stop
  2676
  2677 					ldy #0
  2678 					lda (ztmp),y
  2679 					sta ile
  2680 					beq stop
  2681
  2682 					iny
  2683
  2684 214B			load	lda (ztmp),y
  2685 					sta @buf,x
  2686
  2687 					iny
  2688 					inx
  2689 					beq stop
  2690 					dec ile
  2691 					bne load
  2692
  2693 214B			stop	dex
  2694 					stx @buf
  2695
  2696 					ldx #0
  2697 214B			@sp	equ *-1
  2698 					rts
  2699
  2700 214B			ile	brk
  2701 				.endp
  2702
  2703
  2704 				/* ----------------------------------------------------------------------- */
  2705
  2706
  2707 214B			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2708
  2709 					jsr swap
  2710
  2711 					adw spoint ztmp+2
  2712
  2713 					rts
  2714
  2715 214B			swap	txa:pha
  2716
  2717 					mwa spoint bp2
  2718
  2719 					ldx #0
  2720 					ldy #0
  2721
  2722 214B			loop	cpy ztmp+2
  2723 					bne @+
  2724 					cpx ztmp+3
  2725 					beq stop
  2726
  2727 214B			@	lda (bp2),y
  2728 					pha
  2729
  2730 					lda (ztmp),y
  2731 					sta (bp2),y
  2732
  2733 					pla
  2734 					sta (ztmp),y
  2735
  2736 					iny
  2737 					bne loop
  2738
  2739 					inc ztmp+1
  2740 					inc bp2+1
  2741 					inx
  2742
  2743 					jmp loop
  2744
  2745 214B			stop	pla:tax
  2746
  2747 					rts
  2748
  2749 214B			spoint	dta a(PROGRAMSTACK)
  2750 				.endp
  2751
  2752
  2753 214B			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2754
  2755 					sbw @AllocMem.spoint ztmp+2
  2756
  2757 					jmp @AllocMem.swap
  2758 				.endp
  2759
  2760
  2761 				/* ----------------------------------------------------------------------- */
  2762
  2763
  2764 214B			.proc	@vbxe_detect
  2765
  2766 					ldy #.sizeof(detect)-1
  2767 					mva:rpl copy,y detect,y-
  2768
  2769 					jmp detect
  2770
  2771 214B			copy
  2772 0400				.local	detect,@buf
  2773 				;
  2774 				; 2009 by KMK/DLT
  2775 				;
  2776 					lda #0
  2777 					sta fxptr
  2778
  2779 				        lda #$d6
  2780 				        sta fxptr+1
  2781 				        ldy #FX_MEMB
  2782 				        jsr ?clr
  2783
  2784 				        jsr ?try
  2785 				        bcc ok
  2786
  2787 				        inc fxptr+1
  2788
  2789 					jsr ?try
  2790 					bcc ok
  2791
  2792 					lda #0
  2793 					sta fxptr+1
  2794 					rts
  2795
  2796 0400			?try    ldx $4000
  2797 				        jsr ?chk
  2798 				        bcc ?ret
  2799 				        inx
  2800 				        stx $4000
  2801 				        jsr ?chk
  2802 				        dec $4000
  2803 0400			?ret    rts
  2804
  2805 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2806 					lda	(fxptr),y
  2807 					rts
  2808
  2809 0400			?chk    lda #$80
  2810 				        jsr _vbxe_write
  2811 				        cpx $4000
  2812 				        bne ?fnd
  2813 				        sec
  2814 0400			        .byte $24
  2815 0400			?fnd    clc
  2816 0400			?clr    lda #$00
  2817 0400			_vbxe_write
  2818 				        sta (fxptr),y
  2819 				        rts
  2820
  2821 				/*
  2822 					lda	#0
  2823 					ldx	#0xd6
  2824 					sta	0xd640			; make sure it isn't coincidence
  2825 					lda	0xd640
  2826 					cmp	#0x10			; do we have major version here?
  2827 					beq	VBXE_Detected		; if so, then VBXE is detected
  2828 					lda	#0
  2829 					inx
  2830 					sta	0xd740			; no such luck, try other location
  2831 					lda	0xd740
  2832 					cmp	#0x10
  2833 					beq	VBXE_Detected
  2834 					ldx 	#0  			; not here, so not present or FX core version too low
  2835 					stx	fxptr+1
  2836 					stx	fxptr
  2837
  2838 					sec
  2839 					rts
  2840
  2841 				VBXE_Detected
  2842 					stx	fxptr+1
  2843 					lda	#0
  2844 					sta	fxptr
  2845
  2846 					ldy	#VBXE_MINOR		; get core minor version
  2847 					lda	(fxptr),y
  2848
  2849 					clc
  2850 					rts	 			; x - page of vbxe
  2851 				*/
  2851
  2852
  2853 					.endl
  2854
  2855 				.endp
  2856
  2857
  2858 214B			.proc	@setxdl(.byte a) .reg
  2859
  2860 					asl @
  2861 					sta idx
  2862
  2863 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2864
  2865 					ldy #0
  2866 214B			idx	equ *-1
  2867
  2868 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2869 					and msk,y
  2870 					ora val,y
  2871 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2872
  2873 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2874 					and msk+1,y
  2875 					ora val+1,y
  2876 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2877
  2878 					fxs FX_MEMS #0
  2879 					rts
  2880
  2881 214B			msk	.array [6] .word
  2882 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2883 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2884 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2885 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2886 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2887 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2888 					.enda
  2889
  2890 214B			val	.array [6] .word
  2891 					[e@xdl.mapon]  = XDLC_MAPON
  2892 					[e@xdl.mapoff] = XDLC_MAPOFF
  2893 					[e@xdl.ovron]  = XDLC_GMON
  2894 					[e@xdl.ovroff] = XDLC_OVOFF
  2895 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2896 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2897 					.enda
  2898
  2899 				.endp
  2900
  2901
  2902 214B			.proc	@vbxe_init
  2903
  2904 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2905 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2906
  2907 					ldx #.sizeof(s@xdl)-1
  2908 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2909
  2910 					jsr cmapini		; init color map
  2911
  2912 					fxsa FX_P1		; A = 0
  2913 					fxsa FX_P2
  2914 					fxsa FX_P3
  2915
  2916 					fxsa FX_IRQ_CONTROL
  2917 					fxsa FX_BLITTER_START
  2918
  2919 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2920 					fxsa FX_XDL_ADR1
  2921 					fxsa FX_XDL_ADR2
  2922
  2923 					sta colpf0s
  2924
  2925 					fxs FX_P0 #$ff
  2926
  2927 					mwa #@vbxe_cmap @putchar.vbxe+1
  2928 					mva #{jsr*} @putchar.vbxe
  2929
  2930 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2931
  2932 					rts
  2933
  2934 214B			cmapini	lda colpf1s
  2935 					and #$0f
  2936 					sta colpf1s
  2937
  2938 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2939 					sta ztmp
  2940
  2941 					mva #4 ztmp+1
  2942
  2943 214B			loop	fxs FX_MEMS ztmp
  2944
  2945 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2946 					sta bp+1
  2947
  2948 					ldx #16
  2949 					ldy #0
  2950
  2951 214B			lop	mva #$00	(bp),y+
  2952 					mva colpf1s	(bp),y+
  2953 					mva colpf2s	(bp),y+
  2954 					mva #%00010000	(bp),y+		; overlay palette #1
  2955 					bne lop
  2956
  2957 					inc bp+1
  2958 					dex
  2959 					bne lop
  2960
  2961 					inc ztmp
  2962
  2963 					dec ztmp+1
  2964 					bne loop
  2965
  2966 					fxs FX_MEMS #$00		; disable VBXE BANK
  2967 					rts
  2968
  2969 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2970 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2971 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2972 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2973 					0, 0, 7, 7, %00010001, $ff)
  2973 214B			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2974 				.endp
  2975
  2976
  2977 214B			.proc	@vbxe_cmap
  2978
  2979 					pha
  2980
  2981 					cmp #eol
  2982 					beq stop
  2983
  2984 					cmp #$7d		; clrscr
  2985 					bne skp
  2986
  2987 					jsr @vbxe_init.cmapini
  2988 					jmp stop
  2989
  2990 214B			skp	lda rowcrs
  2991 					pha
  2992 214B				:4 lsr @
  2993 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2994 					fxsa FX_MEMS
  2995
  2996 					pla
  2997 					and #$0f
  2998 					add >MAIN.SYSTEM.VBXE_WINDOW
  2999 					sta bp+1
  3000
  3001 					lda colcrs
  3002 					asl @
  3003 					asl @
  3004 					tay
  3005 					mva colpf0s (bp),y
  3006 					iny
  3007 					mva colpf1s (bp),y
  3008 					iny
  3009 					mva colpf2s (bp),y
  3010
  3011 					fxs FX_MEMS #$00
  3012
  3013 214B			stop	pla
  3014
  3015 					rts
  3016 				.endp
  3017
  3018
  3019 				/* ----------------------------------------------------------------------- */
  3020
  3021
  3022 				/*
  3023 				.proc	@cmdline (.byte a) .reg
  3024
  3025 					stx @sp
  3026
  3027 					sta idpar
  3028
  3029 					lda #0
  3030 					sta parno
  3031
  3032 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3033 					lsr
  3034 					bcc _no_command_line
  3035
  3036 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3037 					cmp #$c0
  3038 					bcs _no_command_line
  3039
  3040 					ldy #$03
  3041 					lda (dosvec),y
  3042 					cmp #{jmp}
  3043 					bne _no_command_line
  3044
  3045 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3046 					lda (dosvec),y
  3047 					sta lbuf
  3048 					iny
  3049 					lda (dosvec),y
  3050 					sta hbuf
  3051
  3052 					adw dosvec #3 zcr
  3053
  3054 				loop	lda #0
  3055 					sta @buf
  3056
  3057 					jsr $ffff
  3058 				zcr	equ *-2
  3059 					beq stop
  3060
  3061 					lda idpar
  3062 					bne skp
  3063
  3064 					ldy #33			; ParamStr(0)
  3065 				_par0	lda (dosvec),y
  3066 					sta @buf-33+1,y
  3067 					iny
  3068 					cpy #36
  3069 					bne _par0
  3070
  3071 					lda #3
  3072 					sta @buf
  3073 					bne stop
  3074
  3075 				skp	ldy #36
  3076 				_cp	lda (dosvec),y
  3077 					sta @buf-36+1,y
  3078 					iny
  3079 					cmp #$9b
  3080 					bne _cp
  3081
  3082 					tya
  3083 					sub #37
  3084 					sta @buf
  3085
  3086 					inc parno
  3087 					lda #0
  3088 				parno	equ *-1
  3089 					cmp #0
  3090 				idpar	equ *-1
  3091
  3092 					bne loop
  3093
  3094 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3095 					lda #0
  3096 				lbuf	equ *-1
  3097 					sta (dosvec),y
  3098 					iny
  3099 					lda #0
  3100 				hbuf	equ *-1
  3101 					sta (dosvec),y
  3102
  3103 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3104
  3105 					lda parno
  3106
  3107 					ldx #0
  3108 				@sp	equ *-1
  3109 					rts
  3110 				.endp
  3111 				*/
  3111
  3112
  3113
  3114 214B			.proc	@CmdLine (.byte a) .reg
  3115
  3116 					stx @sp
  3117
  3118 					sta idpar
  3119
  3120 					lda #0
  3121 					sta parno
  3122 					sta loop+1
  3123
  3124 					lda	#{jsr*}
  3125 					sta	res
  3126
  3127 				; Get filename from SpartaDOS...
  3128 214B			get_param
  3129 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3130 					lsr
  3131 					bcc no_sparta
  3132
  3133 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3134 					cmp #$c0
  3135 					bcs no_sparta
  3136
  3137 					ldy #$03
  3138 					lda (dosvec),y
  3139 					cmp #{jmp}
  3140 					bne no_sparta
  3141
  3142 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3143 					lda (dosvec),y
  3144 					sta lbuf
  3145 					iny
  3146 					lda (dosvec),y
  3147 					sta hbuf
  3148
  3149 					adw dosvec #33 tmp
  3150
  3151 					ldy #0
  3152 214B			fnm	lda (tmp),y
  3153 					iny
  3154 					cmp #$9b
  3155 					bne fnm
  3156
  3157 					tya			; remove .COM
  3158 					sub #5
  3159 					tay
  3160 					lda #0
  3161 					sta (tmp),y
  3162 					tay
  3163
  3164 					lda	#3
  3165 					sta	loop+1
  3166 					add	dosvec
  3167 					sta	get_adr
  3168 					lda	#0
  3169 					adc	dosvec+1
  3170 					sta	get_adr+1
  3171
  3172 					jmp	_ok
  3173
  3174 214B			no_sparta
  3175 					mwa #next get_adr
  3176
  3177 					lda	#{bit*}
  3178 					sta	res
  3179
  3180 				; ... or channel #0
  3181 					lda	MAIN.IOCB@COPY+2	; command
  3182 					cmp	#5			; read line
  3183 					bne	_no_command_line
  3184 					lda	MAIN.IOCB@COPY+3	; status
  3185 					bmi	_no_command_line
  3186 				; don't assume the line is EOL-terminated
  3187 				; DOS II+/D overwrites the EOL with ".COM"
  3188 				; that's why we rely on the length
  3189 					lda	MAIN.IOCB@COPY+9	; length hi
  3190 					bne	_no_command_line
  3191 					ldx	MAIN.IOCB@COPY+8	; length lo
  3192 					beq	_no_command_line
  3193 					inx:inx
  3194 					stx	arg_len
  3195 				; give access to three bytes before the input buffer
  3196 				; in DOS II+/D the device prompt ("D1:") is there
  3197 					lda	MAIN.IOCB@COPY+4
  3198 					sub	#3
  3199 					sta	tmp
  3200 					lda	MAIN.IOCB@COPY+5
  3201 					sbc	#0
  3202 					sta	tmp+1
  3203
  3204 					lda	#0
  3205 					ldy	#0
  3206 214B			arg_len	equ *-1
  3207 					sta	(tmp),y
  3208
  3209
  3210 214B			loop	ldy	#0
  3211
  3212 214B			_ok	ldx	#0
  3213
  3214 214B			lprea	lda	(tmp),y
  3215 					sta	@buf+1,x
  3216
  3217 					beq	stop
  3218
  3219 					cmp	#$9b
  3220 					beq	stop
  3221 					cmp	#' '
  3222 					beq	stop
  3223
  3224 					iny
  3225 					inx
  3226 					cpx #32
  3227 					bne lprea
  3228
  3229 214B			stop	lda #0
  3230 214B			parno	equ *-1
  3231 					cmp #0
  3232 214B			idpar	equ *-1
  3233 					beq found
  3234
  3235 					jsr $ffff		; sty loop+1
  3236 214B			get_adr	equ *-2
  3237 					beq found
  3238
  3239 					inc parno
  3240 					bne loop
  3241
  3242 214B			found	lda #0	;+$9b
  3243 					sta @buf+1,x
  3244 					stx @buf
  3245
  3246 214B			res	jsr sdxres
  3247
  3248 214B			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3249
  3250 					lda parno
  3251
  3252 					ldx #0
  3253 214B			@sp	equ *-1
  3254 					rts
  3255
  3256
  3257 214B			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3258 					lda #0
  3259 214B			lbuf	equ *-1
  3260 					sta (dosvec),y
  3261 					iny
  3262 					lda #0
  3263 214B			hbuf	equ *-1
  3264 					sta (dosvec),y
  3265 					rts
  3266
  3267
  3268 214B			_next	iny
  3269 214B			next	lda (tmp),y
  3270 					beq _eol
  3271 					cmp #' '
  3272 					beq _next
  3273
  3274 					cmp #$9b
  3275 					beq _eol
  3276
  3277 					sty loop+1
  3278 					rts
  3279
  3280 214B			_eol	lda #0
  3281 					rts
  3282
  3283 				.endp
  3284
  3285
  3286 				/* ----------------------------------------------------------------------- */
  3287
  3288 				/*
  3289 				.proc	@rstsnd
  3290 					lda #0
  3291 					sta $d208
  3292 					sta $d218
  3293
  3294 					ldy #3
  3295 					sty $d20f
  3296 					sty $d21f
  3297 					rts
  3298 				.endp
  3299 				*/
  3299
  3300
  3301 				;	ert (*>$3fff) .and (*<$8000)
  3302
  3303
  3304 				/* ----------------------------------------------------------------------- */
  3305
  3306
  3307 214B			.proc	@xmsBank
  3308
  3309 = 0082			ptr3 = eax			; position	(4)
  3310
  3311 					mva ptr3+3 ztmp+1	; position shr 14
  3312 					mva ptr3+2 ztmp
  3313 					lda ptr3+1
  3314
  3315 					.rept 6
  3316 					LSR ZTMP+1
  3317 					ROR ZTMP
  3318 					ROR @
  3319 					.ENDR
  3319 					.endr
Source: REPT
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
  3316 					LSR ZTMP+1
  3316 					ROR ZTMP
  3316 					ROR @
Source: cpu6502.asm
  3320
  3321 					tax			; index to bank
  3322
  3323 					lda portb
  3324 					and #1
  3325 					ora main.misc.adr.banks,x
  3326 					sta portb
  3327
  3328 					lda ptr3 		; offset
  3329 					sta ztmp
  3330 					lda ptr3+1
  3331 					and #$3f
  3332 					ora #$40
  3333 					sta ztmp+1
  3334
  3335 					rts
  3336 				.endp
  3337
  3338
  3339 214B			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3340
  3341 = 0086			ptr1 = dx	; buffer	(2)
  3342
  3343 = 008A			ptr2 = cx	; count		(2)
  3344 = 008C			pos = cx+2	; position	(2) pointer
  3345
  3346 = 0082			ptr3 = eax	; position	(4)
  3347
  3348 					txa:pha
  3349
  3350 					ldy #0
  3351 					lda (pos),y
  3352 					sta ptr3
  3353 					iny
  3354 					lda (pos),y
  3355 					sta ptr3+1
  3356 					iny
  3357 					lda (pos),y
  3358 					sta ptr3+2
  3359 					iny
  3360 					lda (pos),y
  3361 					sta ptr3+3
  3362
  3363 					lda ptr2+1
  3364 					beq lp2
  3365
  3366 214B			lp1	jsr @xmsBank
  3367
  3368 					lda ztmp+1
  3369 					cmp #$7f
  3370 					bne skp
  3371 					lda ztmp
  3372 					beq skp
  3373
  3374 					lda #0
  3375 					jsr nextBank
  3376 					jmp skp2
  3377
  3378 214B			skp	ldy #0
  3379 					mva:rne (ztmp),y @buf,y+
  3380
  3381 214B			skp2	lda portb
  3382 					and #1
  3383 					ora #$fe
  3384 					sta portb
  3385
  3386 					ldy #0
  3387 					mva:rne @buf,y (dx),y+
  3388
  3389 					inc dx+1	// inc(dx, $100)
  3390
  3391 					inl ptr3+1	// inc(position, $100)
  3392
  3393 					dec ptr2+1
  3394 					bne lp1
  3395
  3396 214B			lp2	jsr @xmsBank
  3397
  3398 					lda ztmp+1		; zakonczenie kopiowania
  3399 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3400 					bne skp_
  3401
  3402 					lda ztmp
  3403 					add ptr2
  3404 					bcc skp_
  3405
  3406 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3407 					jsr nextBank
  3408 					jmp skp3
  3409
  3410 214B			skp_	ldy #0
  3411 214B			mv	lda (ztmp),y
  3412 					sta @buf,y
  3413 					iny
  3414 					cpy ptr2
  3415 					bne mv
  3416
  3417 214B			skp3	lda portb
  3418 					and #1
  3419 					ora #$fe
  3420 					sta portb
  3421
  3422 					ldy #0
  3423 214B			lp3	lda @buf,y
  3424 					sta (dx),y
  3425 					iny
  3426 					cpy ptr2
  3427 					bne lp3
  3428
  3429 					jmp @xmsUpdatePosition
  3430
  3431 214B			.local	nextBank
  3432
  3433 					sta max
  3434
  3435 					mwa ztmp src
  3436
  3437 					ldy #0
  3438 214B			mv0	lda $ffff,y
  3439 214B			src	equ *-2
  3440 					sta @buf,y
  3441 					iny
  3442 					inc ztmp
  3443 					bne mv0
  3444
  3445 					lda portb
  3446 					and #1
  3447 					ora main.misc.adr.banks+1,x
  3448 					sta portb
  3449
  3450 					ldx #0
  3451 214B			mv1	cpy #0
  3452 214B			max	equ *-1
  3453 					beq stp
  3454 					lda $4000,x
  3455 					sta @buf,y
  3456 					inx
  3457 					iny
  3458 					bne mv1
  3459 214B			stp	rts
  3460 				.endl
  3461
  3462 				.endp
  3463
  3464
  3465 214B			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3466
  3467 = 0086			ptr1 = dx	; buffer	(2)
  3468
  3469 = 008A			ptr2 = cx	; count		(2)
  3470 = 008C			pos = cx+2	; position	(2) pointer
  3471
  3472 = 0082			ptr3 = eax	; position	(4)
  3473
  3474 					txa:pha
  3475
  3476 					ldy #0			; przepisz POSITION spod wskaznika
  3477 					lda (pos),y
  3478 					sta ptr3
  3479 					iny
  3480 					lda (pos),y
  3481 					sta ptr3+1
  3482 					iny
  3483 					lda (pos),y
  3484 					sta ptr3+2
  3485 					iny
  3486 					lda (pos),y
  3487 					sta ptr3+3
  3488
  3489 214B			lp1	lda portb		; wylacz dodatkowe banki
  3490 					and #1
  3491 					ora #$fe
  3492 					sta portb
  3493
  3494 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3495 					mva:rne (dx),y @buf,y+
  3496
  3497 					jsr @xmsBank		; wlacz dodatkowy bank
  3498
  3499 					lda ptr2+1
  3500 					beq lp2
  3501
  3502 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3503 					cmp #$7f
  3504 					bne skp
  3505 					lda ztmp
  3506 					beq skp
  3507
  3508 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3509 					jsr nextBank
  3510 					jmp skp2
  3511
  3512 214B			skp	mva:rne @buf,y (ztmp),y+
  3513
  3514 214B			skp2	inc dx+1		// inc(dx, $100)
  3515
  3516 					inl ptr3+1		// inc(position, $100)
  3517
  3518 					dec ptr2+1
  3519 					bne lp1
  3520
  3521 214B			lp2	lda ztmp+1		; zakonczenie kopiowania
  3522 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3523 					bne skp_
  3524
  3525 					lda ztmp
  3526 					add ptr2
  3527 					bcc skp_
  3528
  3529 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3530 					jsr nextBank
  3531 					jmp quit
  3532
  3533 214B			skp_	ldy #0
  3534 214B			lp3	lda @buf,y
  3535 					sta (ztmp),y
  3536
  3537 					iny
  3538 					cpy ptr2
  3539 					bne lp3
  3540
  3541 214B			quit	lda portb
  3542 					and #1
  3543 					ora #$fe
  3544 					sta portb
  3545
  3546 					jmp @xmsUpdatePosition
  3547
  3548 214B			.local	nextBank
  3549
  3550 					sta max
  3551
  3552 					mwa ztmp dst
  3553
  3554 					ldy #0
  3555 214B			mv0	lda @buf,y
  3556 					sta $ffff,y
  3557 214B			dst	equ *-2
  3558 					iny
  3559 					inc ztmp
  3560 					bne mv0
  3561
  3562 					lda portb
  3563 					and #1
  3564 					ora main.misc.adr.banks+1,x
  3565 					sta portb
  3566
  3567 					ldx #0
  3568 214B			mv1	cpy #0
  3569 214B			max	equ *-1
  3570 					beq stp
  3571 					lda @buf,y
  3572 					sta $4000,x
  3573 					inx
  3574 					iny
  3575 					bne mv1
  3576 214B			stp	rts
  3577 				.endl
  3578
  3579 				.endp
  3580
  3581
  3582 214B			.proc	@xmsAddPosition
  3583
  3584 214B				.use @xmsReadBuf
  3585
  3586 					add ptr3
  3587 					sta ptr3
  3588 					lda #$00
  3589 					adc ptr3+1
  3590 					sta ptr3+1
  3591 					lda #$00
  3592 					adc ptr3+2
  3593 					sta ptr3+2
  3594 					lda #$00
  3595 					adc ptr3+3
  3596 					sta ptr3+3
  3597
  3598 					rts
  3599 				.endp
  3600
  3601
  3602 214B			.proc	@xmsUpdatePosition
  3603
  3604 214B				.use @xmsReadBuf
  3605
  3606 					tya
  3607 					jsr @xmsAddPosition
  3608
  3609 					ldy #0
  3610 					lda ptr3
  3611 					sta (pos),y
  3612 					iny
  3613 					lda ptr3+1
  3614 					sta (pos),y
  3615 					iny
  3616 					lda ptr3+2
  3617 					sta (pos),y
  3618 					iny
  3619 					lda ptr3+3
  3620 					sta (pos),y
  3621
  3622 					pla:tax
  3623 					rts
  3624 				.endp
  3625
  3626
  3627 				/* ----------------------------------------------------------------------- */
  3628
  3629
  3630 214B			.proc	@ClrScr
  3631
  3632 					ldx #$00
  3633 					lda #$0c
  3634 					jsr xcio
  3635
  3636 					mwa #ename ioadr,x
  3637
  3638 					mva #$0c ioaux1,x
  3639 					mva #$00 ioaux2,x
  3640
  3641 					lda #$03
  3642
  3643 214B			xcio	sta iocom,x
  3644 					jmp ciov
  3645
  3646 214B			ename	.byte 'E:',$9b
  3647
  3648 				.endp
  3649
  3650
  3651 				/* ----------------------------------------------------------------------- */
  3652
  3653
  3654 					opt l+
   540
   541 				; -----------------------------------------------------------
   542
   543 				.macro UNITINITIALIZATION
   544 				
   545 					.ifdef MAIN.SYSTEM.@UnitInit
   546 					jsr MAIN.SYSTEM.@UnitInit
   547 					eif
   548 				
   549 					.ifdef MAIN.ATARI.@UnitInit
   550 					jsr MAIN.ATARI.@UnitInit
   551 					eif
   552 				
   553 					.ifdef MAIN.CRT.@UnitInit
   554 					jsr MAIN.CRT.@UnitInit
   555 					eif
   556 				
   557 					.ifdef MAIN..@UnitInit
   558 					jsr MAIN..@UnitInit
   559 					eif
   560 				.endm
   561
   562 					ift .SIZEOF(MAIN.SYSTEM) > 0
   563 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
   564 					eif
   565
   566 					ift .SIZEOF(MAIN.ATARI) > 0
   567 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
   568 					eif
   569
   570 					ift .SIZEOF(MAIN.CRT) > 0
   571 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
   571 				CRT: $202D..$2040
   572 					eif
   573
   574 					.print 'CODE: ',CODEORIGIN,'..',*-1
   574 				CODE: $2000..$214A
   575
   576 214B			DATAORIGIN
   577
   578 214B 28 00 18 00 0C	.by  $28 $00 $18 $00 $0C
   579
   580 = 0005			VARINITSIZE	= *-DATAORIGIN
   581 = 000E			VARDATASIZE	= 14
   582
   583 = 2159			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
   584
   585 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
   585 				DATA: $214B..$2159
   586
   587 02E0-02E1> 00 20			run START
   588
   589 				; -----------------------------------------------------------
   590
   591 				.macro	STATICDATA
   592 				.endm
   593
   594 					end
