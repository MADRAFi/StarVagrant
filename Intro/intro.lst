mads 2.0.9
  1131 					opt l+
    87
    88 0C75				RCDATA 'assets/Nvdi8.fnt' CHARSET_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('assets/Nvdi8.fnt')
     5 0C75				org RESORIGIN
     7 0C75 20 41 0C		mcpy	jsr sys.off
     9 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
     9 0C80 A9 00 85 8A A9 E4 +  MWA #MAIN.CHARSET_ADDRESS ECX
     9 0C88 A9 00 85 82 A9 04 +  MWA #LEN EAX
     9 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    11 0C93 4C 65 0C			jmp sys.on
    13 0C96 00 00 00 00 00 00 + data	ins 'assets/Nvdi8.fnt'
    15 					.print '$R RCDATA  ',main.CHARSET_ADDRESS,'..',main.CHARSET_ADDRESS+len-1," 'assets/Nvdi8.fnt'"
    15 				$R RCDATA  $E400..$E7FF 'assets/Nvdi8.fnt'
    17 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    89 1096				RCDATA 'assets/intro1.fnt' CHAR_ADDRESS_PIC1_F1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 2000			len = .filesize('assets/intro1.fnt')
    19 1096				org main.CHAR_ADDRESS_PIC1_F1
    21 4800-9FFF> 12 11 10 15 + 	ins 'assets/intro1.fnt'
    23 					.print '$R RCDATA   ',main.CHAR_ADDRESS_PIC1_F1,'..',*-1," 'assets/intro1.fnt'"
    23 				$R RCDATA   $4800..$67FF 'assets/intro1.fnt'
Source: intro.a65
    90 6800				RCDATA 'assets/intro2.fnt' CHAR_ADDRESS_PIC2_F1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 1C00			len = .filesize('assets/intro2.fnt')
    19 6800				org main.CHAR_ADDRESS_PIC2_F1
    21 6800 55 55 55 55 55 55 + 	ins 'assets/intro2.fnt'
    23 					.print '$R RCDATA   ',main.CHAR_ADDRESS_PIC2_F1,'..',*-1," 'assets/intro2.fnt'"
    23 				$R RCDATA   $6800..$83FF 'assets/intro2.fnt'
Source: intro.a65
    91 8400				RCDATA 'assets/intro3.fnt' CHAR_ADDRESS_PIC3_F1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 1400			len = .filesize('assets/intro3.fnt')
    19 8400				org main.CHAR_ADDRESS_PIC3_F1
    21 8400 00 00 00 00 00 00 + 	ins 'assets/intro3.fnt'
    23 					.print '$R RCDATA   ',main.CHAR_ADDRESS_PIC3_F1,'..',*-1," 'assets/intro3.fnt'"
    23 				$R RCDATA   $8400..$97FF 'assets/intro3.fnt'
Source: intro.a65
    92 9800				RCDATA 'assets/intro4.fnt' CHAR_ADDRESS_PIC4_F1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0800			len = .filesize('assets/intro4.fnt')
    19 9800				org main.CHAR_ADDRESS_PIC4_F1
    21 9800 00 9A AA 69 AA AA + 	ins 'assets/intro4.fnt'
    23 					.print '$R RCDATA   ',main.CHAR_ADDRESS_PIC4_F1,'..',*-1," 'assets/intro4.fnt'"
    23 				$R RCDATA   $9800..$9FFF 'assets/intro4.fnt'
Source: intro.a65
    93 A000				RCDATA 'assets/intro1.scr' SCREEN_ADDRESS_PIC1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 04B0			len = .filesize('assets/intro1.scr')
    19 A000				org main.SCREEN_ADDRESS_PIC1
    21 B800-BCAF> 00 01 02 03 + 	ins 'assets/intro1.scr'
    23 					.print '$R RCDATA   ',main.SCREEN_ADDRESS_PIC1,'..',*-1," 'assets/intro1.scr'"
    23 				$R RCDATA   $B800..$BCAF 'assets/intro1.scr'
Source: intro.a65
    94 BCB0				RCDATA 'assets/intro2.scr' SCREEN_ADDRESS_PIC2 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 04B0			len = .filesize('assets/intro2.scr')
     5 BCB0				org RESORIGIN
     7 0C75-1145> 20 41 0C	mcpy	jsr sys.off
     9 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
     9 0C80 A9 B0 85 8A A9 BC +  MWA #MAIN.SCREEN_ADDRESS_PIC2 ECX
     9 0C88 A9 B0 85 82 A9 04 +  MWA #LEN EAX
     9 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    11 0C93 4C 65 0C			jmp sys.on
    13 0C96 00 00 00 00 00 01 + data	ins 'assets/intro2.scr'
    15 					.print '$R RCDATA  ',main.SCREEN_ADDRESS_PIC2,'..',main.SCREEN_ADDRESS_PIC2+len-1," 'assets/intro2.scr'"
    15 				$R RCDATA  $BCB0..$C15F 'assets/intro2.scr'
    17 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    95 1146				RCDATA 'assets/intro3.scr' SCREEN_ADDRESS_PIC3 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 04B0			len = .filesize('assets/intro3.scr')
     5 1146				org RESORIGIN
     7 0C75-1145> 20 41 0C	mcpy	jsr sys.off
     9 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
     9 0C80 A9 60 85 8A A9 C1 +  MWA #MAIN.SCREEN_ADDRESS_PIC3 ECX
     9 0C88 A9 B0 85 82 A9 04 +  MWA #LEN EAX
     9 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    11 0C93 4C 65 0C			jmp sys.on
    13 0C96 00 00 00 00 00 00 + data	ins 'assets/intro3.scr'
    15 					.print '$R RCDATA  ',main.SCREEN_ADDRESS_PIC3,'..',main.SCREEN_ADDRESS_PIC3+len-1," 'assets/intro3.scr'"
    15 				$R RCDATA  $C160..$C60F 'assets/intro3.scr'
    17 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    96 1146				RCDATA 'assets/intro4.scr' SCREEN_ADDRESS_PIC4 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 04B0			len = .filesize('assets/intro4.scr')
     5 1146				org RESORIGIN
     7 0C75-1145> 20 41 0C	mcpy	jsr sys.off
     9 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
     9 0C80 A9 10 85 8A A9 C6 +  MWA #MAIN.SCREEN_ADDRESS_PIC4 ECX
     9 0C88 A9 B0 85 82 A9 04 +  MWA #LEN EAX
     9 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    11 0C93 4C 65 0C			jmp sys.on
    13 0C96 00 01 02 03 03 03 + data	ins 'assets/intro4.scr'
    15 					.print '$R RCDATA  ',main.SCREEN_ADDRESS_PIC4,'..',main.SCREEN_ADDRESS_PIC4+len-1," 'assets/intro4.scr'"
    15 				$R RCDATA  $C610..$CABF 'assets/intro4.scr'
    17 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    97 1146				RCASM 'dlist_title.asm' DISPLAY_LIST_ADDRESS_TITLE 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 1146				org RESORIGIN
     4 = 0022			len = .sizeof(_DISPLAY_LIST_ADDRESS_TITLE)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_TITLE+len >= $bc20
    11 0C75-0CB7> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 30 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_TITLE ECX
    13 0C88 A9 22 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_title.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 3000			FREE_TOP = $3000;
     4 = 3000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 3100			DISPLAY_LIST_ADDRESS_PIC1 = DISPLAY_LIST_ADDRESS_TITLE + $100;
     6 = 3200			DISPLAY_LIST_ADDRESS_PIC2 = DISPLAY_LIST_ADDRESS_PIC1 + $100;
     7 = 3300			DISPLAY_LIST_ADDRESS_PIC3 = DISPLAY_LIST_ADDRESS_PIC2 + $100;
     8 = 3400			DISPLAY_LIST_ADDRESS_PIC4 = DISPLAY_LIST_ADDRESS_PIC3 + $100;
    10 = 3900			PLAYER_ADDRESS = $3900; //DISPLAY_LIST_ADDRESS_PIC4 + $100;
    11 = 4100			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
    14 = 4800			CHAR_ADDRESS_PIC1_F1 = $4800; //MODULE_ADDRESS + $AAC;
    15 = 4C00			    CHAR_ADDRESS_PIC1_F2 = CHAR_ADDRESS_PIC1_F1 + $400;
    16 = 5000			    CHAR_ADDRESS_PIC1_F3 = CHAR_ADDRESS_PIC1_F2 + $400;
    17 = 5400			    CHAR_ADDRESS_PIC1_F4 = CHAR_ADDRESS_PIC1_F3 + $400;
    18 = 5800			    CHAR_ADDRESS_PIC1_F5 = CHAR_ADDRESS_PIC1_F4 + $400;
    19 = 5C00			    CHAR_ADDRESS_PIC1_F6 = CHAR_ADDRESS_PIC1_F5 + $400;
    20 = 6000			    CHAR_ADDRESS_PIC1_F7 = CHAR_ADDRESS_PIC1_F6 + $400;
    21 = 6400			    CHAR_ADDRESS_PIC1_F8 = CHAR_ADDRESS_PIC1_F7 + $400;
    23 = 6800			CHAR_ADDRESS_PIC2_F1 = CHAR_ADDRESS_PIC1_F1 + 8192;
    24 = 6C00			    CHAR_ADDRESS_PIC2_F2 = CHAR_ADDRESS_PIC2_F1 + $400;
    25 = 7000			    CHAR_ADDRESS_PIC2_F3 = CHAR_ADDRESS_PIC2_F2 + $400;
    26 = 7400			    CHAR_ADDRESS_PIC2_F4 = CHAR_ADDRESS_PIC2_F3 + $400;
    27 = 7800			    CHAR_ADDRESS_PIC2_F5 = CHAR_ADDRESS_PIC2_F4 + $400;
    28 = 7C00			    CHAR_ADDRESS_PIC2_F6 = CHAR_ADDRESS_PIC2_F5 + $400;
    29 = 8000			    CHAR_ADDRESS_PIC2_F7 = CHAR_ADDRESS_PIC2_F6 + $400;
    32 = 8400			CHAR_ADDRESS_PIC3_F1 = CHAR_ADDRESS_PIC2_F1 + 7168;
    33 = 8800			    CHAR_ADDRESS_PIC3_F2 = CHAR_ADDRESS_PIC3_F1 + $400;
    34 = 8C00			    CHAR_ADDRESS_PIC3_F3 = CHAR_ADDRESS_PIC3_F2 + $400;
    35 = 9000			    CHAR_ADDRESS_PIC3_F4 = CHAR_ADDRESS_PIC3_F3 + $400;
    36 = 9400			    CHAR_ADDRESS_PIC3_F5 = CHAR_ADDRESS_PIC3_F4 + $400;
    39 = 9800			CHAR_ADDRESS_PIC4_F1 = CHAR_ADDRESS_PIC3_F1 + 5120;
    40 = 9C00			    CHAR_ADDRESS_PIC4_F2 = CHAR_ADDRESS_PIC4_F1 + $400;
    42 = B800			SCREEN_ADDRESS_PIC1 = $B800; //CHAR_ADDRESS_PIC4_F1 + 8192;
    43 = BCB0			SCREEN_ADDRESS_PIC2 = SCREEN_ADDRESS_PIC1 + 1200;
    44 = C160			SCREEN_ADDRESS_PIC3 = SCREEN_ADDRESS_PIC2 + 1200;
    45 = C610			SCREEN_ADDRESS_PIC4 = SCREEN_ADDRESS_PIC3 + 1200;
    47 = E400			CHARSET_ADDRESS = $E400;
    48 = E800			TXT_ADDRESS = $E800;
    54 = 0004			NUMBEROFPICS = 4;
    37 3000			dl_start
    38 3000 F0			    dta DL_DLI + DL_BLANK8                                        
    39 3001 42 00 E8		    dta DL_MODE_40x24T2 + DL_LMS, a(TXT_ADDRESS)
    40 3004 02 02 02 02 02 02 +     :26 dta DL_MODE_40x24T2
    41 301E 70			    dta DL_BLANK8 
    42 301F 41 00 30		    dta DL_JVB, a(dl_start)
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS_TITLE,'..',main.DISPLAY_LIST_ADDRESS_TITLE+len-1," 'dlist_title.asm'"
    23 				$R RCASM   $3000..$3021 'dlist_title.asm'
    25 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    98 0CB8				RCASM 'dlist_pic1.asm' DISPLAY_LIST_ADDRESS_PIC1 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 0CB8				org RESORIGIN
     4 = 0022			len = .sizeof(_DISPLAY_LIST_ADDRESS_PIC1)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_PIC1+len >= $bc20
    11 0C75-0CB7> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 31 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_PIC1 ECX
    13 0C88 A9 22 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_pic1.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 3000			FREE_TOP = $3000;
     4 = 3000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 3100			DISPLAY_LIST_ADDRESS_PIC1 = DISPLAY_LIST_ADDRESS_TITLE + $100;
     6 = 3200			DISPLAY_LIST_ADDRESS_PIC2 = DISPLAY_LIST_ADDRESS_PIC1 + $100;
     7 = 3300			DISPLAY_LIST_ADDRESS_PIC3 = DISPLAY_LIST_ADDRESS_PIC2 + $100;
     8 = 3400			DISPLAY_LIST_ADDRESS_PIC4 = DISPLAY_LIST_ADDRESS_PIC3 + $100;
    10 = 3900			PLAYER_ADDRESS = $3900; //DISPLAY_LIST_ADDRESS_PIC4 + $100;
    11 = 4100			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
    14 = 4800			CHAR_ADDRESS_PIC1_F1 = $4800; //MODULE_ADDRESS + $AAC;
    15 = 4C00			    CHAR_ADDRESS_PIC1_F2 = CHAR_ADDRESS_PIC1_F1 + $400;
    16 = 5000			    CHAR_ADDRESS_PIC1_F3 = CHAR_ADDRESS_PIC1_F2 + $400;
    17 = 5400			    CHAR_ADDRESS_PIC1_F4 = CHAR_ADDRESS_PIC1_F3 + $400;
    18 = 5800			    CHAR_ADDRESS_PIC1_F5 = CHAR_ADDRESS_PIC1_F4 + $400;
    19 = 5C00			    CHAR_ADDRESS_PIC1_F6 = CHAR_ADDRESS_PIC1_F5 + $400;
    20 = 6000			    CHAR_ADDRESS_PIC1_F7 = CHAR_ADDRESS_PIC1_F6 + $400;
    21 = 6400			    CHAR_ADDRESS_PIC1_F8 = CHAR_ADDRESS_PIC1_F7 + $400;
    23 = 6800			CHAR_ADDRESS_PIC2_F1 = CHAR_ADDRESS_PIC1_F1 + 8192;
    24 = 6C00			    CHAR_ADDRESS_PIC2_F2 = CHAR_ADDRESS_PIC2_F1 + $400;
    25 = 7000			    CHAR_ADDRESS_PIC2_F3 = CHAR_ADDRESS_PIC2_F2 + $400;
    26 = 7400			    CHAR_ADDRESS_PIC2_F4 = CHAR_ADDRESS_PIC2_F3 + $400;
    27 = 7800			    CHAR_ADDRESS_PIC2_F5 = CHAR_ADDRESS_PIC2_F4 + $400;
    28 = 7C00			    CHAR_ADDRESS_PIC2_F6 = CHAR_ADDRESS_PIC2_F5 + $400;
    29 = 8000			    CHAR_ADDRESS_PIC2_F7 = CHAR_ADDRESS_PIC2_F6 + $400;
    32 = 8400			CHAR_ADDRESS_PIC3_F1 = CHAR_ADDRESS_PIC2_F1 + 7168;
    33 = 8800			    CHAR_ADDRESS_PIC3_F2 = CHAR_ADDRESS_PIC3_F1 + $400;
    34 = 8C00			    CHAR_ADDRESS_PIC3_F3 = CHAR_ADDRESS_PIC3_F2 + $400;
    35 = 9000			    CHAR_ADDRESS_PIC3_F4 = CHAR_ADDRESS_PIC3_F3 + $400;
    36 = 9400			    CHAR_ADDRESS_PIC3_F5 = CHAR_ADDRESS_PIC3_F4 + $400;
    39 = 9800			CHAR_ADDRESS_PIC4_F1 = CHAR_ADDRESS_PIC3_F1 + 5120;
    40 = 9C00			    CHAR_ADDRESS_PIC4_F2 = CHAR_ADDRESS_PIC4_F1 + $400;
    42 = B800			SCREEN_ADDRESS_PIC1 = $B800; //CHAR_ADDRESS_PIC4_F1 + 8192;
    43 = BCB0			SCREEN_ADDRESS_PIC2 = SCREEN_ADDRESS_PIC1 + 1200;
    44 = C160			SCREEN_ADDRESS_PIC3 = SCREEN_ADDRESS_PIC2 + 1200;
    45 = C610			SCREEN_ADDRESS_PIC4 = SCREEN_ADDRESS_PIC3 + 1200;
    47 = E400			CHARSET_ADDRESS = $E400;
    48 = E800			TXT_ADDRESS = $E800;
    54 = 0004			NUMBEROFPICS = 4;
    37 3100			dl_start
    38 3100 F0			    dta DL_DLI + DL_BLANK8                                        
    39 3101 44 00 E8		    dta DL_MODE_40x24T5 + DL_LMS, a(TXT_ADDRESS)
    40 3104 04			    :1 dta DL_MODE_40x24T5
    41 3105 84			    dta DL_DLI + DL_MODE_40x24T5
    42 3106 04 04		    :2 dta DL_MODE_40x24T5
    43 3108 84			    dta DL_DLI + DL_MODE_40x24T5
    44 3109 04 04		    :2 dta DL_MODE_40x24T5
    45 310B 84			    dta DL_DLI + DL_MODE_40x24T5
    46 310C 04 04		    :2 dta DL_MODE_40x24T5
    47 310E 84			    dta DL_DLI + DL_MODE_40x24T5
    48 310F 04 04		    :2 dta DL_MODE_40x24T5
    49 3111 84			    dta DL_DLI + DL_MODE_40x24T5
    50 3112 04 04		    :2 dta DL_MODE_40x24T5
    51 3114 84			    dta DL_DLI + DL_MODE_40x24T5
    52 3115 04 04		    :2 dta DL_MODE_40x24T5
    53 3117 84			    dta DL_DLI + DL_MODE_40x24T5
    54 3118 04 04		    :2 dta DL_MODE_40x24T5
    55 311A 84			    dta DL_DLI + DL_MODE_40x24T5
    56 311B 02 02 02		    :3 dta DL_MODE_40x24T2
    57 311E 70			    dta DL_BLANK8 
    58 311F 41 00 31		    dta DL_JVB, a(dl_start)                                       ; // jump to beginning
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS_PIC1,'..',main.DISPLAY_LIST_ADDRESS_PIC1+len-1," 'dlist_pic1.asm'"
    23 				$R RCASM   $3100..$3121 'dlist_pic1.asm'
    25 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    99 0CB8				RCASM 'dlist_pic2.asm' DISPLAY_LIST_ADDRESS_PIC2 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 0CB8				org RESORIGIN
     4 = 0022			len = .sizeof(_DISPLAY_LIST_ADDRESS_PIC2)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_PIC2+len >= $bc20
    11 0C75-0CB7> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 32 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_PIC2 ECX
    13 0C88 A9 22 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_pic2.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 3000			FREE_TOP = $3000;
     4 = 3000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 3100			DISPLAY_LIST_ADDRESS_PIC1 = DISPLAY_LIST_ADDRESS_TITLE + $100;
     6 = 3200			DISPLAY_LIST_ADDRESS_PIC2 = DISPLAY_LIST_ADDRESS_PIC1 + $100;
     7 = 3300			DISPLAY_LIST_ADDRESS_PIC3 = DISPLAY_LIST_ADDRESS_PIC2 + $100;
     8 = 3400			DISPLAY_LIST_ADDRESS_PIC4 = DISPLAY_LIST_ADDRESS_PIC3 + $100;
    10 = 3900			PLAYER_ADDRESS = $3900; //DISPLAY_LIST_ADDRESS_PIC4 + $100;
    11 = 4100			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
    14 = 4800			CHAR_ADDRESS_PIC1_F1 = $4800; //MODULE_ADDRESS + $AAC;
    15 = 4C00			    CHAR_ADDRESS_PIC1_F2 = CHAR_ADDRESS_PIC1_F1 + $400;
    16 = 5000			    CHAR_ADDRESS_PIC1_F3 = CHAR_ADDRESS_PIC1_F2 + $400;
    17 = 5400			    CHAR_ADDRESS_PIC1_F4 = CHAR_ADDRESS_PIC1_F3 + $400;
    18 = 5800			    CHAR_ADDRESS_PIC1_F5 = CHAR_ADDRESS_PIC1_F4 + $400;
    19 = 5C00			    CHAR_ADDRESS_PIC1_F6 = CHAR_ADDRESS_PIC1_F5 + $400;
    20 = 6000			    CHAR_ADDRESS_PIC1_F7 = CHAR_ADDRESS_PIC1_F6 + $400;
    21 = 6400			    CHAR_ADDRESS_PIC1_F8 = CHAR_ADDRESS_PIC1_F7 + $400;
    23 = 6800			CHAR_ADDRESS_PIC2_F1 = CHAR_ADDRESS_PIC1_F1 + 8192;
    24 = 6C00			    CHAR_ADDRESS_PIC2_F2 = CHAR_ADDRESS_PIC2_F1 + $400;
    25 = 7000			    CHAR_ADDRESS_PIC2_F3 = CHAR_ADDRESS_PIC2_F2 + $400;
    26 = 7400			    CHAR_ADDRESS_PIC2_F4 = CHAR_ADDRESS_PIC2_F3 + $400;
    27 = 7800			    CHAR_ADDRESS_PIC2_F5 = CHAR_ADDRESS_PIC2_F4 + $400;
    28 = 7C00			    CHAR_ADDRESS_PIC2_F6 = CHAR_ADDRESS_PIC2_F5 + $400;
    29 = 8000			    CHAR_ADDRESS_PIC2_F7 = CHAR_ADDRESS_PIC2_F6 + $400;
    32 = 8400			CHAR_ADDRESS_PIC3_F1 = CHAR_ADDRESS_PIC2_F1 + 7168;
    33 = 8800			    CHAR_ADDRESS_PIC3_F2 = CHAR_ADDRESS_PIC3_F1 + $400;
    34 = 8C00			    CHAR_ADDRESS_PIC3_F3 = CHAR_ADDRESS_PIC3_F2 + $400;
    35 = 9000			    CHAR_ADDRESS_PIC3_F4 = CHAR_ADDRESS_PIC3_F3 + $400;
    36 = 9400			    CHAR_ADDRESS_PIC3_F5 = CHAR_ADDRESS_PIC3_F4 + $400;
    39 = 9800			CHAR_ADDRESS_PIC4_F1 = CHAR_ADDRESS_PIC3_F1 + 5120;
    40 = 9C00			    CHAR_ADDRESS_PIC4_F2 = CHAR_ADDRESS_PIC4_F1 + $400;
    42 = B800			SCREEN_ADDRESS_PIC1 = $B800; //CHAR_ADDRESS_PIC4_F1 + 8192;
    43 = BCB0			SCREEN_ADDRESS_PIC2 = SCREEN_ADDRESS_PIC1 + 1200;
    44 = C160			SCREEN_ADDRESS_PIC3 = SCREEN_ADDRESS_PIC2 + 1200;
    45 = C610			SCREEN_ADDRESS_PIC4 = SCREEN_ADDRESS_PIC3 + 1200;
    47 = E400			CHARSET_ADDRESS = $E400;
    48 = E800			TXT_ADDRESS = $E800;
    54 = 0004			NUMBEROFPICS = 4;
    37 3200			dl_start
    38 3200 F0			    dta DL_DLI + DL_BLANK8                                        
    39 3201 44 00 E8		    dta DL_MODE_40x24T5 + DL_LMS, a(TXT_ADDRESS)                ; raw 0 
    40 3204 04			    :1 dta DL_MODE_40x24T5                                      ; raw 0
    41 3205 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 0
    42 3206 04 04 04		    :3 dta DL_MODE_40x24T5                                      ; raw 1
    43 3209 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 1
    44 320A 04 04 04		    :3 dta DL_MODE_40x24T5                                      ; raw 2
    45 320D 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 2
    46 320E 04 04		    :2 dta DL_MODE_40x24T5                                      ; raw 3
    47 3210 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 3
    48 3211 04 04		    :2 dta DL_MODE_40x24T5                                      ; raw 4
    49 3213 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 4
    50 3214 04 04 04		    :3 dta DL_MODE_40x24T5                                      ; raw 5
    51 3217 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 5
    52 3218 04 04		    :2 dta DL_MODE_40x24T5                                      ; raw 6
    53 321A 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 6
    54 321B 02 02 02		    :3 dta DL_MODE_40x24T2
    55 321E 70			    dta DL_BLANK8 
    56 321F 41 00 32		    dta DL_JVB, a(dl_start)                                       ; // jump to beginning
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS_PIC2,'..',main.DISPLAY_LIST_ADDRESS_PIC2+len-1," 'dlist_pic2.asm'"
    23 				$R RCASM   $3200..$3221 'dlist_pic2.asm'
    25 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
   100 0CB8				RCASM 'dlist_pic3.asm' DISPLAY_LIST_ADDRESS_PIC3 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 0CB8				org RESORIGIN
     4 = 0022			len = .sizeof(_DISPLAY_LIST_ADDRESS_PIC3)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_PIC3+len >= $bc20
    11 0C75-0CB7> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 33 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_PIC3 ECX
    13 0C88 A9 22 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_pic3.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 3000			FREE_TOP = $3000;
     4 = 3000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 3100			DISPLAY_LIST_ADDRESS_PIC1 = DISPLAY_LIST_ADDRESS_TITLE + $100;
     6 = 3200			DISPLAY_LIST_ADDRESS_PIC2 = DISPLAY_LIST_ADDRESS_PIC1 + $100;
     7 = 3300			DISPLAY_LIST_ADDRESS_PIC3 = DISPLAY_LIST_ADDRESS_PIC2 + $100;
     8 = 3400			DISPLAY_LIST_ADDRESS_PIC4 = DISPLAY_LIST_ADDRESS_PIC3 + $100;
    10 = 3900			PLAYER_ADDRESS = $3900; //DISPLAY_LIST_ADDRESS_PIC4 + $100;
    11 = 4100			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
    14 = 4800			CHAR_ADDRESS_PIC1_F1 = $4800; //MODULE_ADDRESS + $AAC;
    15 = 4C00			    CHAR_ADDRESS_PIC1_F2 = CHAR_ADDRESS_PIC1_F1 + $400;
    16 = 5000			    CHAR_ADDRESS_PIC1_F3 = CHAR_ADDRESS_PIC1_F2 + $400;
    17 = 5400			    CHAR_ADDRESS_PIC1_F4 = CHAR_ADDRESS_PIC1_F3 + $400;
    18 = 5800			    CHAR_ADDRESS_PIC1_F5 = CHAR_ADDRESS_PIC1_F4 + $400;
    19 = 5C00			    CHAR_ADDRESS_PIC1_F6 = CHAR_ADDRESS_PIC1_F5 + $400;
    20 = 6000			    CHAR_ADDRESS_PIC1_F7 = CHAR_ADDRESS_PIC1_F6 + $400;
    21 = 6400			    CHAR_ADDRESS_PIC1_F8 = CHAR_ADDRESS_PIC1_F7 + $400;
    23 = 6800			CHAR_ADDRESS_PIC2_F1 = CHAR_ADDRESS_PIC1_F1 + 8192;
    24 = 6C00			    CHAR_ADDRESS_PIC2_F2 = CHAR_ADDRESS_PIC2_F1 + $400;
    25 = 7000			    CHAR_ADDRESS_PIC2_F3 = CHAR_ADDRESS_PIC2_F2 + $400;
    26 = 7400			    CHAR_ADDRESS_PIC2_F4 = CHAR_ADDRESS_PIC2_F3 + $400;
    27 = 7800			    CHAR_ADDRESS_PIC2_F5 = CHAR_ADDRESS_PIC2_F4 + $400;
    28 = 7C00			    CHAR_ADDRESS_PIC2_F6 = CHAR_ADDRESS_PIC2_F5 + $400;
    29 = 8000			    CHAR_ADDRESS_PIC2_F7 = CHAR_ADDRESS_PIC2_F6 + $400;
    32 = 8400			CHAR_ADDRESS_PIC3_F1 = CHAR_ADDRESS_PIC2_F1 + 7168;
    33 = 8800			    CHAR_ADDRESS_PIC3_F2 = CHAR_ADDRESS_PIC3_F1 + $400;
    34 = 8C00			    CHAR_ADDRESS_PIC3_F3 = CHAR_ADDRESS_PIC3_F2 + $400;
    35 = 9000			    CHAR_ADDRESS_PIC3_F4 = CHAR_ADDRESS_PIC3_F3 + $400;
    36 = 9400			    CHAR_ADDRESS_PIC3_F5 = CHAR_ADDRESS_PIC3_F4 + $400;
    39 = 9800			CHAR_ADDRESS_PIC4_F1 = CHAR_ADDRESS_PIC3_F1 + 5120;
    40 = 9C00			    CHAR_ADDRESS_PIC4_F2 = CHAR_ADDRESS_PIC4_F1 + $400;
    42 = B800			SCREEN_ADDRESS_PIC1 = $B800; //CHAR_ADDRESS_PIC4_F1 + 8192;
    43 = BCB0			SCREEN_ADDRESS_PIC2 = SCREEN_ADDRESS_PIC1 + 1200;
    44 = C160			SCREEN_ADDRESS_PIC3 = SCREEN_ADDRESS_PIC2 + 1200;
    45 = C610			SCREEN_ADDRESS_PIC4 = SCREEN_ADDRESS_PIC3 + 1200;
    47 = E400			CHARSET_ADDRESS = $E400;
    48 = E800			TXT_ADDRESS = $E800;
    54 = 0004			NUMBEROFPICS = 4;
    37 3300			dl_start
    38 3300 F0			    dta DL_DLI + DL_BLANK8                                        
    39 3301 44 00 E8		    dta DL_MODE_40x24T5 + DL_LMS, a(TXT_ADDRESS)                ; raw 0
    40 3304 04 04 04 04 04 04 +     :7 dta DL_MODE_40x24T5                                      ; raw 0
    41 330B 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 0
    42 330C 04 04 04		    :3 dta DL_MODE_40x24T5                                      ; raw 1
    43 330F 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 1
    44 3310 04 04 04		    :3 dta DL_MODE_40x24T5                                      ; raw 2
    45 3313 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 2
    46 3314 04 04		    :2 dta DL_MODE_40x24T5                                      ; raw 3
    47 3316 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 3
    49 3317 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 1
    50 3318 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 3
    51 3319 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 4
    52 331A 84			    dta DL_DLI + DL_MODE_40x24T5                                ; raw 3
    53 331B 02 02 02		    :3 dta DL_MODE_40x24T2
    54 331E 70			    dta DL_BLANK8 
    55 331F 41 00 33		    dta DL_JVB, a(dl_start)                                       ; // jump to beginning
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS_PIC3,'..',main.DISPLAY_LIST_ADDRESS_PIC3+len-1," 'dlist_pic3.asm'"
    23 				$R RCASM   $3300..$3321 'dlist_pic3.asm'
    25 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
   101 0CB8				RCASM 'dlist_pic4.asm' DISPLAY_LIST_ADDRESS_PIC4 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 0CB8				org RESORIGIN
     4 = 0021			len = .sizeof(_DISPLAY_LIST_ADDRESS_PIC4)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_PIC4+len >= $bc20
    11 0C75-0CB6> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 34 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_PIC4 ECX
    13 0C88 A9 21 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_pic4.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 3000			FREE_TOP = $3000;
     4 = 3000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 3100			DISPLAY_LIST_ADDRESS_PIC1 = DISPLAY_LIST_ADDRESS_TITLE + $100;
     6 = 3200			DISPLAY_LIST_ADDRESS_PIC2 = DISPLAY_LIST_ADDRESS_PIC1 + $100;
     7 = 3300			DISPLAY_LIST_ADDRESS_PIC3 = DISPLAY_LIST_ADDRESS_PIC2 + $100;
     8 = 3400			DISPLAY_LIST_ADDRESS_PIC4 = DISPLAY_LIST_ADDRESS_PIC3 + $100;
    10 = 3900			PLAYER_ADDRESS = $3900; //DISPLAY_LIST_ADDRESS_PIC4 + $100;
    11 = 4100			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
    14 = 4800			CHAR_ADDRESS_PIC1_F1 = $4800; //MODULE_ADDRESS + $AAC;
    15 = 4C00			    CHAR_ADDRESS_PIC1_F2 = CHAR_ADDRESS_PIC1_F1 + $400;
    16 = 5000			    CHAR_ADDRESS_PIC1_F3 = CHAR_ADDRESS_PIC1_F2 + $400;
    17 = 5400			    CHAR_ADDRESS_PIC1_F4 = CHAR_ADDRESS_PIC1_F3 + $400;
    18 = 5800			    CHAR_ADDRESS_PIC1_F5 = CHAR_ADDRESS_PIC1_F4 + $400;
    19 = 5C00			    CHAR_ADDRESS_PIC1_F6 = CHAR_ADDRESS_PIC1_F5 + $400;
    20 = 6000			    CHAR_ADDRESS_PIC1_F7 = CHAR_ADDRESS_PIC1_F6 + $400;
    21 = 6400			    CHAR_ADDRESS_PIC1_F8 = CHAR_ADDRESS_PIC1_F7 + $400;
    23 = 6800			CHAR_ADDRESS_PIC2_F1 = CHAR_ADDRESS_PIC1_F1 + 8192;
    24 = 6C00			    CHAR_ADDRESS_PIC2_F2 = CHAR_ADDRESS_PIC2_F1 + $400;
    25 = 7000			    CHAR_ADDRESS_PIC2_F3 = CHAR_ADDRESS_PIC2_F2 + $400;
    26 = 7400			    CHAR_ADDRESS_PIC2_F4 = CHAR_ADDRESS_PIC2_F3 + $400;
    27 = 7800			    CHAR_ADDRESS_PIC2_F5 = CHAR_ADDRESS_PIC2_F4 + $400;
    28 = 7C00			    CHAR_ADDRESS_PIC2_F6 = CHAR_ADDRESS_PIC2_F5 + $400;
    29 = 8000			    CHAR_ADDRESS_PIC2_F7 = CHAR_ADDRESS_PIC2_F6 + $400;
    32 = 8400			CHAR_ADDRESS_PIC3_F1 = CHAR_ADDRESS_PIC2_F1 + 7168;
    33 = 8800			    CHAR_ADDRESS_PIC3_F2 = CHAR_ADDRESS_PIC3_F1 + $400;
    34 = 8C00			    CHAR_ADDRESS_PIC3_F3 = CHAR_ADDRESS_PIC3_F2 + $400;
    35 = 9000			    CHAR_ADDRESS_PIC3_F4 = CHAR_ADDRESS_PIC3_F3 + $400;
    36 = 9400			    CHAR_ADDRESS_PIC3_F5 = CHAR_ADDRESS_PIC3_F4 + $400;
    39 = 9800			CHAR_ADDRESS_PIC4_F1 = CHAR_ADDRESS_PIC3_F1 + 5120;
    40 = 9C00			    CHAR_ADDRESS_PIC4_F2 = CHAR_ADDRESS_PIC4_F1 + $400;
    42 = B800			SCREEN_ADDRESS_PIC1 = $B800; //CHAR_ADDRESS_PIC4_F1 + 8192;
    43 = BCB0			SCREEN_ADDRESS_PIC2 = SCREEN_ADDRESS_PIC1 + 1200;
    44 = C160			SCREEN_ADDRESS_PIC3 = SCREEN_ADDRESS_PIC2 + 1200;
    45 = C610			SCREEN_ADDRESS_PIC4 = SCREEN_ADDRESS_PIC3 + 1200;
    47 = E400			CHARSET_ADDRESS = $E400;
    48 = E800			TXT_ADDRESS = $E800;
    54 = 0004			NUMBEROFPICS = 4;
    38 3400			dl_start
    39 3400 F0			    dta DL_DLI + DL_BLANK8                                        
    40 3401 44 00 E8		    dta DL_MODE_40x24T5 + DL_LMS, a(TXT_ADDRESS)
    41 3404 04 04 04 04 04	    :5 dta DL_MODE_40x24T5
    42 3409 84			    dta DL_DLI + DL_MODE_40x24T5
    43 340A 04 04 04 04		    :4 dta DL_MODE_40x24T5
    44 340E 84			    dta DL_DLI + DL_MODE_40x24T5
    45 340F 84			    dta DL_DLI + DL_MODE_40x24T5
    46 3410 04			    dta DL_MODE_40x24T5
    47 3411 84			    dta DL_DLI + DL_MODE_40x24T5
    48 3412 02 02 02 02 02 02 +     :11 dta DL_MODE_40x24T2
    49 341D 70			    dta DL_BLANK8 
    50 341E 41 00 34		    dta DL_JVB, a(dl_start)                                       ; // jump to beginning
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS_PIC4,'..',main.DISPLAY_LIST_ADDRESS_PIC4+len-1," 'dlist_pic4.asm'"
    23 				$R RCASM   $3400..$3420 'dlist_pic4.asm'
    25 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
   102 0CB7				RMTPLAY 'assets/intro.feat' PLAYER_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RMTPLAY [Source: res6502.asm]
     2 = 0000			STEREOMODE	= 0
     3 = 3900			PLAYER		= main.PLAYER_ADDRESS
Source: rmt_player.asm
    27 = 0004			TRACKS		equ 4
    37 0CB7				org $e0
    38 00E0			p_tis
    39 00E0			p_instrstable	org *+2
    40 00E2			p_trackslbstable	org *+2
    41 00E4			p_trackshbstable	org *+2
    42 00E6			p_song			org *+2
    43 00E8			ns				org *+2
    44 00EA			nr				org *+2
    45 00EC			nt				org *+2
    46 00EE			reg1			org *+1
    47 00EF			reg2			org *+1
    48 00F0			reg3			org *+1
    49 00F1			tmp				org *+1
    56 00F2				org PLAYER-$400+$e0
    58 35E0			track_variables
    59 35E0			trackn_db	org *+TRACKS
    60 35E4			trackn_hb	org *+TRACKS
    61 35E8			trackn_idx	org *+TRACKS
    62 35EC			trackn_pause	org *+TRACKS
    63 35F0			trackn_note	org *+TRACKS
    64 35F4			trackn_volume	org *+TRACKS
    65 35F8			trackn_distor 	org *+TRACKS
    66 35FC			trackn_shiftfrq	org *+TRACKS
    74 3600			trackn_instrx2	org *+TRACKS
    75 3604			trackn_instrdb	org *+TRACKS
    76 3608			trackn_instrhb	org *+TRACKS
    77 360C			trackn_instridx	org *+TRACKS
    78 3610			trackn_instrlen	org *+TRACKS
    79 3614			trackn_instrlop	org *+TRACKS
    80 3618			trackn_instrreachend	org *+TRACKS
    81 361C			trackn_volumeslidedepth org *+TRACKS
    82 3620			trackn_volumeslidevalue org *+TRACKS
    86 = 0000			FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
    96 3624			trackn_tabletypespeed org *+TRACKS
   100 3628			trackn_tablenote	org *+TRACKS
   101 362C			trackn_tablea		org *+TRACKS
   102 3630			trackn_tableend		org *+TRACKS
   106 3634			trackn_tablespeeda	org *+TRACKS
   116 3638			trackn_audf	org *+TRACKS
   117 363C			trackn_audc	org *+TRACKS
   119 3640			trackn_audctl	org *+TRACKS
   121 3644			v_aspeed		org *+1
   122 3645			track_endvariables
   123 3645					org PLAYER-$100-$140-$40+2
   124 = 000C			INSTRPAR	equ 12
   125 3682			tabbeganddistor
   126 3682-3691> 80 00		 dta frqtabpure-frqtab,$00
   127 3684 80 20		 dta frqtabpure-frqtab,$20
   128 3686 80 40		 dta frqtabpure-frqtab,$40
   129 3688 00 C0		 dta frqtabbass1-frqtab,$c0
   130 368A 80 80		 dta frqtabpure-frqtab,$80
   131 368C 80 A0		 dta frqtabpure-frqtab,$a0
   132 368E 00 C0		 dta frqtabbass1-frqtab,$c0
   133 3690 40 C0		 dta frqtabbass2-frqtab,$c0
   146 3692					org PLAYER-$100-$140
   154 36C0					org PLAYER-$100-$100
   155 3700			frqtab
   157 3700			frqtabbass1
   158 3700-37BF> BF B6 AA A1 + 	dta $BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
   159 3710 98 8F 89 80 7A 71 + 	dta $98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
   160 3720 3C 38 35 32 2F 2D + 	dta $3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
   161 3730 17 16 14 13 12 11 + 	dta $17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
   162 3740			frqtabbass2
   163 3740 FF F1 E4 D8 CA C0 + 	dta $FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
   164 3750 66 61 5A 55 52 4B + 	dta $66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
   165 3760 28 25 24 21 1F 1E + 	dta $28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
   166 3770 0F 0E 0D 0C 0B 0A + 	dta $0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
   167 3780			frqtabpure
   168 3780 F3 E6 D9 CC C1 B5 + 	dta $F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
   169 3790 60 5B 55 51 4C 48 + 	dta $60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
   170 37A0 25 23 21 1F 1D 1C + 	dta $25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
   171 37B0 0E 0D 0C 0B 0A 09 + 	dta $0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
   179 37C0					org PLAYER-$0100
   180 3800			volumetab
   181 3800-3C00> 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   182 3810 00 00 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
   183 3820 00 00 00 00 01 01 + 	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
   184 3830 00 00 00 01 01 01 + 	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
   185 3840 00 00 01 01 01 01 + 	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
   186 3850 00 00 01 01 01 02 + 	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
   187 3860 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
   188 3870 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
   189 3880 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
   190 3890 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
   191 38A0 00 01 01 02 03 03 + 	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
   192 38B0 00 01 01 02 03 04 + 	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
   193 38C0 00 01 02 02 03 04 + 	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
   194 38D0 00 01 02 03 03 04 + 	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
   195 38E0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
   196 38F0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
   197 3900				org PLAYER
   201 3900			RASTERMUSICTRACKER
   202 3900 4C 9A 3A			jmp rmt_play
   204 3903 4C 0F 39			jmp rmt_init
   205 3906 4C B4 3A			jmp rmt_p3
   206 3909 4C 4A 39			jmp rmt_silence
   207 390C 4C CB 3B			jmp SetPokey
   211 390F			rmt_init
   212 390F 86 E8			stx ns
   213 3911 84 E9			sty ns+1
   215 3913 48				pha
   225 3914 A0 65			ldy #track_endvariables-track_variables
   226 3916 A9 00			lda #0
   227 3918 99 DF 35		ri0	sta track_variables-1,y
   228 391B 88				dey
   229 391C D0 FA			bne ri0
   231 391E A0 04			ldy #4
   232 3920 B1 E8			lda (ns),y
   233 3922 8D A8 3A			sta v_maxtracklen
   234 3925 C8				iny
   248 3926 A0 08			ldy #8
   249 3928 B1 E8		ri1	lda (ns),y
   250 392A 99 D8 00			sta p_tis-8,y
   251 392D C8				iny
   252 392E C0 10			cpy #8+8
   253 3930 D0 F6			bne ri1
   255 3932 68				pla
   256 3933 48				pha
   272 3934 0A				asl @
   273 3935 0A				asl @
   274 3936 18				clc
   275 3937 65 E6			adc p_song
   276 3939 85 E6			sta p_song
   277 393B 68				pla
   278 393C 08				php
   279 393D 29 C0			and #$c0
   280 393F 0A				asl @
   281 3940 2A				rol @
   282 3941 2A				rol @
   284 3942 28				plp
   285 3943 65 E7			adc p_song+1
   286 3945 85 E7			sta p_song+1
   288 3947 20 5F 39			jsr GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   289 394A			rmt_silence
   303 394A A9 00			lda #0
   304 394C 8D 08 D2			sta $d208
   305 394F A0 03			ldy #3
   306 3951 8C 0F D2			sty $d20f
   307 3954 A0 08			ldy #8
   308 3956 99 00 D2		si1	sta $d200,y
   309 3959 88				dey
   310 395A 10 FA			bpl si1
   315 395C A9 01			lda #FEAT_INSTRSPEED
   317 395E 60				rts
   318 395F			GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   319 395F			GetSongLine
   320 395F A2 00			ldx #0
   321 3961 8E A6 3A			stx v_abeat
   322 3964			nn0
   323 3964 8A			nn1	txa
   324 3965 A8				tay
   325 3966 B1 E6			lda (p_song),y
   326 3968 C9 FE			cmp #$fe
   327 396A B0 2D			bcs nn2
   328 396C A8				tay
   329 396D B1 E2			lda (p_trackslbstable),y
   330 396F 9D E0 35			sta trackn_db,x
   331 3972 B1 E4			lda (p_trackshbstable),y
   332 3974 9D E4 35		nn1a sta trackn_hb,x
   333 3977 A9 00			lda #0
   334 3979 9D E8 35			sta trackn_idx,x
   335 397C A9 01			lda #1
   336 397E 9D EC 35		nn1a2 sta trackn_pause,x
   337 3981 A9 80			lda #$80
   338 3983 9D 00 36			sta trackn_instrx2,x
   339 3986 E8				inx
   340 3987 E0 04		xtracks01	cpx #TRACKS
   341 3989 D0 D9			bne nn1
   342 398B A5 E6			lda p_song
   343 398D 18				clc
   344 398E 69 04		xtracks02	adc #TRACKS
   345 3990 85 E6			sta p_song
   346 3992 90 1B			bcc GetTrackLine
   347 3994 E6 E7			inc p_song+1
   348 3996			nn1b
   349 3996 4C AF 39			jmp GetTrackLine
   350 3999			nn2
   351 3999 F0 04			beq nn3
   352 399B			nn2a
   353 399B A9 00			lda #0
   354 399D F0 DF			beq nn1a2
   355 399F			nn3
   356 399F A0 02			ldy #2
   357 39A1 B1 E6			lda (p_song),y
   358 39A3 AA				tax
   359 39A4 C8				iny
   360 39A5 B1 E6			lda (p_song),y
   361 39A7 85 E7			sta p_song+1
   362 39A9 86 E6			stx p_song
   363 39AB A2 00			ldx #0
   364 39AD F0 B5			beq nn0
   365 39AF			GetTrackLine
   366 39AF			oo0
   367 39AF			oo0a
   373 39AF A2 FF			ldx #-1
   374 39B1			oo1
   375 39B1 E8				inx
   376 39B2 DE EC 35			dec trackn_pause,x
   377 39B5 D0 42			bne oo1x
   378 39B7			oo1b
   379 39B7 BD E0 35			lda trackn_db,x
   380 39BA 85 E8			sta ns
   381 39BC BD E4 35			lda trackn_hb,x
   382 39BF 85 E9			sta ns+1
   383 39C1			oo1i
   384 39C1 BC E8 35			ldy trackn_idx,x
   385 39C4 FE E8 35			inc trackn_idx,x
   386 39C7 B1 E8			lda (ns),y
   387 39C9 85 EE			sta reg1
   388 39CB 29 3F			and #$3f
   389 39CD C9 3D			cmp #61
   390 39CF F0 0E			beq oo1a
   391 39D1 B0 32			bcs oo2
   392 39D3 9D F0 35			sta trackn_note,x
   396 39D6 C8				iny
   397 39D7 B1 E8			lda (ns),y
   398 39D9 4A				lsr @
   399 39DA 29 7E			and #$3f*2
   400 39DC 9D 00 36			sta trackn_instrx2,x
   401 39DF			oo1a
   402 39DF A9 01			lda #1
   403 39E1 9D EC 35			sta trackn_pause,x
   404 39E4 BC E8 35			ldy trackn_idx,x
   405 39E7 FE E8 35			inc trackn_idx,x
   406 39EA B1 E8			lda (ns),y
   407 39EC 4A				lsr @
   408 39ED 66 EE			ror reg1
   409 39EF 4A				lsr @
   410 39F0 66 EE			ror reg1
   411 39F2 A5 EE			lda reg1
   420 39F4 29 F0			and #$f0
   421 39F6 9D F4 35			sta trackn_volume,x
   422 39F9			oo1x
   423 39F9 E0 03		xtracks03sub1	cpx #TRACKS-1
   424 39FB D0 B4			bne oo1
   430 39FD A9 03			lda #FEAT_CONSTANTSPEED
   432 39FF 8D 44 36			sta v_aspeed
   433 3A02 4C 3C 3A			jmp InitOfNewSetInstrumentsOnly
   434 3A05			oo2
   435 3A05 C9 3F			cmp #63
   436 3A07 F0 1B			beq oo63
   437 3A09 A5 EE			lda reg1
   438 3A0B 29 C0			and #$c0
   439 3A0D F0 09			beq oo62_b
   440 3A0F 0A				asl @
   441 3A10 2A				rol @
   442 3A11 2A				rol @
   443 3A12 9D EC 35			sta trackn_pause,x
   444 3A15 4C F9 39			jmp oo1x
   445 3A18			oo62_b
   446 3A18 C8				iny
   447 3A19 B1 E8			lda (ns),y
   448 3A1B 9D EC 35			sta trackn_pause,x
   449 3A1E FE E8 35			inc trackn_idx,x
   450 3A21 4C F9 39			jmp oo1x
   451 3A24			oo63
   452 3A24 A5 EE			lda reg1
   462 3A26 C9 FF			cmp #255
   463 3A28 F0 09			beq oo63_11
   464 3A2A C8				iny
   465 3A2B B1 E8			lda (ns),y
   466 3A2D 9D E8 35			sta trackn_idx,x
   467 3A30 4C C1 39			jmp oo1i
   468 3A33			oo63_11
   469 3A33 4C 5F 39			jmp GetSongLine
   470 3A36 4C B4 3A		p2xrmtp3	jmp rmt_p3
   471 3A39 CA			p2x0 dex
   472 3A3A 30 FA			 bmi p2xrmtp3
   473 3A3C			InitOfNewSetInstrumentsOnly
   474 3A3C BC 00 36		p2x1 ldy trackn_instrx2,x
   475 3A3F 30 F8			bmi p2x0
   488 3A41			SetUpInstrumentY2
   489 3A41 B1 E0			lda (p_instrstable),y
   490 3A43 9D 04 36			sta trackn_instrdb,x
   491 3A46 85 EC			sta nt
   492 3A48 C8				iny
   493 3A49 B1 E0			lda (p_instrstable),y
   494 3A4B 9D 08 36			sta trackn_instrhb,x
   495 3A4E 85 ED			sta nt+1
   510 3A50 A0 02			ldy #2
   512 3A52 B1 EC			lda (nt),y
   513 3A54 9D 10 36			sta trackn_instrlen,x
   514 3A57 C8				iny
   515 3A58 B1 EC			lda (nt),y
   516 3A5A 9D 14 36			sta trackn_instrlop,x
   517 3A5D C8				iny
   518 3A5E B1 EC			lda (nt),y
   519 3A60 9D 24 36			sta trackn_tabletypespeed,x
   523 3A63 9D 34 36			sta trackn_tablespeeda,x
   530 3A66 C8				iny
   531 3A67 B1 EC			lda (nt),y
   532 3A69 9D 40 36			sta trackn_audctl,x
   533 3A6C C8				iny
   537 3A6D B1 EC			lda (nt),y
   538 3A6F 9D 1C 36			sta trackn_volumeslidedepth,x
   567 3A72 A9 80			lda #128
   568 3A74 9D 20 36			sta trackn_volumeslidevalue,x
   569 3A77 9D 00 36			sta trackn_instrx2,x
   570 3A7A 0A				asl @
   571 3A7B 9D 18 36			sta trackn_instrreachend,x
   572 3A7E 9D FC 35			sta trackn_shiftfrq,x
   573 3A81 A8				tay
   574 3A82 B1 EC			lda (nt),y
   575 3A84 9D 30 36			sta trackn_tableend,x
   576 3A87 69 00			adc #0
   577 3A89 9D 0C 36			sta trackn_instridx,x
   578 3A8C A9 0C			lda #INSTRPAR
   579 3A8E 9D 2C 36			sta trackn_tablea,x
   580 3A91 A8				tay
   581 3A92 B1 EC			lda (nt),y
   582 3A94 9D 28 36			sta trackn_tablenote,x
   583 3A97			xata_rtshere
   587 3A97 4C 39 3A			jmp p2x0
   589 3A9A			rmt_play
   590 3A9A			rmt_p0
   591 3A9A 20 CB 3B			jsr SetPokey
   592 3A9D			rmt_p1
   605 3A9D			rmt_p2
   606 3A9D CE 44 36			dec v_aspeed
   607 3AA0 D0 12			bne rmt_p3
   608 3AA2 EE A6 3A			inc v_abeat
   609 3AA5 A9 FF			lda #$ff
   610 = 3AA6			v_abeat equ *-1
   611 3AA7 C9 FF			cmp #$ff
   612 = 3AA8			v_maxtracklen equ *-1
   613 3AA9 F0 03			beq p2o3
   614 3AAB 4C AF 39			jmp GetTrackLine
   615 3AAE			p2o3
   616 3AAE 4C 5F 39			jmp GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
   617 3AB1 4C AF 3B		go_ppnext	jmp ppnext
   618 3AB4			rmt_p3
   619 3AB4 A9 37			lda #>frqtab
   620 3AB6 85 EB			sta nr+1
   621 3AB8 A2 03		xtracks05sub1	ldx #TRACKS-1
   622 3ABA			pp1
   623 3ABA BD 08 36			lda trackn_instrhb,x
   624 3ABD F0 F2			beq go_ppnext
   625 3ABF 85 E9			sta ns+1
   626 3AC1 BD 04 36			lda trackn_instrdb,x
   627 3AC4 85 E8			sta ns
   628 3AC6 BC 0C 36			ldy trackn_instridx,x
   629 3AC9 B1 E8			lda (ns),y
   630 3ACB 85 EE			sta reg1
   631 3ACD C8				iny
   632 3ACE B1 E8			lda (ns),y
   633 3AD0 85 EF			sta reg2
   634 3AD2 C8				iny
   635 3AD3 B1 E8			lda (ns),y
   636 3AD5 85 F0			sta reg3
   637 3AD7 C8				iny
   638 3AD8 98				tya
   639 3AD9 DD 10 36			cmp trackn_instrlen,x
   640 3ADC 90 0A			bcc pp2
   641 3ADE F0 08			beq pp2
   642 3AE0 A9 80			lda #$80
   643 3AE2 9D 18 36			sta trackn_instrreachend,x
   644 3AE5			pp1b
   645 3AE5 BD 14 36			lda trackn_instrlop,x
   646 3AE8 9D 0C 36		pp2	sta trackn_instridx,x
   647 3AEB A5 EE			lda reg1
   657 3AED 29 0F			and #$0f
   658 3AEF 1D F4 35			ora trackn_volume,x
   659 3AF2 A8				tay
   660 3AF3 B9 00 38			lda volumetab,y
   661 3AF6 85 F1			sta tmp
   662 3AF8 A5 EF			lda reg2
   663 3AFA 29 0E			and #$0e
   664 3AFC A8				tay
   665 3AFD B9 82 36			lda tabbeganddistor,y
   666 3B00 85 EA			sta nr
   667 3B02 A5 F1			lda tmp
   668 3B04 19 83 36			ora tabbeganddistor+1,y
   669 3B07 9D 3C 36			sta trackn_audc,x
   670 3B0A			InstrumentsEffects
   696 3B0A BC 30 36			ldy trackn_tableend,x
   697 3B0D C0 0D			cpy #INSTRPAR+1
   698 3B0F 90 30			bcc ei3
   699 3B11 BD 34 36			lda trackn_tablespeeda,x
   700 3B14 10 25			bpl ei2f
   701 3B16			ei2c
   702 3B16 98				tya
   703 3B17 DD 2C 36			cmp trackn_tablea,x
   704 3B1A D0 07			bne ei2c2
   708 3B1C A9 0C			lda #INSTRPAR
   710 3B1E 9D 2C 36			sta trackn_tablea,x
   711 3B21 D0 03			bne ei2a
   712 3B23			ei2c2
   713 3B23 FE 2C 36			inc trackn_tablea,x
   714 3B26			ei2a
   715 3B26 BD 04 36			lda trackn_instrdb,x
   716 3B29 85 EC			sta nt
   717 3B2B BD 08 36			lda trackn_instrhb,x
   718 3B2E 85 ED			sta nt+1
   719 3B30 BC 2C 36			ldy trackn_tablea,x
   720 3B33 B1 EC			lda (nt),y
   728 3B35 9D 28 36			sta trackn_tablenote,x
   729 3B38 BD 24 36			lda trackn_tabletypespeed,x
   733 3B3B			ei2f
   734 3B3B 38				sec
   735 3B3C E9 01			sbc #1
   736 3B3E 9D 34 36			sta trackn_tablespeeda,x
   737 3B41			ei3
   738 3B41 BD 18 36			lda trackn_instrreachend,x
   739 3B44 10 18			bpl ei4
   740 3B46 BD F4 35			lda trackn_volume,x
   741 3B49 F0 13			beq ei4
   747 3B4B A8				tay
   748 3B4C BD 20 36			lda trackn_volumeslidevalue,x
   749 3B4F 18				clc
   750 3B50 7D 1C 36			adc trackn_volumeslidedepth,x
   751 3B53 9D 20 36			sta trackn_volumeslidevalue,x
   752 3B56 90 06			bcc ei4
   753 3B58 98				tya
   754 3B59 E9 10			sbc #16
   755 3B5B 9D F4 35			sta trackn_volume,x
   756 3B5E			ei4
   762 3B5E A5 EF			lda reg2
   766 3B60 29 70			and #$70
   770 3B62 4A				lsr @
   771 3B63 4A				lsr @
   772 3B64 8D 68 3B			sta jmx+1
   773 3B67 90 FE		jmx	bcc *
   774 3B69 4C 90 3B			jmp cmd0
   775 3B6C EA				nop
   776 3B6D 4C 7C 3B			jmp cmd1
   778 3B70 EA				nop
   779 3B71 4C 81 3B			jmp cmd2
   782 3B74 EA				nop
   783 3B75 4C 81 3B			jmp cmd3
   786 3B78 EA				nop
   787 3B79 4C 81 3B			jmp cmd4
   808 3B7C			cmd1
   810 3B7C A5 F0			lda reg3
   811 3B7E 4C AC 3B			jmp cmd0c
   813 3B81			cmd2
   820 3B81			cmd3
   828 3B81			cmd4
   830 3B81 BD FC 35			lda trackn_shiftfrq,x
   831 3B84 18				clc
   832 3B85 65 F0			adc reg3
   833 3B87 9D FC 35			sta trackn_shiftfrq,x
   834 3B8A BD F0 35			lda trackn_note,x
   835 3B8D 4C 96 3B			jmp cmd0a
   837 3B90			cmd5
   880 3B90			cmd6
   892 3B90			cmd7
   912 3B90			cmd0
   913 3B90 BD F0 35			lda trackn_note,x
   914 3B93 18				clc
   915 3B94 65 F0			adc reg3
   916 3B96			cmd0a
   921 3B96 18				clc
   922 3B97 7D 28 36			adc trackn_tablenote,x
   923 3B9A C9 3D			cmp #61
   924 3B9C 90 07			bcc cmd0a1
   925 3B9E A9 00			lda #0
   926 3BA0 9D 3C 36			sta trackn_audc,x
   927 3BA3 A9 3F			lda #63
   928 3BA5			cmd0a1
   932 3BA5 A8				tay
   933 3BA6 B1 EA			lda (nr),y
   934 3BA8 18				clc
   935 3BA9 7D FC 35			adc trackn_shiftfrq,x
   960 3BAC			cmd0c
   961 3BAC 9D 38 36			sta trackn_audf,x
   962 3BAF			pp9
   998 3BAF			ppnext
   999 3BAF CA				dex
  1000 3BB0 30 03			bmi rmt_p4
  1001 3BB2 4C BA 3A			jmp pp1
  1002 3BB5			rmt_p4
  1004 3BB5 AD 40 36			lda trackn_audctl+0
  1005 3BB8 0D 41 36			ora trackn_audctl+1
  1006 3BBB 0D 42 36			ora trackn_audctl+2
  1007 3BBE 0D 43 36			ora trackn_audctl+3
  1008 3BC1 AA				tax
  1012 3BC2			qq1
  1013 3BC2 8E CC 3B			stx v_audctl
  1119 3BC5			qq5
  1120 3BC5 8E CC 3B			stx v_audctl
  1240 3BC8			rmt_p5
  1245 3BC8 A9 01			lda #1
  1247 3BCA 60				rts
  1248 3BCB			SetPokey
  1289 3BCB A0 FF			ldy #$ff
  1290 = 3BCC			v_audctl equ *-1
  1291 3BCD AD 38 36			lda trackn_audf+0
  1292 3BD0 AE 3C 36			ldx trackn_audc+0
  1293 3BD3 8D 00 D2			sta $d200
  1294 3BD6 8E 01 D2			stx $d201
  1295 3BD9 AD 39 36			lda trackn_audf+1
  1296 3BDC AE 3D 36			ldx trackn_audc+1
  1297 3BDF 8D 02 D2			sta $d200+2
  1298 3BE2 8E 03 D2			stx $d201+2
  1299 3BE5 AD 3A 36			lda trackn_audf+2
  1300 3BE8 AE 3E 36			ldx trackn_audc+2
  1301 3BEB 8D 04 D2			sta $d200+4
  1302 3BEE 8E 05 D2			stx $d201+4
  1303 3BF1 AD 3B 36			lda trackn_audf+3
  1304 3BF4 AE 3F 36			ldx trackn_audc+3
  1305 3BF7 8D 06 D2			sta $d200+6
  1306 3BFA 8E 07 D2			stx $d201+6
  1307 3BFD 8C 08 D2			sty $d208
  1356 3C00 60				rts
  1357 3C01			RMTPLAYEREND
Source: intro.feat
     3 = 0000			FEAT_SFX		equ 0
     4 = 0000			FEAT_GLOBALVOLUMEFADE	equ 0		;RMTGLOBALVOLUMEFADE variable
     5 = 0000			FEAT_NOSTARTINGSONGLINE	equ 0
     6 = 0001			FEAT_INSTRSPEED		equ 1
     7 = 0003			FEAT_CONSTANTSPEED		equ 3		;(0 times)
     8 = 0001			FEAT_COMMAND1		equ 1		;(23 times)
     9 = 0000			FEAT_COMMAND2		equ 0		;(0 times)
    10 = 0000			FEAT_COMMAND3		equ 0		;(0 times)
    11 = 0001			FEAT_COMMAND4		equ 1		;(1 times)
    12 = 0000			FEAT_COMMAND5		equ 0		;(0 times)
    13 = 0000			FEAT_COMMAND6		equ 0		;(0 times)
    14 = 0000			FEAT_COMMAND7SETNOTE		equ 0		;(0 times)
    15 = 0000			FEAT_COMMAND7VOLUMEONLY		equ 0		;(0 times)
    16 = 0000			FEAT_PORTAMENTO		equ 0		;(0 times)
    17 = 0000			FEAT_FILTER		equ 0		;(0 times)
    18 = 0000			FEAT_FILTERG0L		equ 0		;(0 times)
    19 = 0000			FEAT_FILTERG1L		equ 0		;(0 times)
    20 = 0000			FEAT_FILTERG0R		equ 0		;(0 times)
    21 = 0000			FEAT_FILTERG1R		equ 0		;(0 times)
    22 = 0000			FEAT_BASS16		equ 0		;(0 times)
    23 = 0000			FEAT_BASS16G1L		equ 0		;(0 times)
    24 = 0000			FEAT_BASS16G3L		equ 0		;(0 times)
    25 = 0000			FEAT_BASS16G1R		equ 0		;(0 times)
    26 = 0000			FEAT_BASS16G3R		equ 0		;(0 times)
    27 = 0000			FEAT_VOLUMEONLYG0L		equ 0		;(0 times)
    28 = 0000			FEAT_VOLUMEONLYG2L		equ 0		;(0 times)
    29 = 0000			FEAT_VOLUMEONLYG3L		equ 0		;(0 times)
    30 = 0000			FEAT_VOLUMEONLYG0R		equ 0		;(0 times)
    31 = 0000			FEAT_VOLUMEONLYG2R		equ 0		;(0 times)
    32 = 0000			FEAT_VOLUMEONLYG3R		equ 0		;(0 times)
    33 = 0000			FEAT_TABLETYPE		equ 0		;(0 times)
    34 = 0000			FEAT_TABLEMODE		equ 0		;(0 times)
    35 = 0000			FEAT_TABLEGO		equ 0		;(0 times)
    36 = 0001			FEAT_AUDCTLMANUALSET		equ 1		;(1 times)
    37 = 0000			FEAT_VOLUMEMIN		equ 0		;(0 times)
    38 = 0000			FEAT_EFFECTVIBRATO		equ 0		;(0 times)
    39 = 0000			FEAT_EFFECTFSHIFT		equ 0		;(0 times)
    13 					.echo '$R RMTPLAY ',track_variables,'..',RMTPLAYEREND," 'assets/intro.feat'"
    13 				$R RMTPLAY $35E0..$3C01 'assets/intro.feat'
Source: intro.a65
   103 3C01				RMT 'assets/intro.rmt' MODULE_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RMT [Source: res6502.asm]
     2 = 0649			len = .filesize('assets/intro.rmt')
    28 3C01				org main.MODULE_ADDRESS
     2 4100				.get [$100] 'assets/intro.rmt',0,6				// wczytujemy plik do bufora MADS'a
     6 = 4100			new_add = MAIN.MODULE_ADDRESS						// nowy adres dla modulu RMT
     8 = 4100			old_add	= .wget[$102]					// stary adres modulu RMT
    10 = 0643			length	= .wget[$104] - old_add + 1			// dlugosc pliku RMT bez naglowka DOS'u
    12 = 0000			ofset	= new_add-old_add
    14 4100				.get [old_add-6] 'assets/intro.rmt'
    16  [40FC] 00			.put[old_add-4] = .lo(new_add)			// poprawiamy nagwek DOS'a
    17  [40FD] 41			.put[old_add-3] = .hi(new_add)			// tak aby zawieral informacje o nowym
    19  [40FE] 42			.put[old_add-2] = .lo(new_add + length - 1)	// adresie modulu RMT
    20  [40FF] 47			.put[old_add-1] = .hi(new_add + length - 1)
    22 = 0034			type	= .get[old_add+3]
    24 = 4110			pinst	= .get[old_add+8] + .get[old_add+9]<<8
    25 = 4120			pltrc	= .get[old_add+10] + .get[old_add+11]<<8
    26 = 4136			phtrc	= .get[old_add+12] + .get[old_add+13]<<8
    27 = 46FB			ptlst	= .get[old_add+14] + .get[old_add+15]<<8
    29  [4108] 10			.put[old_add+8] = .lo(pinst+ofset)
    30  [4109] 41			.put[old_add+9] = .hi(pinst+ofset)
    32  [410A] 20			.put[old_add+10] = .lo(pltrc+ofset)
    33  [410B] 41			.put[old_add+11] = .hi(pltrc+ofset)
    35  [410C] 36			.put[old_add+12] = .lo(phtrc+ofset)
    36  [410D] 41			.put[old_add+13] = .hi(phtrc+ofset)
    38  [410E] FB			.put[old_add+14] = .lo(ptlst+ofset)
    39  [410F] 46			.put[old_add+15] = .hi(ptlst+ofset)
    43 = 414C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4110] 4C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4111] 41			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4180				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4112] 80			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4113] 41			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 419C				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4114] 9C			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4115] 41			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 41C7				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4116] C7			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4117] 41			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 41F5				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [4118] F5			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [4119] 41			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4214				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [411A] 14			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [411B] 42			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 422A				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [411C] 2A			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [411D] 42			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    43 = 4249				?TMP = .GET[PINST+#*2] + .GET[PINST+#*2+1]<<8
    43  [411E] 49			.PUT[PINST+#*2] = .LO(?TMP+OFSET)
    43  [411F] 42			.PUT[PINST+#*2+1] = .HI(?TMP+OFSET)
    52 = 425A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4120] 5A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4136] 42			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 426A				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4121] 6A			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4137] 42			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 429C				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4122] 9C			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4138] 42			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 42EB				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4123] EB			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4139] 42			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 431D				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4124] 1D			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413A] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4348				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4125] 48			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413B] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4369				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4126] 69			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413C] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 439B				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4127] 9B			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413D] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 43CB				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4128] CB			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413E] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 43E6				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4129] E6			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [413F] 43			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 442E				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412A] 2E			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4140] 44			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4476				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412B] 76			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4141] 44			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4496				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412C] 96			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4142] 44			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 44D4				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412D] D4			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4143] 44			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4512				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412E] 12			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4144] 45			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4550				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [412F] 50			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4145] 45			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4564				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4130] 64			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4146] 45			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 45A0				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4131] A0			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4147] 45			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 45DD				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4132] DD			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4148] 45			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4620				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4133] 20			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [4149] 46			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 4652				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4134] 52			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [414A] 46			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    52 = 46B2				?TMP = .GET[PLTRC+#] + .GET[PHTRC+#]<<8
    52  [4135] B2			.PUT[PLTRC+#] = .LO(?TMP+OFSET)
    52  [414B] 46			.PUT[PHTRC+#] = .HI(?TMP+OFSET)
    66 = 0004				skip=4
    70 = 46FB				?TMP = .GET[PTLST+#*SKIP+2] + .GET[PTLST+#*SKIP+3]<<8
    70  [4741] FB			.PUT[PTLST+#*SKIP+2] = .LO(?TMP+OFSET)
    70  [4742] 46			.PUT[PTLST+#*SKIP+3] = .HI(?TMP+OFSET)
    31 4743			_end
    32 					.print '$R RMT     ',main.MODULE_ADDRESS,'..',main.MODULE_ADDRESS+len-6," 'assets/intro.rmt'"
    32 				$R RMT     $4100..$4743 'assets/intro.rmt'
Source: intro.a65
   104 				.endl
   105
   106 				; -----------------------------------------------------------
   107
   108 4743				org CODEORIGIN
   109
   110 0C00				STATICDATA
Macro: STATICDATA [Source: intro.a65]
     1 0C00-23DF> 04 54 52 55 + .by  $04 $54 $52 $55 $45 $00 $05 $46  $41 $4C $53 $45 $00 $00 $00 $0A  $39 $65 $61 $72 $00 $12 $14 $11
     2 0C18 19 0C 00 26 35 6E + .by  $19 $0C $00 $26 $35 $6E $69 $74  $65 $64 $00 $25 $61 $72 $74 $68  $00 $25 $6D $70 $69 $72 $65 $00
     3 0C30 69 73 00 73 74 69 + .by  $69 $73 $00 $73 $74 $69 $6C $6C  $00 $66 $69 $67 $68 $74 $69 $6E  $67 $0E $00 $23 $21 $66 $74 $65
     4 0C48 72 00 18 00 79 65 + .by  $72 $00 $18 $00 $79 $65 $61 $72  $73 $00 $69 $6E $00 $6D $69 $6C  $69 $74 $61 $72 $79 $0C $00 $79
     5 0C60 6F 75 00 68 61 76 + .by  $6F $75 $00 $68 $61 $76 $65 $00  $20 $66 $69 $6E $61 $6C $6C $79  $00 $66 $75 $6C $66 $69 $6C $6C
     6 0C78 65 64 00 79 6F 75 + .by  $65 $64 $00 $79 $6F $75 $72 $00  $63 $6F $6E $74 $72 $61 $63 $74  $0E $00 $26 $26 $6F $72 $00 $61
     7 0C90 00 6C 6F 6E 67 00 + .by  $00 $6C $6F $6E $67 $00 $74 $69  $6D $65 $00 $79 $6F $75 $00 $64  $72 $65 $61 $6D $65 $64 $00 $61
     8 0CA8 62 6F 75 74 00 79 + .by  $62 $6F $75 $74 $00 $79 $6F $75  $72 $00 $21 $6F $77 $6E $00 $76  $65 $6E $74 $75 $72 $65 $73 $00
     9 0CC0 61 6E 64 00 74 6F + .by  $61 $6E $64 $00 $74 $6F $00 $62  $65 $00 $61 $62 $6C $65 $00 $74  $6F $00 $64 $6F $00 $12 $77 $68
    10 0CD8 61 74 65 76 65 72 + .by  $61 $74 $65 $76 $65 $72 $00 $79  $6F $75 $00 $77 $61 $6E $74 $0E  $00 $17 $37 $69 $74 $68 $00 $72
    11 0CF0 65 63 65 69 76 65 + .by  $65 $63 $65 $69 $76 $65 $64 $00  $70 $61 $79 $00 $63 $68 $65 $63  $6B $00 $22 $79 $6F $75 $00 $77
    12 0D08 65 72 65 00 61 62 + .by  $65 $72 $65 $00 $61 $62 $6C $65  $00 $74 $6F $00 $62 $75 $79 $00  $63 $68 $65 $61 $70 $65 $73 $74
    13 0D20 00 73 68 69 70 00 + .by  $00 $73 $68 $69 $70 $00 $20 $61  $6E $64 $00 $73 $74 $69 $6C $6C  $00 $68 $61 $76 $65 $00 $73 $6F
    14 0D38 6D 65 00 63 68 61 + .by  $6D $65 $00 $63 $68 $61 $6E $67  $65 $00 $6C $65 $66 $74 $0E $00  $23 $29 $74 $00 $69 $73 $00 $75
    15 0D50 70 00 74 6F 00 79 + .by  $70 $00 $74 $6F $00 $79 $6F $75  $0C $00 $77 $68 $65 $72 $65 $00  $74 $6F $00 $67 $6F $00 $6E $6F
    16 0D68 77 0E 0E 0E 00 1D + .by  $77 $0E $0E $0E $00 $1D $80 $B0  $F2 $E5 $F3 $F3 $80 $F3 $F0 $E1  $E3 $E5 $80 $E2 $E1 $F2 $80 $F4
    17 0D80 EF 80 E3 EF EE F4 + .by  $EF $80 $E3 $EF $EE $F4 $E9 $EE  $F5 $E5 $80 $00 $0B $30 $72 $6F  $67 $72 $61 $6D $6D $69 $6E $67
    18 0D98 00 07 2D 21 24 32 + .by  $00 $07 $2D $21 $24 $32 $21 $26  $69 $00 $08 $27 $72 $61 $70 $68  $69 $63 $73 $00 $06 $22 $72 $6F
    19 0DB0 6E 69 75 00 03 2B + .by  $6E $69 $75 $00 $03 $2B $61 $7A  $00 $05 $2D $75 $73 $69 $63 $00  $06 $23 $61 $72 $75 $73 $6F $00
    20 0DC8 6C 6A 3B FF FF 6B + .by  $6C $6A $3B $FF $FF $6B $2B $2A  $6F $FF $70 $75 $9B $69 $2D $3D  $76 $FF $63 $FF $FF $62 $78 $7A
    21 0DE0 34 FF 33 36 1B 35 + .by  $34 $FF $33 $36 $1B $35 $32 $31  $2C $20 $2E $6E $FF $6D $2F $81  $72 $FF $65 $79 $7F $74 $77 $71
    22 0DF8 39 FF 30 37 7E 38 + .by  $39 $FF $30 $37 $7E $38 $3E $FF  $66 $68 $64 $FF $82 $67 $73 $61  $4C $4A $3A $FF $FF $4B $5C $5E
    23 0E10 4F FF 50 55 FF 49 + .by  $4F $FF $50 $55 $FF $49 $5F $7C  $56 $FF $43 $FF $FF $42 $58 $5A  $24 $FF $23 $26 $FF $25 $22 $21
    24 0E28 5B 3B 5D 4E FF 4D + .by  $5B $3B $5D $4E $FF $4D $3F $FF  $52 $FF $45 $59 $FF $54 $57 $51  $28 $FF $29 $27 $FF $40 $FF $FF
    25 0E40 46 48 44 FF FF 47 + .by  $46 $48 $44 $FF $FF $47 $53 $41  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    26 0E58 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    27 0E70 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    28 0E88 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    29 0EA0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    30 0EB8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
Source: intro.a65
   111
   112 0EC8			START
   113 0EC8 BA				tsx
   114 0EC9 8E 3A 1F			stx MAIN.@halt+1
   115
   116 					.ifdef fmulinit
   117 					fmulinit
   118 					eif
   119
   120 					ift DATAORIGIN+VARINITSIZE > $BFFF
   121 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   122 					els
   123 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   123 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   123 0ECC A9 E0 85 86 A9 23 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   123 0ED4 A9 0E 85 8A A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   123 0EDC A9 00 85 82		 MVA #0 @FILL.PTR2
   123 0EE0 20 03 20		 JSR @FILL
   124 					eif
   125
   126 0EE3 A2 0F			ldx #$0f
   127 0EE5 BD 40 03 9D 3D 1F + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   128
   129 0EEE E8				inx		; X = 0 !!!
   130 0EEF 86 8E			stx bp		; lo BP = 0
   131
   132 0EF1				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: intro.a65]
Source: intro.a65
   133
   134 0EF1			.local	MAIN						; PROCEDURE
   135
   136 0EF1 4C 65 1A			jmp l_01CF
   137
   138 				; -----------------------------------------------------------
   139
   140 0EF4			.local	SYSTEM						; UNIT
   141
   142 0EF4			.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER
   143
   144 				; -----------------------------------------------------------
   145
   146 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   147 				; as Pointer
   148 0EF4 B5 98 85 86			mva :STACKORIGIN,x A
   149 0EF8 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   150 0EFC CA				dex						; sub bx, 1
   151
   152
   153 				; ---------------------  ASM Block 004  ---------------------
   154
   155 0EFD A0 00			ldy #0
   156 0EFF B1 86 8D 56 20		mva (edx),y Result
   157
   158
   159 0F04			@exit
   160
   161 				; -----------------------------------------------------------
   162
   163 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   164 				; as Pointer
   165
   166 0F04 E8				inx						; add bx, 1
   167 0F05 AD 56 20 95 98		mva RESULT :STACKORIGIN,x
   168
   169 					.ifdef @new
   170 					@FreeMem #@VarData #@VarDataSize
   171 					eif
   172
   173 				; -----------------------------------------------------------
   174
   175 = 0086			A	= edx
   176 = 2056			RESULT	= DATAORIGIN+$000B
   177
   178 = 2056			@VarData	= RESULT
   179 = 0001			@VarDataSize	= 1
   180
   181 0F0A 60				rts						; ret
   182 				.endl
   183
   184 0F0B			.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER
   185
   186 				; -----------------------------------------------------------
   187
   188 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   189 				; as Pointer
   190 0F0B B5 98 85 8A			mva :STACKORIGIN,x VALUE
   191 0F0F CA				dex						; sub bx, 1
   192
   193 				; -----------------------------------------------------------
   194
   195 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   196 				; as Pointer
   197 0F10 B5 98 85 86			mva :STACKORIGIN,x A
   198 0F14 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   199 0F18 CA				dex						; sub bx, 1
   200
   201
   202 				; ---------------------  ASM Block 021  ---------------------
   203
   204 0F19 A0 00			ldy #0
   205 0F1B A5 8A 91 86			mva value (edx),y
   206
   207
   208 				; -----------------------------------------------------------
   209
   210 = 0086			A	= edx
   211 = 008A			VALUE	= ecx
   212
   213 0F1F			@exit
   214 					.ifdef @new
   215 					@FreeMem #@VarData #@VarDataSize
   216 					eif
   217 0F1F 60				rts						; ret
   218 				.endl
   219
   220 0F20			.local	FILLBYTE_01F7					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   221
   222 				; -----------------------------------------------------------
   223
   224 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   225 				; as Pointer
   226 0F20 B5 98 85 82			mva :STACKORIGIN,x VALUE
   227 0F24 CA				dex						; sub bx, 1
   228
   229 				; -----------------------------------------------------------
   230
   231 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   232 				; as Pointer
   233 0F25 B5 98 85 8A			mva :STACKORIGIN,x COUNT
   234 0F29 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   235 0F2D CA				dex						; sub bx, 1
   236
   237 				; -----------------------------------------------------------
   238
   239 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   240 				; as Pointer
   241 0F2E B5 98 85 86			mva :STACKORIGIN,x A
   242 0F32 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   243 0F36 CA				dex						; sub bx, 1
   244
   245
   246 				; ---------------------  ASM Block 029  ---------------------
   247
   248 0F37 20 03 20			jsr @fill
   249
   250
   251 				; -----------------------------------------------------------
   252
   253 = 0086			A	= edx
   254 = 008A			COUNT	= ecx
   255 = 0082			VALUE	= eax
   256
   257 0F3A			@exit
   258 					.ifdef @new
   259 					@FreeMem #@VarData #@VarDataSize
   260 					eif
   261 0F3A 60				rts						; ret
   262 				.endl
   263
   264 0F3B			.local	MOVE_0201					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   265
   266 				; -----------------------------------------------------------
   267
   268 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   269 				; as Pointer
   270 0F3B B5 98 85 82			mva :STACKORIGIN,x COUNT
   271 0F3F B5 A8 85 83			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   272 0F43 CA				dex						; sub bx, 1
   273
   274 				; -----------------------------------------------------------
   275
   276 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   277 				; as Pointer
   278 0F44 B5 98 85 8A			mva :STACKORIGIN,x DEST
   279 0F48 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   280 0F4C CA				dex						; sub bx, 1
   281
   282 				; -----------------------------------------------------------
   283
   284 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   285 				; as Pointer
   286 0F4D B5 98 85 86			mva :STACKORIGIN,x SOURCE
   287 0F51 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   288 0F55 CA				dex						; sub bx, 1
   289
   290
   291 				; ---------------------  ASM Block 031  ---------------------
   292
   293 0F56 20 AE 1F			jsr @move
   294
   295
   296 				; -----------------------------------------------------------
   297
   298 = 0086			SOURCE	= edx
   299 = 008A			DEST	= ecx
   300 = 0082			COUNT	= eax
   301
   302 0F59			@exit
   303 					.ifdef @new
   304 					@FreeMem #@VarData #@VarDataSize
   305 					eif
   306 0F59 60				rts						; ret
   307 				.endl
   308
   309 0F5A			.local	MOVE_020B					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   310
   311 				; -----------------------------------------------------------
   312
   313 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   314 				; as Pointer
   315 0F5A B5 98 85 82			mva :STACKORIGIN,x COUNT
   316 0F5E B5 A8 85 83			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   317 0F62 CA				dex						; sub bx, 1
   318
   319 				; -----------------------------------------------------------
   320
   321 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   322 				; as Pointer
   323 0F63 B5 98 85 8A			mva :STACKORIGIN,x DEST
   324 0F67 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   325 0F6B CA				dex						; sub bx, 1
   326
   327 				; -----------------------------------------------------------
   328
   329 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   330 				; as Pointer
   331 0F6C B5 98 85 86			mva :STACKORIGIN,x SOURCE
   332 0F70 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   333 0F74 CA				dex						; sub bx, 1
   334
   335
   336 				; ---------------------  ASM Block 033  ---------------------
   337
   338 0F75 20 AE 1F			jsr @move
   339
   340
   341 				; -----------------------------------------------------------
   342
   343 = 0086			SOURCE	= edx
   344 = 008A			DEST	= ecx
   345 = 0082			COUNT	= eax
   346
   347 0F78			@exit
   348 					.ifdef @new
   349 					@FreeMem #@VarData #@VarDataSize
   350 					eif
   351 0F78 60				rts						; ret
   352 				.endl
   353
   354 				; -----------------------------------------------------------
   355
   356 = 0648			M_PI_2	= $0648
   357 = 0192			D_PI_2	= $0192
   358 = 0004			D_PI_180	= $0004
   359 = 0000			MGTIA	= $0000
   360 = 0080			MVBXE	= $0080
   361 = 0000			VBXE_XDLADR	= $0000
   362 = 0100			VBXE_BCBADR	= $0100
   363 = 1000			VBXE_MAPADR	= $1000
   364 = 5000			VBXE_OVRADR	= $5000
   365 = B000			VBXE_WINDOW	= $B000
   366 = 0000			IDLI	= $0000
   367 = 0001			IVBL	= $0001
   368 = 00FE			CH_DELCHR	= $00FE
   369 = 009B			CH_ENTER	= $009B
   370 = 001B			CH_ESC	= $001B
   371 = 001C			CH_CURS_UP	= $001C
   372 = 001D			CH_CURS_DOWN	= $001D
   373 = 001E			CH_CURS_LEFT	= $001E
   374 = 001F			CH_CURS_RIGHT	= $001F
   375 = 007F			CH_TAB	= $007F
   376 = 009B			CH_EOL	= $009B
   377 = 007D			CH_CLR	= $007D
   378 = 00FD			CH_BELL	= $00FD
   379 = 007E			CH_DEL	= $007E
   380 = 009C			CH_DELLINE	= $009C
   381 = 009D			CH_INSLINE	= $009D
   382 = 0000			COLOR_BLACK	= $0000
   383 = 000E			COLOR_WHITE	= $000E
   384 = 0032			COLOR_RED	= $0032
   385 = 0096			COLOR_CYAN	= $0096
   386 = 0068			COLOR_VIOLET	= $0068
   387 = 00C4			COLOR_GREEN	= $00C4
   388 = 0074			COLOR_BLUE	= $0074
   389 = 00EE			COLOR_YELLOW	= $00EE
   390 = 004A			COLOR_ORANGE	= $004A
   391 = 00E4			COLOR_BROWN	= $00E4
   392 = 003C			COLOR_LIGHTRED	= $003C
   393 = 0004			COLOR_GRAY1	= $0004
   394 = 0006			COLOR_GRAY2	= $0006
   395 = 000A			COLOR_GRAY3	= $000A
   396 = 00CC			COLOR_LIGHTGREEN	= $00CC
   397 = 007C			COLOR_LIGHTBLUE	= $007C
   398 = 0004			FMOPENREAD	= $0004
   399 = 0008			FMOPENWRITE	= $0008
   400 = 0009			FMOPENAPPEND	= $0009
   401 = 000C			FMOPENREADWRITE	= $000C
   402 = 204B			SCREENWIDTH	= DATAORIGIN+$0000
   403 = 204D			SCREENHEIGHT	= DATAORIGIN+$0002
   404 = 204F			DATESEPARATOR	= DATAORIGIN+$0004
   405 = 2050			FILEMODE	= DATAORIGIN+$0005
   406 = 2051			SCREENMODE	= DATAORIGIN+$0006
   407 = 2052			IORESULT	= DATAORIGIN+$0007
   408 = 2053			EOLN	= DATAORIGIN+$0008
   409 = 2054			RNDSEED	= DATAORIGIN+$0009
   410
   411 				.endl							; UNIT SYSTEM
   412
   413 				; -----------------------------------------------------------
   414
   415 0F79			.local	ATARI						; UNIT
   416
   417 				; -----------------------------------------------------------
   418
   419 = 0012			RTCLOK	= $0012
   420 = 004D			ATRACT	= $004D
   421 = 0052			LMARGIN	= $0052
   422 = 0053			RMARGIN	= $0053
   423 = 0054			ROWCRS	= $0054
   424 = 0055			COLCRS	= $0055
   425 = 0057			DINDEX	= $0057
   426 = 0058			SAVMSC	= $0058
   427 = 0200			VDSLST	= $0200
   428 = 0230			SDLSTL	= $0230
   429 = 0290			TXTROW	= $0290
   430 = 0291			TXTCOL	= $0291
   431 = 0293			TINDEX	= $0293
   432 = 0294			TXTMSC	= $0294
   433 = 022F			SDMCTL	= $022F
   434 = 026F			GPRIOR	= $026F
   435 = 02F0			CRSINH	= $02F0
   436 = 02F3			CHACT	= $02F3
   437 = 02F4			CHBAS	= $02F4
   438 = 02FC			CH	= $02FC
   439 = 02C0			PCOLR0	= $02C0
   440 = 02C1			PCOLR1	= $02C1
   441 = 02C2			PCOLR2	= $02C2
   442 = 02C3			PCOLR3	= $02C3
   443 = 02C4			COLOR0	= $02C4
   444 = 02C5			COLOR1	= $02C5
   445 = 02C6			COLOR2	= $02C6
   446 = 02C7			COLOR3	= $02C7
   447 = 02C8			COLOR4	= $02C8
   448 = 02C8			COLBAKS	= $02C8
   449 = D000			HPOSP0	= $D000
   450 = D001			HPOSP1	= $D001
   451 = D002			HPOSP2	= $D002
   452 = D003			HPOSP3	= $D003
   453 = D004			HPOSM0	= $D004
   454 = D005			HPOSM1	= $D005
   455 = D006			HPOSM2	= $D006
   456 = D007			HPOSM3	= $D007
   457 = D008			SIZEP0	= $D008
   458 = D009			SIZEP1	= $D009
   459 = D00A			SIZEP2	= $D00A
   460 = D00B			SIZEP3	= $D00B
   461 = D00C			SIZEM	= $D00C
   462 = D00D			GRAFP0	= $D00D
   463 = D00E			GRAFP1	= $D00E
   464 = D00F			GRAFP2	= $D00F
   465 = D010			GRAFP3	= $D010
   466 = D011			GRAFM	= $D011
   467 = D004			P0PF	= $D004
   468 = D014			PAL	= $D014
   469 = D012			COLPM0	= $D012
   470 = D013			COLPM1	= $D013
   471 = D014			COLPM2	= $D014
   472 = D015			COLPM3	= $D015
   473 = D016			COLPF0	= $D016
   474 = D017			COLPF1	= $D017
   475 = D018			COLPF2	= $D018
   476 = D019			COLPF3	= $D019
   477 = D01A			COLBK	= $D01A
   478 = D01B			PRIOR	= $D01B
   479 = D01D			GRACTL	= $D01D
   480 = D01E			HITCLR	= $D01E
   481 = D200			AUDF1	= $D200
   482 = D201			AUDC1	= $D201
   483 = D202			AUDF2	= $D202
   484 = D203			AUDC2	= $D203
   485 = D204			AUDF3	= $D204
   486 = D205			AUDC3	= $D205
   487 = D206			AUDF4	= $D206
   488 = D207			AUDC4	= $D207
   489 = D208			AUDCTL	= $D208
   490 = D20F			SKSTAT	= $D20F
   491 = D301			PORTB	= $D301
   492 = D400			DMACTL	= $D400
   493 = D401			CHACTL	= $D401
   494 = D402			DLISTL	= $D402
   495 = D404			HSCROL	= $D404
   496 = D405			VSCROL	= $D405
   497 = D407			PMBASE	= $D407
   498 = D409			CHBASE	= $D409
   499 = D40A			WSYNC	= $D40A
   500 = D40B			VCOUNT	= $D40B
   501 = D40C			PENH	= $D40C
   502 = D40D			PENV	= $D40D
   503 = D40E			NMIEN	= $D40E
   504
   505 				.endl							; UNIT ATARI
   506
   507 				; -----------------------------------------------------------
   508
   509 0F79			.local	B_UTILS						; UNIT
   510
   511 				; -----------------------------------------------------------
   512
   513
   514 				.endl							; UNIT B_UTILS
   515
   516 				; -----------------------------------------------------------
   517
   518 0F79			.local	B_SYSTEM					; UNIT
   519
   520 0F79			.local	SYSTEMOFF_0225					; PROCEDURE | ASSEMBLER | OVERLOAD
   521
   522 				; -----------------------------------------------------------
   523
   524 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   525 				; as Pointer
   526 0F79 B5 98 8D 58 20		mva :STACKORIGIN,x PORT_B
   527 0F7E CA				dex						; sub bx, 1
   528
   529
   530 				; ---------------------  ASM Block 047  ---------------------
   531
   532
   533 						;lda:cmp:req 20 ;; removed due to problem with nmien = 0 already set
   534 0F7F 78					sei
   535 0F80 A9 00 8D 0E D4			mva #0 NMIEN
   536
   537 0F85 AD 58 20 8D 01 D3			mva port_b PORTB
   538 0F8B A9 B5 8D FA FF A9 + 		mwa #__nmi NMIVEC
   539
   540 0F95 A9 CB				lda <__iret
   541 0F97 8D FE FF				sta IRQVEC
   542 0F9A 8D C9 0F				sta __vblvec
   543 0F9D 8D BB 0F				sta __dlivec
   544
   545 0FA0 A9 0F				lda >__iret
   546 0FA2 8D FF FF				sta IRQVEC+1
   547 0FA5 8D CA 0F				sta __vblvec+1
   548 0FA8 8D BC 0F				sta __dlivec+1
   549
   550 0FAB A9 40 8D 0E D4			mva #$40 NMIEN
   551 0FB0 8D 57 20				sta __nmien
   552 0FB3 D0 17				bne __stop
   553 0FB5			__nmi
   554 0FB5 2C 0F D4				bit NMIST
   555 0FB8 10 04				bpl __vbl
   556 0FBA 4C BB 0F				jmp __dlivec
   557 = 0FBB			.def :__dlivec = *-2
   558 0FBD 40					rti
   559 0FBE			__vbl
   560 0FBE E6 14				inc rtclok+2
   561 0FC0 D0 06				bne __vblvec-1
   562 0FC2 E6 13				inc rtclok+1
   563 0FC4 D0 02				bne __vblvec-1
   564 0FC6 E6 12				inc rtclok
   565 0FC8 4C C9 0F				jmp __vblvec
   566 = 0FC9			.def :__vblvec = *-2
   567 = 0FCB			.def :__iret
   568 0FCB 40			    	rti
   569 0FCC			__stop
   570
   571
   572 				; -----------------------------------------------------------
   573
   574 = 2058			PORT_B	= DATAORIGIN+$000D
   575
   576 = 2058			@VarData	= PORT_B
   577 = 0001			@VarDataSize	= 1
   578
   579
   580 0FCC			@exit
   581 					.ifdef @new
   582 					@FreeMem #@VarData #@VarDataSize
   583 					eif
   584 0FCC 60				rts						; ret
   585 				.endl
   586
   587 0FCD			.local	SYSTEMOFF_0229					; PROCEDURE | OVERLOAD
   588
   589
   590
   591
   592 				; optimize FAIL ('SYSTEMOFF_0225', B_SYSTEM), line = 137
   593 0FCD E8				inx
   594 0FCE A9 FE 95 98			mva #$FE :STACKORIGIN,x
   595 0FD2 20 79 0F			jsr SYSTEMOFF_0225
   596
   597 0FD5			@exit
   598 					.ifdef @new
   599 					@FreeMem #@VarData #@VarDataSize
   600 					eif
   601 0FD5 60				rts						; ret
   602 				.endl
   603
   604 0FD6			.local	ENABLEVBLI					; PROCEDURE | ASSEMBLER
   605
   606 				; -----------------------------------------------------------
   607
   608 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   609 				; as Pointer
   610 0FD6 B5 98 8D 59 20		mva :STACKORIGIN,x VBLPTR
   611 0FDB B5 A8 8D 5A 20		mva :STACKORIGIN+STACKWIDTH,x VBLPTR+1
   612 0FE0 CA				dex						; sub bx, 1
   613
   614
   615 				; ---------------------  ASM Block 049  ---------------------
   616
   617
   618 0FE1 A5 14 C5 14 F0 FC			lda:cmp:req 20
   619 0FE7 A9 00 8D 0E D4			mva #0 NMIEN
   620 0FEC AD 59 20 8D C9 0F + 		mwa vblptr __vblvec
   621 0FF8 AD 57 20				lda __nmien
   622 0FFB 09 40				ora #$40
   623 0FFD 8D 0E D4				sta NMIEN
   624 1000 8D 57 20				sta __nmien
   625
   626
   627 				; -----------------------------------------------------------
   628
   629 = 2059			VBLPTR	= DATAORIGIN+$000E
   630
   631 = 2059			@VarData	= VBLPTR
   632 = 0002			@VarDataSize	= 2
   633
   634
   635 1003			@exit
   636 					.ifdef @new
   637 					@FreeMem #@VarData #@VarDataSize
   638 					eif
   639 1003 60				rts						; ret
   640 				.endl
   641
   642 1004			.local	DISABLEVBLI					; PROCEDURE | ASSEMBLER
   643
   644
   645 				; ---------------------  ASM Block 050  ---------------------
   646
   647
   648 1004 A5 14 C5 14 F0 FC			lda:cmp:req 20
   649 100A A9 00 8D 0E D4			mva #0 NMIEN
   650 100F A9 CB 8D C9 0F A9 + 		mwa #__iret __vblvec
   651 1019 AD 57 20				lda __nmien
   652 101C 09 40				ora #$40
   653 101E 8D 0E D4				sta NMIEN
   654 1021 8D 57 20				sta __nmien
   655
   656
   657 1024			@exit
   658 					.ifdef @new
   659 					@FreeMem #@VarData #@VarDataSize
   660 					eif
   661 1024 60				rts						; ret
   662 				.endl
   663
   664 1025			.local	ENABLEDLI					; PROCEDURE | ASSEMBLER
   665
   666 				; -----------------------------------------------------------
   667
   668 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   669 				; as Pointer
   670 1025 B5 98 8D 5B 20		mva :STACKORIGIN,x DLIPTR
   671 102A B5 A8 8D 5C 20		mva :STACKORIGIN+STACKWIDTH,x DLIPTR+1
   672 102F CA				dex						; sub bx, 1
   673
   674
   675 				; ---------------------  ASM Block 051  ---------------------
   676
   677
   678 1030 A5 14 C5 14 F0 FC			lda:cmp:req 20
   679 1036 A9 00 8D 0E D4			mva #0 NMIEN
   680 103B AD 5B 20 8D BB 0F + 		mwa dliptr __dlivec
   681 1047 A9 C0 8D 0E D4			mva #$c0 NMIEN
   682 104C 8D 57 20				sta __nmien
   683
   684
   685 				; -----------------------------------------------------------
   686
   687 = 205B			DLIPTR	= DATAORIGIN+$0010
   688
   689 = 205B			@VarData	= DLIPTR
   690 = 0002			@VarDataSize	= 2
   691
   692
   693 104F			@exit
   694 					.ifdef @new
   695 					@FreeMem #@VarData #@VarDataSize
   696 					eif
   697 104F 60				rts						; ret
   698 				.endl
   699
   700 1050			.local	DISABLEDLI					; PROCEDURE | ASSEMBLER
   701
   702
   703 				; ---------------------  ASM Block 052  ---------------------
   704
   705
   706 1050 A5 14 C5 14 F0 FC			lda:cmp:req 20
   707 1056 A9 40 8D 0E D4			mva #$40 NMIEN
   708 105B 8D 57 20				sta __nmien
   709
   710
   711 105E			@exit
   712 					.ifdef @new
   713 					@FreeMem #@VarData #@VarDataSize
   714 					eif
   715 105E 60				rts						; ret
   716 				.endl
   717
   718 105F			.local	WAITFRAME					; PROCEDURE | ASSEMBLER
   719
   720
   721 				; ---------------------  ASM Block 053  ---------------------
   722
   723
   724 105F A5 14 C5 14 F0 FC	    lda:cmp:req rtclok+2
   725
   726
   727 1065			@exit
   728 					.ifdef @new
   729 					@FreeMem #@VarData #@VarDataSize
   730 					eif
   731 1065 60				rts						; ret
   732 				.endl
   733
   734 1066			.local	WAITFRAMES					; PROCEDURE
   735
   736 				; -----------------------------------------------------------
   737
   738 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   739 				; as Pointer
   740 1066 B5 98 8D 5D 20		mva :STACKORIGIN,x FRAMES
   741 106B CA				dex						; sub bx, 1
   742
   743
   744
   745
   746 				; --- WhileProlog
   747 106C			l_0241
   748
   749 				; optimize OK (B_SYSTEM), line = 210
   750
   751 106C AD 5D 20			lda FRAMES
   752 106F C9 00			cmp #$00
   753 1071 F0 02			seq
   754 1073 B0 03			bcs @+
   755 1075 4C 81 10			jmp l_0250
   756 1078			@
   757
   758 				; optimize FAIL ('WAITFRAME', B_SYSTEM), line = 211
   759 1078 20 5F 10			jsr WAITFRAME
   760
   761 				; optimize FAIL (0, B_SYSTEM), line = 212
   762 107B CE 5D 20			dec FRAMES
   763
   764 				; --- WhileDoEpilog
   765 107E			c_0241
   766 107E 4C 6C 10			jmp l_0241
   767 1081			l_0250
   768 1081			b_0241
   769
   770 				; -----------------------------------------------------------
   771
   772 = 205D			FRAMES	= DATAORIGIN+$0012
   773
   774 = 205D			@VarData	= FRAMES
   775 = 0001			@VarDataSize	= 1
   776
   777
   778 1081			@exit
   779 					.ifdef @new
   780 					@FreeMem #@VarData #@VarDataSize
   781 					eif
   782 1081 60				rts						; ret
   783 				.endl
   784
   785 1082			.local	SETCHARSET					; PROCEDURE
   786
   787 				; -----------------------------------------------------------
   788
   789 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   790 				; as Pointer
   791 1082 B5 98 8D 5E 20		mva :STACKORIGIN,x MSB
   792 1087 CA				dex						; sub bx, 1
   793
   794
   795
   796
   797 				; optimize OK (B_SYSTEM), line = 218
   798
   799 1088 AD 5E 20 8D 09 D4		mva MSB ATARI.CHBASE
   800
   801 				; -----------------------------------------------------------
   802
   803 = 205E			MSB	= DATAORIGIN+$0013
   804
   805 = 205E			@VarData	= MSB
   806 = 0001			@VarDataSize	= 1
   807
   808
   809 108E			@exit
   810 					.ifdef @new
   811 					@FreeMem #@VarData #@VarDataSize
   812 					eif
   813 108E 60				rts						; ret
   814 				.endl
   815
   816 				; -----------------------------------------------------------
   817
   818 = 2057			__NMIEN	= DATAORIGIN+$000C
   819 = 0080			PORTB_SELFTEST_OFF	= $0080
   820 = 0002			PORTB_BASIC_OFF	= $0002
   821 = 0001			PORTB_SYSTEM_ON	= $0001
   822
   823 				.endl							; UNIT B_SYSTEM
   824
   825 				; -----------------------------------------------------------
   826
   827 108F			.local	DOS						; UNIT
   828
   829 				; -----------------------------------------------------------
   830
   831 = D014			PALNTSC	= $D014
   832
   833 				.endl							; UNIT DOS
   834
   835 				; -----------------------------------------------------------
   836
   837 108F			.local	STRUTILS					; UNIT
   838
   839 				; -----------------------------------------------------------
   840
   841
   842 				.endl							; UNIT STRUTILS
   843
   844 				; -----------------------------------------------------------
   845
   846 108F			.local	SYSUTILS					; UNIT
   847
   848 				; -----------------------------------------------------------
   849
   850 = 0001			FAREADONLY	= $0001
   851 = 0002			FAHIDDEN	= $0002
   852 = 0004			FASYSFILE	= $0004
   853 = 0008			FAVOLUMEID	= $0008
   854 = 0010			FADIRECTORY	= $0010
   855 = 0020			FAARCHIVE	= $0020
   856 = 003F			FAANYFILE	= $003F
   857
   858 				.endl							; UNIT SYSUTILS
   859
   860 				; -----------------------------------------------------------
   861
   862 108F			.local	B_CRT						; UNIT
   863
   864 108F			.local	CRT_INIT_027D					; PROCEDURE | OVERLOAD
   865
   866 				; -----------------------------------------------------------
   867
   868 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   869 				; as Pointer
   870 108F B5 98 8D 6B 20		mva :STACKORIGIN,x HEIGHT
   871 1094 CA				dex						; sub bx, 1
   872
   873 				; -----------------------------------------------------------
   874
   875 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   876 				; as Pointer
   877 1095 B5 98 8D 6A 20		mva :STACKORIGIN,x WIDTH
   878 109A CA				dex						; sub bx, 1
   879
   880 				; -----------------------------------------------------------
   881
   882 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   883 				; as Pointer
   884 109B B5 98 8D 68 20		mva :STACKORIGIN,x VRAM_ADDRESS
   885 10A0 B5 A8 8D 69 20		mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
   886 10A5 CA				dex						; sub bx, 1
   887
   888
   889
   890
   891 				; optimize OK (B_CRT), line = 483
   892
   893 10A6 AD 68 20 8D 5F 20		mva VRAM_ADDRESS CRT_VRAM
   894 10AC AD 69 20 8D 60 20		mva VRAM_ADDRESS+1 CRT_VRAM+1
   895
   896 				; optimize OK (B_CRT), line = 484
   897
   898 10B2 AD 6A 20 8D 63 20		mva WIDTH CRT_SCREENWIDTH
   899
   900 				; optimize OK (B_CRT), line = 485
   901
   902 10B8 AD 6B 20 8D 64 20		mva HEIGHT CRT_SCREENHEIGHT
   903
   904 				; optimize OK (B_CRT), line = 486
   905
   906 10BE AD 6B 20			lda HEIGHT
   907 10C1 85 8A			sta :ecx
   908 10C3 AD 6A 20			lda WIDTH
   909 10C6 85 82			sta :eax
   910 					.ifdef fmulinit
   911 					fmulu_8
   912 					els
   913 10C8 20 6C 1F			imulCL
   914 					eif
   915 10CB A5 82			lda :eax
   916 10CD 8D 61 20			sta CRT_SIZE
   917 10D0 A5 83			lda :eax+1
   918 10D2 8D 62 20			sta CRT_SIZE+1
   919
   920 				; optimize OK (B_CRT), line = 487
   921
   922 10D5 AD 5F 20 8D 65 20		mva CRT_VRAM CRT_CURSOR
   923 10DB AD 60 20 8D 66 20		mva CRT_VRAM+1 CRT_CURSOR+1
   924
   925 				; optimize OK (B_CRT), line = 488
   926
   927 10E1 A9 00 8D 67 20		mva #$00 CRT_LEFTMARGIN
   928
   929 				; -----------------------------------------------------------
   930
   931 = 2068			VRAM_ADDRESS	= DATAORIGIN+$001D
   932 = 206A			WIDTH	= DATAORIGIN+$001F
   933 = 206B			HEIGHT	= DATAORIGIN+$0020
   934
   935 = 2068			@VarData	= VRAM_ADDRESS
   936 = 0004			@VarDataSize	= 4
   937
   938
   939 10E6			@exit
   940 					.ifdef @new
   941 					@FreeMem #@VarData #@VarDataSize
   942 					eif
   943 10E6 60				rts						; ret
   944 				.endl
   945
   946 10E7			.local	CRT_INIT_02B0					; PROCEDURE | OVERLOAD
   947
   948 				; -----------------------------------------------------------
   949
   950 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   951 				; as Pointer
   952 10E7 B5 98 8D 6C 20		mva :STACKORIGIN,x VRAM_ADDRESS
   953 10EC B5 A8 8D 6D 20		mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
   954 10F1 CA				dex						; sub bx, 1
   955
   956
   957
   958
   959 				; optimize FAIL ('CRT_INIT_027D', B_CRT), line = 493
   960 10F2 E8				inx
   961 10F3 AD 6C 20 95 98		mva VRAM_ADDRESS :STACKORIGIN,x
   962 10F8 AD 6D 20 95 A8		mva VRAM_ADDRESS+1 :STACKORIGIN+STACKWIDTH,x
   963 10FD E8				inx
   964 10FE A9 28 95 98			mva #$28 :STACKORIGIN,x
   965 1102 E8				inx
   966 1103 A9 18 95 98			mva #$18 :STACKORIGIN,x
   967 1107 20 8F 10			jsr CRT_INIT_027D
   968
   969 				; -----------------------------------------------------------
   970
   971 = 206C			VRAM_ADDRESS	= DATAORIGIN+$0021
   972
   973 = 206C			@VarData	= VRAM_ADDRESS
   974 = 0002			@VarDataSize	= 2
   975
   976
   977 110A			@exit
   978 					.ifdef @new
   979 					@FreeMem #@VarData #@VarDataSize
   980 					eif
   981 110A 60				rts						; ret
   982 				.endl
   983
   984 110B			.local	CRT_GOTOXY					; PROCEDURE
   985
   986 				; -----------------------------------------------------------
   987
   988 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   989 				; as Pointer
   990 110B B5 98 8D 6F 20		mva :STACKORIGIN,x Y
   991 1110 CA				dex						; sub bx, 1
   992
   993 				; -----------------------------------------------------------
   994
   995 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   996 				; as Pointer
   997 1111 B5 98 8D 6E 20		mva :STACKORIGIN,x X
   998 1116 CA				dex						; sub bx, 1
   999
  1000
  1001
  1002
  1003 				; optimize OK (B_CRT), line = 516
  1004
  1005 1117 AD 63 20			lda CRT_SCREENWIDTH
  1006 111A 85 8A			sta :ecx
  1007 111C AD 6F 20			lda Y
  1008 111F 85 82			sta :eax
  1009 					.ifdef fmulinit
  1010 					fmulu_8
  1011 					els
  1012 1121 20 6C 1F			imulCL
  1013 					eif
  1014 1124 A5 82			lda :eax
  1015 1126 18 6D 6E 20			add X
  1016 112A 85 A1			sta :STACKORIGIN+9
  1017 112C A5 83			lda :eax+1
  1018 112E 69 00			adc #$00
  1019 1130 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  1020 1132 A5 A1			lda :STACKORIGIN+9
  1021 1134 18 6D 5F 20			add CRT_VRAM
  1022 1138 8D 65 20			sta CRT_CURSOR
  1023 113B A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  1024 113D 6D 60 20			adc CRT_VRAM+1
  1025 1140 8D 66 20			sta CRT_CURSOR+1
  1026
  1027 				; -----------------------------------------------------------
  1028
  1029 = 206E			X	= DATAORIGIN+$0023
  1030 = 206F			Y	= DATAORIGIN+$0024
  1031
  1032 = 206E			@VarData	= X
  1033 = 0002			@VarDataSize	= 2
  1034
  1035
  1036 1143			@exit
  1037 					.ifdef @new
  1038 					@FreeMem #@VarData #@VarDataSize
  1039 					eif
  1040 1143 60				rts						; ret
  1041 				.endl
  1042
  1043 1144			.local	CRT_WRITE_02DD					; PROCEDURE | OVERLOAD
  1044
  1045 				; -----------------------------------------------------------
  1046
  1047 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1048 				; as Pointer
  1049 1144 B5 98 8D AE 11		mva :STACKORIGIN,x S
  1050 1149 B5 A8 8D AF 11		mva :STACKORIGIN+STACKWIDTH,x S+1
  1051 114E CA				dex						; sub bx, 1
  1052 					@move S #adr.S #256
  1052 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
  1052 114F AD AE 11 85 86 AD +  MWA S @MOVE.PTR1
  1052 1159 A9 70 85 8A A9 20 +  MWA #ADR.S @MOVE.PTR2
  1052 1161 A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
  1052 1169 20 AE 1F		 JSR @MOVE
  1053 116C A9 70 8D AE 11 A9 + 	mwa #adr.S S
  1054
  1055
  1056
  1057
  1058 				; optimize OK (B_CRT), line = 531
  1059
  1060 1176 AD AE 11			lda S
  1061 1179 18 69 01			add #$01
  1062 117C 85 86			sta :edx
  1063 117E AD AF 11			lda S+1
  1064 1181 69 00			adc #$00
  1065 1183 85 87			sta :edx+1
  1066 1185 AD 70 20			lda adr.S+$00
  1067 1188 85 82			sta :eax
  1068 118A AD 65 20			lda CRT_CURSOR
  1069 118D 85 8A			sta :ecx
  1070 118F AD 66 20			lda CRT_CURSOR+1
  1071 1192 85 8B			sta :ecx+1
  1072 1194 A9 00			lda #$00
  1073 1196 85 83			sta :eax+1
  1074 1198 20 AE 1F			jsr @move
  1075
  1076 				; optimize OK (B_CRT), line = 532
  1077
  1078 119B AD 65 20			lda CRT_CURSOR
  1079 119E 18 6D 70 20			add adr.S+$00
  1080 11A2 8D 65 20			sta CRT_CURSOR
  1081 11A5 AD 66 20			lda CRT_CURSOR+1
  1082 11A8 69 00			adc #$00
  1083 11AA 8D 66 20			sta CRT_CURSOR+1
  1084
  1085 				; -----------------------------------------------------------
  1086
  1087 = 2070			adr.S	= DATAORIGIN+$0025
  1088 11AD			.var S	= adr.S .word
  1089
  1090 = 11AE			@VarData	= S
  1091 = 0100			@VarDataSize	= 256
  1092
  1093
  1094 11AD			@exit
  1095 					.ifdef @new
  1096 					@FreeMem #@VarData #@VarDataSize
  1097 					eif
  1098 11AD 60				rts						; ret
  1099 = 11AE 70 20		S
  1099 				.endl
  1100
  1101 11B0			.local	CRT_WRITEXY					; PROCEDURE
  1102
  1103 				; -----------------------------------------------------------
  1104
  1105 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1106 				; as Pointer
  1107 11B0 B5 98 8D 0C 12		mva :STACKORIGIN,x S
  1108 11B5 B5 A8 8D 0D 12		mva :STACKORIGIN+STACKWIDTH,x S+1
  1109 11BA CA				dex						; sub bx, 1
  1110 					@move S #adr.S #256
  1110 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
  1110 11BB AD 0C 12 85 86 AD +  MWA S @MOVE.PTR1
  1110 11C5 A9 72 85 8A A9 21 +  MWA #ADR.S @MOVE.PTR2
  1110 11CD A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
  1110 11D5 20 AE 1F		 JSR @MOVE
  1111 11D8 A9 72 8D 0C 12 A9 + 	mwa #adr.S S
  1112
  1113 				; -----------------------------------------------------------
  1114
  1115 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1116 				; as Pointer
  1117 11E2 B5 98 8D 71 21		mva :STACKORIGIN,x Y
  1118 11E7 CA				dex						; sub bx, 1
  1119
  1120 				; -----------------------------------------------------------
  1121
  1122 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1123 				; as Pointer
  1124 11E8 B5 98 8D 70 21		mva :STACKORIGIN,x X
  1125 11ED CA				dex						; sub bx, 1
  1126
  1127
  1128
  1129
  1130 				; optimize FAIL ('CRT_GOTOXY', B_CRT), line = 568
  1131 11EE E8				inx
  1132 11EF AD 70 21 95 98		mva X :STACKORIGIN,x
  1133 11F4 E8				inx
  1134 11F5 AD 71 21 95 98		mva Y :STACKORIGIN,x
  1135 11FA 20 0B 11			jsr CRT_GOTOXY
  1136
  1137 				; optimize FAIL ('CRT_WRITE_02DD', B_CRT), line = 569
  1138 11FD E8				inx
  1139 11FE AD 0C 12 95 98		mva S :STACKORIGIN,x
  1140 1203 AD 0D 12 95 A8		mva S+1 :STACKORIGIN+STACKWIDTH,x
  1141 1208 20 44 11			jsr CRT_WRITE_02DD
  1142
  1143 				; -----------------------------------------------------------
  1144
  1145 = 2170			X	= DATAORIGIN+$0125
  1146 = 2171			Y	= DATAORIGIN+$0126
  1147 = 2172			adr.S	= DATAORIGIN+$0127
  1148 120B			.var S	= adr.S .word
  1149
  1150 = 2170			@VarData	= X
  1151 = 0102			@VarDataSize	= 258
  1152
  1153
  1154 120B			@exit
  1155 					.ifdef @new
  1156 					@FreeMem #@VarData #@VarDataSize
  1157 					eif
  1158 120B 60				rts						; ret
  1159 = 120C 72 21		S
  1159 				.endl
  1160
  1161 120E			.local	CRT_KEYPRESSED					; FUNCTION
  1162
  1163
  1164
  1165
  1166 				; optimize OK (B_CRT), line = 592
  1167
  1168 120E A9 00 8D 72 22		mva #$00 RESULT
  1169
  1170 				; optimize OK (B_CRT), line = 593
  1171
  1172 1213 AD 0F D2			lda ATARI.SKSTAT
  1173 1216 A0 01			ldy #1
  1174 1218 29 04			and #$04
  1175 121A F0 01			beq @+
  1176 121C 88				dey
  1177 121D			@
  1178 					.ifdef IFTMP_38
  1179 					sty IFTMP_38
  1180 					eif
  1181 121D 98				tya
  1182 121E F0 05			jeq l_0324
  1183
  1184 				; optimize OK (B_CRT), line = 593
  1185
  1186 1220 A9 01 8D 72 22		mva #$01 RESULT
  1187 1225			l_0324
  1188
  1189 1225			@exit
  1190
  1191 				; -----------------------------------------------------------
  1192
  1193 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1194 				; as Pointer
  1195
  1196 1225 E8				inx						; add bx, 1
  1197 1226 AD 72 22 95 98		mva RESULT :STACKORIGIN,x
  1198
  1199 					.ifdef @new
  1200 					@FreeMem #@VarData #@VarDataSize
  1201 					eif
  1202
  1203 				; -----------------------------------------------------------
  1204
  1205 = 2272			RESULT	= DATAORIGIN+$0227
  1206
  1207 = 2272			@VarData	= RESULT
  1208 = 0001			@VarDataSize	= 1
  1209
  1210 122B 60				rts						; ret
  1211 				.endl
  1212
  1213 122C			.local	CRT_WRITECENTERED_0337				; PROCEDURE | OVERLOAD
  1214
  1215 				; -----------------------------------------------------------
  1216
  1217 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1218 				; as Pointer
  1219 122C B5 98 8D B6 12		mva :STACKORIGIN,x S
  1220 1231 B5 A8 8D B7 12		mva :STACKORIGIN+STACKWIDTH,x S+1
  1221 1236 CA				dex						; sub bx, 1
  1222 					@move S #adr.S #256
  1222 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
  1222 1237 AD B6 12 85 86 AD +  MWA S @MOVE.PTR1
  1222 1241 A9 74 85 8A A9 22 +  MWA #ADR.S @MOVE.PTR2
  1222 1249 A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
  1222 1251 20 AE 1F		 JSR @MOVE
  1223 1254 A9 74 8D B6 12 A9 + 	mwa #adr.S S
  1224
  1225 				; -----------------------------------------------------------
  1226
  1227 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1228 				; as Pointer
  1229 125E B5 98 8D 73 22		mva :STACKORIGIN,x ROW
  1230 1263 CA				dex						; sub bx, 1
  1231
  1232
  1233
  1234
  1235 				; optimize OK (B_CRT), line = 690
  1236
  1237 1264 AD 63 20			lda CRT_SCREENWIDTH
  1238 1267 4A				lsr @
  1239 1268 85 A1			sta :STACKORIGIN+9
  1240 126A AD B6 12 85 90 AD + 	mwa S :bp2
  1241 1274 A0 00			ldy #0
  1242 1276 B1 90			lda (:bp2),y
  1243 1278 4A				lsr @
  1244 1279 85 A2			sta :STACKORIGIN+10
  1245 127B A5 A1			lda :STACKORIGIN+9
  1246 127D 38 E5 A2			sub :STACKORIGIN+10
  1247 1280 38 E9 01			sub #$01
  1248 1283 8D 74 23			sta OFF
  1249
  1250 				; optimize OK (B_CRT), line = 691
  1251
  1252 1286 AD 65 20			lda CRT_CURSOR
  1253 1289 18 6D 74 23			add OFF
  1254 128D 8D 65 20			sta CRT_CURSOR
  1255 1290 AD 66 20			lda CRT_CURSOR+1
  1256 1293 69 00			adc #$00
  1257 1295 8D 66 20			sta CRT_CURSOR+1
  1258
  1259 				; optimize FAIL ('CRT_GOTOXY', B_CRT), line = 692
  1260 1298 E8				inx
  1261 1299 AD 74 23 95 98		mva OFF :STACKORIGIN,x
  1262 129E E8				inx
  1263 129F AD 73 22 95 98		mva ROW :STACKORIGIN,x
  1264 12A4 20 0B 11			jsr CRT_GOTOXY
  1265
  1266 				; optimize FAIL ('CRT_WRITE_02DD', B_CRT), line = 693
  1267 12A7 E8				inx
  1268 12A8 AD B6 12 95 98		mva S :STACKORIGIN,x
  1269 12AD AD B7 12 95 A8		mva S+1 :STACKORIGIN+STACKWIDTH,x
  1270 12B2 20 44 11			jsr CRT_WRITE_02DD
  1271
  1272 				; -----------------------------------------------------------
  1273
  1274 = 2273			ROW	= DATAORIGIN+$0228
  1275 = 2274			adr.S	= DATAORIGIN+$0229
  1276 12B5			.var S	= adr.S .word
  1277 = 2374			OFF	= DATAORIGIN+$0329
  1278
  1279 = 2273			@VarData	= ROW
  1280 = 0102			@VarDataSize	= 258
  1281
  1282
  1283 12B5			@exit
  1284 					.ifdef @new
  1285 					@FreeMem #@VarData #@VarDataSize
  1286 					eif
  1287 12B5 60				rts						; ret
  1288 = 12B6 74 22		S
  1288 				.endl
  1289
  1290 12B8			.local	CRT_CLEARROW_0363				; PROCEDURE | OVERLOAD
  1291
  1292 				; -----------------------------------------------------------
  1293
  1294 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1295 				; as Pointer
  1296 12B8 B5 98 8D 75 23		mva :STACKORIGIN,x ROW
  1297 12BD CA				dex						; sub bx, 1
  1298
  1299
  1300
  1301
  1302 				; optimize FAIL ('CRT_GOTOXY', B_CRT), line = 717
  1303 12BE E8				inx
  1304 12BF AD 67 20 95 98		mva CRT_LEFTMARGIN :STACKORIGIN,x
  1305 12C4 E8				inx
  1306 12C5 AD 75 23 95 98		mva ROW :STACKORIGIN,x
  1307 12CA 20 0B 11			jsr CRT_GOTOXY
  1308
  1309 				; optimize OK (B_CRT), line = 718
  1310
  1311 12CD AD 63 20			lda CRT_SCREENWIDTH
  1312 12D0 85 8A			sta :ecx
  1313 12D2 AD 75 23			lda ROW
  1314 12D5 85 82			sta :eax
  1315 					.ifdef fmulinit
  1316 					fmulu_8
  1317 					els
  1318 12D7 20 6C 1F			imulCL
  1319 					eif
  1320 12DA AD 5F 20			lda CRT_VRAM
  1321 12DD 18 65 82			add :eax
  1322 12E0 85 86			sta :edx
  1323 12E2 AD 60 20			lda CRT_VRAM+1
  1324 12E5 65 83			adc :eax+1
  1325 12E7 85 87			sta :edx+1
  1326 12E9 AD 63 20			lda CRT_SCREENWIDTH
  1327 12EC 85 8A			sta :ecx
  1328 12EE A9 00			lda #$00
  1329 12F0 85 8B			sta :ecx+1
  1330 12F2 85 82			sta :eax
  1331 12F4 20 03 20			jsr @fill
  1332
  1333 				; -----------------------------------------------------------
  1334
  1335 = 2375			ROW	= DATAORIGIN+$032A
  1336
  1337 = 2375			@VarData	= ROW
  1338 = 0001			@VarDataSize	= 1
  1339
  1340
  1341 12F7			@exit
  1342 					.ifdef @new
  1343 					@FreeMem #@VarData #@VarDataSize
  1344 					eif
  1345 12F7 60				rts						; ret
  1346 				.endl
  1347
  1348 12F8			.local	CRT_INVERT					; PROCEDURE
  1349
  1350 				; -----------------------------------------------------------
  1351
  1352 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1353 				; as Pointer
  1354 12F8 B5 98 8D 78 23		mva :STACKORIGIN,x WIDTH
  1355 12FD CA				dex						; sub bx, 1
  1356
  1357 				; -----------------------------------------------------------
  1358
  1359 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1360 				; as Pointer
  1361 12FE B5 98 8D 77 23		mva :STACKORIGIN,x Y
  1362 1303 CA				dex						; sub bx, 1
  1363
  1364 				; -----------------------------------------------------------
  1365
  1366 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1367 				; as Pointer
  1368 1304 B5 98 8D 76 23		mva :STACKORIGIN,x X
  1369 1309 CA				dex						; sub bx, 1
  1370
  1371
  1372
  1373
  1374 				; optimize OK (B_CRT), line = 734
  1375
  1376 130A AD 63 20			lda CRT_SCREENWIDTH
  1377 130D 85 8A			sta :ecx
  1378 130F AD 77 23			lda Y
  1379 1312 85 82			sta :eax
  1380 					.ifdef fmulinit
  1381 					fmulu_8
  1382 					els
  1383 1314 20 6C 1F			imulCL
  1384 					eif
  1385 1317 AD 5F 20			lda CRT_VRAM
  1386 131A 18 65 82			add :eax
  1387 131D 85 A1			sta :STACKORIGIN+9
  1388 131F AD 60 20			lda CRT_VRAM+1
  1389 1322 65 83			adc :eax+1
  1390 1324 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  1391 1326 A5 A1			lda :STACKORIGIN+9
  1392 1328 18 6D 76 23			add X
  1393 132C 8D 79 23			sta CURSOR
  1394 132F A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  1395 1331 69 00			adc #$00
  1396 1333 8D 7A 23			sta CURSOR+1
  1397
  1398 				; --- WhileProlog
  1399 1336			l_03A8
  1400
  1401 				; optimize OK (B_CRT), line = 735
  1402
  1403 1336 AD 78 23			lda WIDTH
  1404 1339 C9 00			cmp #$00
  1405 133B F0 02			seq
  1406 133D B0 03			bcs @+
  1407 133F 4C 67 13			jmp l_03B7
  1408 1342			@
  1409
  1410 				; optimize OK (B_CRT), line = 736
  1411
  1412 1342 AD 7A 23			lda CURSOR+1
  1413 1345 85 8F			sta :bp+1
  1414 1347 AC 79 23			ldy CURSOR
  1415 134A B1 8E			lda (:bp),y
  1416 134C 49 80			eor #$80
  1417 134E 85 A2			sta :STACKORIGIN+10
  1418 1350 AD 7A 23			lda CURSOR+1
  1419 1353 85 8F			sta :bp+1
  1420 1355 A5 A2			lda :STACKORIGIN+10
  1421 1357 91 8E			sta (:bp),y
  1422
  1423 				; optimize FAIL (0, B_CRT), line = 737
  1424 1359 CE 78 23			dec WIDTH
  1425
  1426 				; optimize FAIL (0, B_CRT), line = 738
  1427 135C EE 79 23 D0 03 EE + 	inw CURSOR
  1428
  1429 				; --- WhileDoEpilog
  1430 1364			c_03A8
  1431 1364 4C 36 13			jmp l_03A8
  1432 1367			l_03B7
  1433 1367			b_03A8
  1434
  1435 				; -----------------------------------------------------------
  1436
  1437 = 2376			X	= DATAORIGIN+$032B
  1438 = 2377			Y	= DATAORIGIN+$032C
  1439 = 2378			WIDTH	= DATAORIGIN+$032D
  1440 = 2379			CURSOR	= DATAORIGIN+$032E
  1441
  1442 = 2376			@VarData	= X
  1443 = 0005			@VarDataSize	= 5
  1444
  1445
  1446 1367			@exit
  1447 					.ifdef @new
  1448 					@FreeMem #@VarData #@VarDataSize
  1449 					eif
  1450 1367 60				rts						; ret
  1451 				.endl
  1452
  1453 				; -----------------------------------------------------------
  1454
  1455 = 0028			DEFAULT_SCREENWIDTH	= $0028
  1456 = 0018			DEFAULT_SCREENHEIGHT	= $0018
  1457 = 009B			CHAR_RETURN	= $009B
  1458 = 001B			CHAR_ESCAPE	= $001B
  1459 = 007E			CHAR_BACKSPACE	= $007E
  1460 = 007F			CHAR_TAB	= $007F
  1461 = 0081			CHAR_INVERSE	= $0081
  1462 = 0082			CHAR_CAPS	= $0082
  1463 = 00DB			ICHAR_RETURN	= $00DB
  1464 = 005B			ICHAR_ESCAPE	= $005B
  1465 = 007E			ICHAR_BACKSPACE	= $007E
  1466 = 007F			ICHAR_TAB	= $007F
  1467 = 00C1			ICHAR_INVERSE	= $00C1
  1468 = 00C2			ICHAR_CAPS	= $00C2
  1469 = 0DC8			adr.CRT_KEYCODE	= CODEORIGIN+$01C8
  1470 1368			.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
  1471 = 205F			CRT_VRAM	= DATAORIGIN+$0014
  1472 = 2061			CRT_SIZE	= DATAORIGIN+$0016
  1473 = 2063			CRT_SCREENWIDTH	= DATAORIGIN+$0018
  1474 = 2064			CRT_SCREENHEIGHT	= DATAORIGIN+$0019
  1475 = 2065			CRT_CURSOR	= DATAORIGIN+$001A
  1476 = 2067			CRT_LEFTMARGIN	= DATAORIGIN+$001C
  1477 = D209			KBCODE	= $D209
  1478 = D01F			CONSOL	= $D01F
  1479
  1480 = 1368 C8 0D		CRT_KEYCODE
  1480 				.endl							; UNIT B_CRT
  1481
  1482 				; -----------------------------------------------------------
  1483
  1484 136A			.local	RMT						; UNIT
  1485
  1486 136A			.local	TRMT.INIT					; PROCEDURE | ASSEMBLER
  1487 136A 8D 7B 23			sta TRMT
  1488 136D 8C 7C 23			sty TRMT+1
  1489 1370 8D 7E 23			sta PLAYER
  1490 1373 8C 7F 23			sty PLAYER+1
  1491 1376 18 69 02			add #2
  1492 1379 90 01			scc
  1493 137B C8				iny
  1494 137C 8D 80 23			sta MODUL
  1495 137F 8C 81 23			sty MODUL+1
  1496
  1497 				; -----------------------------------------------------------
  1498
  1499 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1500 				; as Pointer
  1501 1382 B5 98 8D 7D 23		mva :STACKORIGIN,x A
  1502 1387 CA				dex						; sub bx, 1
  1503
  1504
  1505 				; ---------------------  ASM Block 072  ---------------------
  1506
  1507 1388 8A 48			txa:pha
  1508
  1509 138A AD 7B 23 85 90 AD + 	mwa TRMT :bp2
  1510
  1511 1394 A0 00			ldy #0
  1512 1396 B1 90			lda (:bp2),y
  1513 1398 18 69 03			add #3		; jsr player+3
  1514 139B 8D B2 13			sta adr
  1515 139E C8				iny
  1516 139F B1 90			lda (:bp2),y
  1517 13A1 69 00			adc #0
  1518 13A3 8D B3 13			sta adr+1
  1519
  1520 13A6 C8				iny
  1521 13A7 B1 90			lda (:bp2),y
  1522 13A9 AA				tax		; low byte of RMT module to X reg
  1523 13AA C8				iny
  1524 13AB B1 90			lda (:bp2),y
  1525 13AD A8				tay		; hi byte of RMT module to Y reg
  1526
  1527 13AE AD 7D 23			lda a		; starting song line 0-255 to A reg
  1528 13B1 20 FF FF			jsr $ffff
  1529 = 13B2			adr	equ *-2
  1530
  1531 13B4 68 AA			pla:tax
  1532
  1533
  1534 				; -----------------------------------------------------------
  1535
  1536 = 237B			TRMT	= DATAORIGIN+$0330
  1537 = 237D			A	= DATAORIGIN+$0332
  1538 = 237E			PLAYER	= DATAORIGIN+$0333
  1539 = 2380			MODUL	= DATAORIGIN+$0335
  1540
  1541 = 237B			@VarData	= TRMT
  1542 = 0007			@VarDataSize	= 7
  1543
  1544
  1545 13B6			@exit
  1546 					.ifdef @new
  1547 					@FreeMem #@VarData #@VarDataSize
  1548 					eif
  1549 13B6 60				rts						; ret
  1550 				.endl
  1551
  1552 13B7			.local	TRMT.PLAY					; PROCEDURE | ASSEMBLER
  1553 13B7 8D 86 23			sta TRMT
  1554 13BA 8C 87 23			sty TRMT+1
  1555 13BD 8D 88 23			sta PLAYER
  1556 13C0 8C 89 23			sty PLAYER+1
  1557 13C3 18 69 02			add #2
  1558 13C6 90 01			scc
  1559 13C8 C8				iny
  1560 13C9 8D 8A 23			sta MODUL
  1561 13CC 8C 8B 23			sty MODUL+1
  1562
  1563
  1564 				; ---------------------  ASM Block 074  ---------------------
  1565
  1566 13CF 8A 48			txa:pha
  1567
  1568 13D1 AD 86 23 8D E0 13 + 	mwa TRMT ptr
  1569
  1570 13DD A0 01			ldy #1
  1571 13DF B9 FF FF		cptr	lda $ffff,y
  1572 = 13E0			ptr	equ *-2
  1573 13E2 99 E9 13			sta adr,y
  1574 13E5 88				dey
  1575 13E6 10 F7			bpl cptr
  1576
  1577 13E8 20 FF FF			jsr $ffff
  1578 = 13E9			adr	equ *-2
  1579
  1580 13EB 68 AA			pla:tax
  1581
  1582
  1583 				; -----------------------------------------------------------
  1584
  1585 = 2386			TRMT	= DATAORIGIN+$033B
  1586 = 2388			PLAYER	= DATAORIGIN+$033D
  1587 = 238A			MODUL	= DATAORIGIN+$033F
  1588
  1589 = 2386			@VarData	= TRMT
  1590 = 0006			@VarDataSize	= 6
  1591
  1592
  1593 13ED			@exit
  1594 					.ifdef @new
  1595 					@FreeMem #@VarData #@VarDataSize
  1596 					eif
  1597 13ED 60				rts						; ret
  1598 				.endl
  1599
  1600 13EE			.local	TRMT.STOP					; PROCEDURE | ASSEMBLER
  1601 13EE 8D 8C 23			sta TRMT
  1602 13F1 8C 8D 23			sty TRMT+1
  1603 13F4 8D 8E 23			sta PLAYER
  1604 13F7 8C 8F 23			sty PLAYER+1
  1605 13FA 18 69 02			add #2
  1606 13FD 90 01			scc
  1607 13FF C8				iny
  1608 1400 8D 90 23			sta MODUL
  1609 1403 8C 91 23			sty MODUL+1
  1610
  1611
  1612 				; ---------------------  ASM Block 075  ---------------------
  1613
  1614 1406 8A 48			txa:pha
  1615
  1616 1408 AD 8C 23 85 90 AD + 	mwa TRMT :bp2
  1617
  1618 1412 A0 00			ldy #0
  1619 1414 B1 90			lda (:bp2),y
  1620 1416 18 69 09			add #9		; jsr player+9
  1621 1419 8D 25 14			sta adr
  1622 141C C8				iny
  1623 141D B1 90			lda (:bp2),y
  1624 141F 69 00			adc #0
  1625 1421 8D 26 14			sta adr+1
  1626
  1627 1424 20 FF FF			jsr $ffff
  1628 = 1425			adr	equ *-2
  1629
  1630 1427 68 AA			pla:tax
  1631
  1632
  1633 				; -----------------------------------------------------------
  1634
  1635 = 238C			TRMT	= DATAORIGIN+$0341
  1636 = 238E			PLAYER	= DATAORIGIN+$0343
  1637 = 2390			MODUL	= DATAORIGIN+$0345
  1638
  1639 = 238C			@VarData	= TRMT
  1640 = 0006			@VarDataSize	= 6
  1641
  1642
  1643 1429			@exit
  1644 					.ifdef @new
  1645 					@FreeMem #@VarData #@VarDataSize
  1646 					eif
  1647 1429 60				rts						; ret
  1648 				.endl
  1649
  1650 				; -----------------------------------------------------------
  1651
  1652
  1653 				.endl							; UNIT RMT
  1654
  1655 142A			.local	DLI_PIC1_F1					; PROCEDURE | ASSEMBLER | INTERRUPT
  1656
  1657
  1658 				; ---------------------  ASM Block 076  ---------------------
  1659
  1660
  1661 142A 48			        pha ; store registers
  1662 				        ;sta ATARI.WSYNC
  1663 142B AD 92 23 8D 16 D0	        mva adr.gfxcolors ATARI.colpf0
  1664 1431 AD 93 23 8D 17 D0	        mva adr.gfxcolors+1 ATARI.colpf1
  1665 1437 AD 94 23 8D 18 D0	        mva adr.gfxcolors+2 ATARI.colpf2
  1666 143D AD 95 23 8D 1A D0	        mva adr.gfxcolors+3 ATARI.colbk
  1667 				        
  1668 				        ;sta ATARI.WSYNC
  1669 1443 A9 48 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F1) ATARI.chbase
  1670
  1671 1448 A9 54 8D BB 0F A9 +         mwa #dli_pic1_f2 __dlivec
  1672 1452 68			        pla ; restore registers
  1673 				        
  1674 1453 40				rti						; ret
  1675 				.endl
  1676
  1677 1454			.local	DLI_PIC1_F2					; PROCEDURE | ASSEMBLER | INTERRUPT
  1678
  1679
  1680 				; ---------------------  ASM Block 077  ---------------------
  1681
  1682
  1683 1454 48			        pha ; store registers
  1684 1455 8D 0A D4		        sta ATARI.WSYNC
  1685 1458 A9 4C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F2) ATARI.chbase
  1686
  1687 145D A9 69 8D BB 0F A9 +         mwa #dli_pic1_f3 __dlivec
  1688
  1689 1467 68			        pla ; restore registers
  1690 				        
  1691 1468 40				rti						; ret
  1692 				.endl
  1693
  1694 1469			.local	DLI_PIC1_F3					; PROCEDURE | ASSEMBLER | INTERRUPT
  1695
  1696
  1697 				; ---------------------  ASM Block 078  ---------------------
  1698
  1699
  1700 1469 48			        pha ; store registers
  1701 146A 8D 0A D4		        sta ATARI.WSYNC
  1702 146D A9 50 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F3) ATARI.chbase
  1703
  1704 1472 A9 7E 8D BB 0F A9 +         mwa #dli_pic1_f4 __dlivec
  1705
  1706 147C 68			        pla ; restore registers
  1707 				        
  1708 147D 40				rti						; ret
  1709 				.endl
  1710
  1711 147E			.local	DLI_PIC1_F4					; PROCEDURE | ASSEMBLER | INTERRUPT
  1712
  1713
  1714 				; ---------------------  ASM Block 079  ---------------------
  1715
  1716
  1717 147E 48			        pha ; store registers
  1718 147F 8D 0A D4		        sta ATARI.WSYNC
  1719 1482 A9 54 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F4) ATARI.chbase
  1720
  1721 1487 A9 93 8D BB 0F A9 +         mwa #dli_pic1_f5 __dlivec
  1722
  1723 1491 68			        pla ; restore registers
  1724 				        
  1725 1492 40				rti						; ret
  1726 				.endl
  1727
  1728 1493			.local	DLI_PIC1_F5					; PROCEDURE | ASSEMBLER | INTERRUPT
  1729
  1730
  1731 				; ---------------------  ASM Block 080  ---------------------
  1732
  1733
  1734 1493 48			        pha ; store registers
  1735 1494 8D 0A D4		        sta ATARI.WSYNC
  1736 1497 A9 58 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F5) ATARI.chbase
  1737
  1738 149C A9 A8 8D BB 0F A9 +         mwa #dli_pic1_f6 __dlivec
  1739
  1740 14A6 68			        pla ; restore registers
  1741 				        
  1742 14A7 40				rti						; ret
  1743 				.endl
  1744
  1745 14A8			.local	DLI_PIC1_F6					; PROCEDURE | ASSEMBLER | INTERRUPT
  1746
  1747
  1748 				; ---------------------  ASM Block 081  ---------------------
  1749
  1750
  1751 14A8 48			        pha ; store registers
  1752 14A9 8D 0A D4		        sta ATARI.WSYNC
  1753 14AC A9 5C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F6) ATARI.chbase
  1754
  1755 14B1 A9 BD 8D BB 0F A9 +         mwa #dli_pic1_f7 __dlivec
  1756
  1757 14BB 68			        pla ; restore registers
  1758 				        
  1759 14BC 40				rti						; ret
  1760 				.endl
  1761
  1762 14BD			.local	DLI_PIC1_F7					; PROCEDURE | ASSEMBLER | INTERRUPT
  1763
  1764
  1765 				; ---------------------  ASM Block 082  ---------------------
  1766
  1767
  1768 14BD 48			        pha ; store registers
  1769 14BE 8D 0A D4		        sta ATARI.WSYNC
  1770 14C1 A9 60 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F7) ATARI.chbase
  1771
  1772 14C6 A9 D2 8D BB 0F A9 +         mwa #dli_pic1_f8 __dlivec
  1773
  1774 14D0 68			        pla ; restore registers
  1775 				        
  1776 14D1 40				rti						; ret
  1777 				.endl
  1778
  1779 14D2			.local	DLI_PIC1_F8					; PROCEDURE | ASSEMBLER | INTERRUPT
  1780
  1781
  1782 				; ---------------------  ASM Block 083  ---------------------
  1783
  1784
  1785 14D2 48			        pha ; store registers
  1786 14D3 8D 0A D4		        sta ATARI.WSYNC
  1787 14D6 A9 64 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC1_F8) ATARI.chbase
  1788
  1789 14DB A9 E7 8D BB 0F A9 +         mwa #dli_pic1_f9 __dlivec
  1790
  1791 14E5 68			        pla ; restore registers
  1792 				        
  1793 14E6 40				rti						; ret
  1794 				.endl
  1795
  1796 14E7			.local	DLI_PIC1_F9					; PROCEDURE | INTERRUPT
  1797
  1798
  1799
  1800
  1801 				; ---------------------  ASM Block 084  ---------------------
  1802
  1803
  1804 14E7 48 8A 48 98 48	        phr ; store registers
  1805 				        ;sta ATARI.WSYNC
  1806 14EC AD A6 23 8D 16 D0	        mva adr.txtcolors ATARI.colpf0
  1807 14F2 A9 00 8D 18 D0	        mva #00 ATARI.colpf2
  1808 14F7 A9 00 8D 1A D0	        mva #00 ATARI.colbk
  1809 14FC AD A7 23 8D 17 D0	        mva adr.txtcolors+1 ATARI.colpf1
  1810 				        
  1811 				        ;sta ATARI.WSYNC
  1812 1502 A9 E4 8D 09 D4	        mva #.hi(CHARSET_ADDRESS) ATARI.chbase
  1813 				;        sta ATARI.WSYNC
  1814 				        
  1815 				        ;mwa #dli_pic1_f1 __dlivec
  1816 				    
  1817
  1818 				; ---------------------  ASM Block 085  ---------------------
  1819
  1820
  1821 1507 68 A8 68 AA 68	        plr ; restore registers
  1822 				        
  1823 150C 40				rti						; ret
  1824 				.endl
  1825
  1826 150D			.local	DLI_PIC2_F1					; PROCEDURE | ASSEMBLER | INTERRUPT
  1827
  1828
  1829 				; ---------------------  ASM Block 086  ---------------------
  1830
  1831
  1832 150D 48			        pha ; store registers
  1833 				        ;sta ATARI.WSYNC
  1834 150E AD 92 23 8D 16 D0	        mva adr.gfxcolors ATARI.colpf0
  1835 1514 AD 93 23 8D 17 D0	        mva adr.gfxcolors+1 ATARI.colpf1
  1836 151A AD 94 23 8D 18 D0	        mva adr.gfxcolors+2 ATARI.colpf2
  1837 1520 AD 95 23 8D 1A D0	        mva adr.gfxcolors+3 ATARI.colbk
  1838 				        
  1839 				        ;sta ATARI.WSYNC
  1840 1526 A9 68 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F1) ATARI.chbase
  1841
  1842 152B A9 37 8D BB 0F A9 +         mwa #dli_pic2_f2 __dlivec
  1843 1535 68			        pla ; restore registers
  1844 				        
  1845 1536 40				rti						; ret
  1846 				.endl
  1847
  1848 1537			.local	DLI_PIC2_F2					; PROCEDURE | ASSEMBLER | INTERRUPT
  1849
  1850
  1851 				; ---------------------  ASM Block 087  ---------------------
  1852
  1853
  1854 1537 48			        pha ; store registers
  1855 1538 8D 0A D4		        sta ATARI.WSYNC
  1856 153B A9 6C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F2) ATARI.chbase
  1857
  1858 1540 A9 4C 8D BB 0F A9 +         mwa #dli_pic2_f3 __dlivec
  1859
  1860 154A 68			        pla ; restore registers
  1861 				        
  1862 154B 40				rti						; ret
  1863 				.endl
  1864
  1865 154C			.local	DLI_PIC2_F3					; PROCEDURE | ASSEMBLER | INTERRUPT
  1866
  1867
  1868 				; ---------------------  ASM Block 088  ---------------------
  1869
  1870
  1871 154C 48			        pha ; store registers
  1872 154D 8D 0A D4		        sta ATARI.WSYNC
  1873 1550 A9 70 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F3) ATARI.chbase
  1874
  1875 1555 A9 61 8D BB 0F A9 +         mwa #dli_pic2_f4 __dlivec
  1876
  1877 155F 68			        pla ; restore registers
  1878 				        
  1879 1560 40				rti						; ret
  1880 				.endl
  1881
  1882 1561			.local	DLI_PIC2_F4					; PROCEDURE | ASSEMBLER | INTERRUPT
  1883
  1884
  1885 				; ---------------------  ASM Block 089  ---------------------
  1886
  1887
  1888 1561 48			        pha ; store registers
  1889 1562 8D 0A D4		        sta ATARI.WSYNC
  1890 1565 A9 74 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F4) ATARI.chbase
  1891
  1892 156A A9 76 8D BB 0F A9 +         mwa #dli_pic2_f5 __dlivec
  1893
  1894 1574 68			        pla ; restore registers
  1895 				        
  1896 1575 40				rti						; ret
  1897 				.endl
  1898
  1899 1576			.local	DLI_PIC2_F5					; PROCEDURE | ASSEMBLER | INTERRUPT
  1900
  1901
  1902 				; ---------------------  ASM Block 090  ---------------------
  1903
  1904
  1905 1576 48			        pha ; store registers
  1906 1577 8D 0A D4		        sta ATARI.WSYNC
  1907 157A A9 78 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F5) ATARI.chbase
  1908
  1909 157F A9 8B 8D BB 0F A9 +         mwa #dli_pic2_f6 __dlivec
  1910
  1911 1589 68			        pla ; restore registers
  1912 				        
  1913 158A 40				rti						; ret
  1914 				.endl
  1915
  1916 158B			.local	DLI_PIC2_F6					; PROCEDURE | ASSEMBLER | INTERRUPT
  1917
  1918
  1919 				; ---------------------  ASM Block 091  ---------------------
  1920
  1921
  1922 158B 48			        pha ; store registers
  1923 158C 8D 0A D4		        sta ATARI.WSYNC
  1924 158F A9 7C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F6) ATARI.chbase
  1925
  1926 1594 A9 A0 8D BB 0F A9 +         mwa #dli_pic2_f7 __dlivec
  1927
  1928 159E 68			        pla ; restore registers
  1929 				        
  1930 159F 40				rti						; ret
  1931 				.endl
  1932
  1933 15A0			.local	DLI_PIC2_F7					; PROCEDURE | ASSEMBLER | INTERRUPT
  1934
  1935
  1936 				; ---------------------  ASM Block 092  ---------------------
  1937
  1938
  1939 15A0 48			        pha ; store registers
  1940 15A1 8D 0A D4		        sta ATARI.WSYNC
  1941 15A4 A9 80 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC2_F7) ATARI.chbase
  1942
  1943 15A9 A9 B5 8D BB 0F A9 +         mwa #dli_pic2_f8 __dlivec
  1944
  1945 15B3 68			        pla ; restore registers
  1946 				        
  1947 15B4 40				rti						; ret
  1948 				.endl
  1949
  1950 15B5			.local	DLI_PIC2_F8					; PROCEDURE | INTERRUPT
  1951
  1952
  1953
  1954
  1955 				; ---------------------  ASM Block 093  ---------------------
  1956
  1957
  1958 15B5 48 8A 48 98 48	        phr ; store registers
  1959 				        ;sta ATARI.WSYNC
  1960 15BA AD A6 23 8D 16 D0	        mva adr.txtcolors ATARI.colpf0
  1961 15C0 A9 00 8D 18 D0	        mva #00 ATARI.colpf2
  1962 15C5 A9 00 8D 1A D0	        mva #00 ATARI.colbk
  1963 15CA AD A7 23 8D 17 D0	        mva adr.txtcolors+1 ATARI.colpf1
  1964 				        
  1965 				        ;sta ATARI.WSYNC
  1966 15D0 A9 E4 8D 09 D4	        mva #.hi(CHARSET_ADDRESS) ATARI.chbase
  1967 				;        sta ATARI.WSYNC
  1968 				        
  1969 				    
  1970
  1971 				; ---------------------  ASM Block 094  ---------------------
  1972
  1973
  1974
  1975 15D5 68 A8 68 AA 68	        plr ; restore registers
  1976 				        
  1977 15DA 40				rti						; ret
  1978 				.endl
  1979
  1980 15DB			.local	DLI_PIC3_F1					; PROCEDURE | ASSEMBLER | INTERRUPT
  1981
  1982
  1983 				; ---------------------  ASM Block 095  ---------------------
  1984
  1985
  1986 15DB 48			        pha ; store registers
  1987
  1988 15DC AD 92 23 8D 16 D0	        mva adr.gfxcolors ATARI.colpf0
  1989 15E2 AD 93 23 8D 17 D0	        mva adr.gfxcolors+1 ATARI.colpf1
  1990 15E8 AD 94 23 8D 18 D0	        mva adr.gfxcolors+2 ATARI.colpf2
  1991 15EE AD 95 23 8D 1A D0	        mva adr.gfxcolors+3 ATARI.colbk
  1992 				        
  1993 15F4 A9 84 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F1) ATARI.chbase
  1994
  1995 15F9 A9 05 8D BB 0F A9 +         mwa #DLI_PIC3_F2 __dlivec
  1996 1603 68			        pla ; restore registers
  1997 				        
  1998 1604 40				rti						; ret
  1999 				.endl
  2000
  2001 1605			.local	DLI_PIC3_F2					; PROCEDURE | ASSEMBLER | INTERRUPT
  2002
  2003
  2004 				; ---------------------  ASM Block 096  ---------------------
  2005
  2006
  2007 1605 48			        pha ; store registers
  2008 1606 8D 0A D4		        sta ATARI.WSYNC
  2009 1609 A9 88 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F2) ATARI.chbase
  2010
  2011 160E A9 1A 8D BB 0F A9 +         mwa #DLI_PIC3_F3 __dlivec
  2012
  2013 1618 68			        pla ; restore registers
  2014 				        
  2015 1619 40				rti						; ret
  2016 				.endl
  2017
  2018 161A			.local	DLI_PIC3_F3					; PROCEDURE | ASSEMBLER | INTERRUPT
  2019
  2020
  2021 				; ---------------------  ASM Block 097  ---------------------
  2022
  2023
  2024 161A 48			        pha ; store registers
  2025 161B 8D 0A D4		        sta ATARI.WSYNC
  2026 161E A9 8C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F3) ATARI.chbase
  2027
  2028 1623 A9 2F 8D BB 0F A9 +         mwa #DLI_PIC3_F4 __dlivec
  2029
  2030 162D 68			        pla ; restore registers
  2031 				        
  2032 162E 40				rti						; ret
  2033 				.endl
  2034
  2035 162F			.local	DLI_PIC3_F4					; PROCEDURE | ASSEMBLER | INTERRUPT
  2036
  2037
  2038 				; ---------------------  ASM Block 098  ---------------------
  2039
  2040
  2041 162F 48			        pha ; store registers
  2042 1630 8D 0A D4		        sta ATARI.WSYNC
  2043 1633 A9 90 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F4) ATARI.chbase
  2044
  2045 1638 A9 44 8D BB 0F A9 +         mwa #DLI_PIC3_F5 __dlivec
  2046
  2047 1642 68			        pla ; restore registers
  2048 				        
  2049 1643 40				rti						; ret
  2050 				.endl
  2051
  2052 1644			.local	DLI_PIC3_F5					; PROCEDURE | ASSEMBLER | INTERRUPT
  2053
  2054
  2055 				; ---------------------  ASM Block 099  ---------------------
  2056
  2057
  2058 1644 48			        pha ; store registers
  2059 1645 8D 0A D4		        sta ATARI.WSYNC
  2060 1648 A9 88 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F2) ATARI.chbase
  2061
  2062 164D A9 59 8D BB 0F A9 +         mwa #DLI_PIC3_F6 __dlivec
  2063
  2064 1657 68			        pla ; restore registers
  2065 				        
  2066 1658 40				rti						; ret
  2067 				.endl
  2068
  2069 1659			.local	DLI_PIC3_F6					; PROCEDURE | ASSEMBLER | INTERRUPT
  2070
  2071
  2072 				; ---------------------  ASM Block 100  ---------------------
  2073
  2074
  2075 1659 48			        pha ; store registers
  2076 165A 8D 0A D4		        sta ATARI.WSYNC
  2077 165D A9 90 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F4) ATARI.chbase
  2078
  2079 1662 A9 6E 8D BB 0F A9 +         mwa #DLI_PIC3_F7 __dlivec
  2080
  2081 166C 68			        pla ; restore registers
  2082 				        
  2083 166D 40				rti						; ret
  2084 				.endl
  2085
  2086 166E			.local	DLI_PIC3_F7					; PROCEDURE | ASSEMBLER | INTERRUPT
  2087
  2088
  2089 				; ---------------------  ASM Block 101  ---------------------
  2090
  2091
  2092 166E 48			        pha ; store registers
  2093 166F 8D 0A D4		        sta ATARI.WSYNC
  2094 1672 A9 94 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F5) ATARI.chbase
  2095
  2096 1677 A9 83 8D BB 0F A9 +         mwa #DLI_PIC3_F8 __dlivec
  2097
  2098 1681 68			        pla ; restore registers
  2099 				        
  2100 1682 40				rti						; ret
  2101 				.endl
  2102
  2103 1683			.local	DLI_PIC3_F8					; PROCEDURE | ASSEMBLER | INTERRUPT
  2104
  2105
  2106 				; ---------------------  ASM Block 102  ---------------------
  2107
  2108
  2109 1683 48			        pha ; store registers
  2110 1684 8D 0A D4		        sta ATARI.WSYNC
  2111 1687 A9 90 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC3_F4) ATARI.chbase
  2112
  2113 168C A9 98 8D BB 0F A9 +         mwa #DLI_PIC3_F9 __dlivec
  2114
  2115 1696 68			        pla ; restore registers
  2116 				        
  2117 1697 40				rti						; ret
  2118 				.endl
  2119
  2120 1698			.local	DLI_PIC3_F9					; PROCEDURE | INTERRUPT
  2121
  2122
  2123
  2124
  2125 				; ---------------------  ASM Block 103  ---------------------
  2126
  2127
  2128 1698 48 8A 48 98 48	        phr ; store registers
  2129
  2130 169D AD A6 23 8D 16 D0	        mva adr.txtcolors ATARI.colpf0
  2131 16A3 A9 00 8D 18 D0	        mva #00 ATARI.colpf2
  2132 16A8 A9 00 8D 1A D0	        mva #00 ATARI.colbk
  2133 16AD AD A7 23 8D 17 D0	        mva adr.txtcolors+1 ATARI.colpf1
  2134 				        
  2135 16B3 A9 E4 8D 09 D4	        mva #.hi(CHARSET_ADDRESS) ATARI.chbase
  2136
  2137 				    
  2138
  2139 				; ---------------------  ASM Block 104  ---------------------
  2140
  2141
  2142
  2143 16B8 68 A8 68 AA 68	        plr ; restore registers
  2144 				     
  2145 16BD 40				rti						; ret
  2146 				.endl
  2147
  2148 16BE			.local	DLI_PIC4_F1					; PROCEDURE | ASSEMBLER | INTERRUPT
  2149
  2150
  2151 				; ---------------------  ASM Block 105  ---------------------
  2152
  2153
  2154 16BE 48			        pha ; store registers
  2155
  2156 16BF AD 92 23 8D 16 D0	        mva adr.gfxcolors ATARI.colpf0
  2157 16C5 AD 93 23 8D 17 D0	        mva adr.gfxcolors+1 ATARI.colpf1
  2158 16CB AD 94 23 8D 18 D0	        mva adr.gfxcolors+2 ATARI.colpf2
  2159 16D1 AD 95 23 8D 1A D0	        mva adr.gfxcolors+3 ATARI.colbk
  2160 				        
  2161 16D7 A9 98 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC4_F1) ATARI.chbase
  2162
  2163 16DC A9 E8 8D BB 0F A9 +         mwa #DLI_PIC4_F2 __dlivec
  2164 16E6 68			        pla ; restore registers
  2165 				        
  2166 16E7 40				rti						; ret
  2167 				.endl
  2168
  2169 16E8			.local	DLI_PIC4_F2					; PROCEDURE | ASSEMBLER | INTERRUPT
  2170
  2171
  2172 				; ---------------------  ASM Block 106  ---------------------
  2173
  2174
  2175 16E8 48			        pha ; store registers
  2176 16E9 8D 0A D4		        sta ATARI.WSYNC
  2177 16EC A9 9C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC4_F2) ATARI.chbase
  2178
  2179 16F1 A9 FD 8D BB 0F A9 +         mwa #DLI_PIC4_F3 __dlivec
  2180
  2181 16FB 68			        pla ; restore registers
  2182 				        
  2183 16FC 40				rti						; ret
  2184 				.endl
  2185
  2186 16FD			.local	DLI_PIC4_F3					; PROCEDURE | ASSEMBLER | INTERRUPT
  2187
  2188
  2189 				; ---------------------  ASM Block 107  ---------------------
  2190
  2191
  2192 16FD 48			        pha ; store registers
  2193 16FE 8D 0A D4		        sta ATARI.WSYNC
  2194 1701 A9 98 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC4_F1) ATARI.chbase
  2195
  2196 1706 A9 12 8D BB 0F A9 +         mwa #DLI_PIC4_F4 __dlivec
  2197
  2198 1710 68			        pla ; restore registers
  2199 				        
  2200 1711 40				rti						; ret
  2201 				.endl
  2202
  2203 1712			.local	DLI_PIC4_F4					; PROCEDURE | ASSEMBLER | INTERRUPT
  2204
  2205
  2206 				; ---------------------  ASM Block 108  ---------------------
  2207
  2208
  2209 1712 48			        pha ; store registers
  2210 1713 8D 0A D4		        sta ATARI.WSYNC
  2211 1716 A9 9C 8D 09 D4	        mva #.hi(CHAR_ADDRESS_PIC4_F2) ATARI.chbase
  2212
  2213 171B A9 27 8D BB 0F A9 +         mwa #DLI_PIC4_F5 __dlivec
  2214
  2215 1725 68			        pla ; restore registers
  2216 				        
  2217 1726 40				rti						; ret
  2218 				.endl
  2219
  2220 1727			.local	DLI_PIC4_F5					; PROCEDURE | INTERRUPT
  2221
  2222
  2223
  2224
  2225 				; ---------------------  ASM Block 109  ---------------------
  2226
  2227
  2228 1727 48 8A 48 98 48	        phr ; store registers
  2229
  2230 172C AD A6 23 8D 16 D0	        mva adr.txtcolors ATARI.colpf0
  2231 1732 A9 00 8D 18 D0	        mva #00 ATARI.colpf2
  2232 1737 A9 00 8D 1A D0	        mva #00 ATARI.colbk
  2233 173C AD A7 23 8D 17 D0	        mva adr.txtcolors+1 ATARI.colpf1
  2234 				        
  2235 1742 A9 E4 8D 09 D4	        mva #.hi(CHARSET_ADDRESS) ATARI.chbase
  2236
  2237 				    
  2238
  2239 				; ---------------------  ASM Block 110  ---------------------
  2240
  2241
  2242
  2243 1747 68 A8 68 AA 68	        plr ; restore registers
  2244 				        
  2245 174C 40				rti						; ret
  2246 				.endl
  2247
  2248 174D			.local	VBL						; PROCEDURE | INTERRUPT
  2249
  2250
  2251
  2252
  2253 				; ---------------------  ASM Block 111  ---------------------
  2254
  2255
  2256 174D 48 8A 48 98 48	      phr ; store registers
  2257 				  
  2258
  2259 				; optimize OK (), line = 440
  2260
  2261 					.ifdef IFTMP_42
  2262 					lda MUSIC
  2263 					sta IFTMP_42
  2264 					eif
  2265 1752 AD AF 23			lda MUSIC
  2266 1755 F0 09			jeq l_040B
  2267
  2268 				; optimize FAIL ('RMT.TRMT.PLAY', ), line = 440
  2269 1757 AD 53 1F			lda MSX
  2270 175A AC 54 1F			ldy MSX+1
  2271 175D 20 B7 13			jsr RMT.TRMT.PLAY
  2272 1760			l_040B
  2273
  2274 				; ---------------------  ASM Block 112  ---------------------
  2275
  2276
  2277 1760 AD B2 23 8D BB 0F +       mwa firstDLI __dlivec
  2278 176C 68 A8 68 AA 68	      plr ; restore registers
  2279 				  
  2280 1771 40				rti						; ret
  2281 				.endl
  2282
  2283 1772			.local	DLI_TITLE					; PROCEDURE | INTERRUPT
  2284
  2285
  2286
  2287
  2288 				; ---------------------  ASM Block 113  ---------------------
  2289
  2290
  2291 1772 48 8A 48 98 48	        phr ; store registers
  2292 1777 8D 0A D4		        sta ATARI.WSYNC
  2293 177A AD A6 23 8D 16 D0	        mva adr.txtcolors ATARI.colpf0
  2294 1780 A9 00 8D 18 D0	        mva #00 ATARI.colpf2
  2295 1785 A9 00 8D 1A D0	        mva #00 ATARI.colbk
  2296 178A AD A7 23 8D 17 D0	        mva adr.txtcolors+1 ATARI.colpf1
  2297 				    
  2298
  2299 				; ---------------------  ASM Block 114  ---------------------
  2300
  2301
  2302 1790 68 A8 68 AA 68	        plr ; restore registers
  2303 				        
  2304 1795 40				rti						; ret
  2305 				.endl
  2306
  2307 1796			.local	GFX_FADEIN					; PROCEDURE
  2308
  2309
  2310
  2311
  2312 				; optimize OK (intro.pas), line = 49
  2313
  2314 1796 AD AC 23			lda PICNUMBER
  2315 1799 0A 0A			:2 asl @
  2316 179B 8D AD 23			sta Y
  2317
  2318 				; --- RepeatUntilProlog
  2319 179E			l_0422
  2320
  2321 				; optimize FAIL ('B_SYSTEM.WAITFRAMES', intro.pas), line = 51
  2322 179E E8				inx
  2323 179F A9 02 95 98			mva #$02 :STACKORIGIN,x
  2324 17A3 20 66 10			jsr B_SYSTEM.WAITFRAMES
  2325
  2326 				; optimize OK (intro.pas), line = 52
  2327
  2328 17A6 AD 92 23			lda adr.GFXCOLORS+$00
  2329 17A9 29 0F			and #$0F
  2330 17AB 85 A1			sta :STACKORIGIN+9
  2331 17AD AC AD 23			ldy Y
  2332 17B0 B9 96 23			lda adr.PICCOLORS,y
  2333 17B3 29 0F			and #$0F
  2334 17B5 85 A2			sta :STACKORIGIN+10
  2335 17B7 A0 01			ldy #1
  2336 17B9 A5 A1			lda :STACKORIGIN+9
  2337 17BB C5 A2			cmp :STACKORIGIN+10
  2338 17BD D0 01			bne @+
  2339 17BF 88				dey
  2340 17C0			@
  2341 					.ifdef IFTMP_43
  2342 17C0 8C E0 23			sty IFTMP_43
  2343 					eif
  2344 17C3 98				tya
  2345 17C4 F0 03			jeq l_0444
  2346
  2347 				; optimize OK (intro.pas), line = 52
  2348
  2349 17C6 EE 92 23			inc adr.GFXCOLORS+$00
  2350 17C9			l_0444
  2351
  2352 				; Restore conditional expression
  2353 17C9 AD E0 23			lda IFTMP_43
  2354
  2355 				; else condition
  2356 17CC D0 09			jne l_0450
  2357
  2358
  2359 				; optimize OK (intro.pas), line = 52
  2360
  2361 17CE AC AD 23			ldy Y
  2362 17D1 B9 96 23			lda adr.PICCOLORS,y
  2363 17D4 8D 92 23			sta adr.GFXCOLORS+$00
  2364 17D7			l_0450
  2365
  2366 				; optimize OK (intro.pas), line = 53
  2367
  2368 17D7 AD 93 23			lda adr.GFXCOLORS+$01
  2369 17DA 29 0F			and #$0F
  2370 17DC 85 A1			sta :STACKORIGIN+9
  2371 17DE AC AD 23			ldy Y
  2372 17E1 C8				iny
  2373 17E2 B9 96 23			lda adr.PICCOLORS,y
  2374 17E5 29 0F			and #$0F
  2375 17E7 85 A2			sta :STACKORIGIN+10
  2376 17E9 A0 01			ldy #1
  2377 17EB A5 A1			lda :STACKORIGIN+9
  2378 17ED C5 A2			cmp :STACKORIGIN+10
  2379 17EF D0 01			bne @+
  2380 17F1 88				dey
  2381 17F2			@
  2382 					.ifdef IFTMP_44
  2383 17F2 8C E1 23			sty IFTMP_44
  2384 					eif
  2385 17F5 98				tya
  2386 17F6 F0 03			jeq l_047E
  2387
  2388 				; optimize OK (intro.pas), line = 53
  2389
  2390 17F8 EE 93 23			inc adr.GFXCOLORS+$01
  2391 17FB			l_047E
  2392
  2393 				; Restore conditional expression
  2394 17FB AD E1 23			lda IFTMP_44
  2395
  2396 				; else condition
  2397 17FE D0 0A			jne l_048A
  2398
  2399
  2400 				; optimize OK (intro.pas), line = 53
  2401
  2402 1800 AC AD 23			ldy Y
  2403 1803 C8				iny
  2404 1804 B9 96 23			lda adr.PICCOLORS,y
  2405 1807 8D 93 23			sta adr.GFXCOLORS+$01
  2406 180A			l_048A
  2407
  2408 				; optimize OK (intro.pas), line = 54
  2409
  2410 180A AD 94 23			lda adr.GFXCOLORS+$02
  2411 180D 29 0F			and #$0F
  2412 180F 85 A1			sta :STACKORIGIN+9
  2413 1811 AD AD 23			lda Y
  2414 1814 18 69 02			add #$02
  2415 1817 A8				tay
  2416 1818 B9 96 23			lda adr.PICCOLORS,y
  2417 181B 29 0F			and #$0F
  2418 181D 85 A2			sta :STACKORIGIN+10
  2419 181F A0 01			ldy #1
  2420 1821 A5 A1			lda :STACKORIGIN+9
  2421 1823 C5 A2			cmp :STACKORIGIN+10
  2422 1825 D0 01			bne @+
  2423 1827 88				dey
  2424 1828			@
  2425 					.ifdef IFTMP_45
  2426 1828 8C E2 23			sty IFTMP_45
  2427 					eif
  2428 182B 98				tya
  2429 182C F0 03			jeq l_04BC
  2430
  2431 				; optimize OK (intro.pas), line = 54
  2432
  2433 182E EE 94 23			inc adr.GFXCOLORS+$02
  2434 1831			l_04BC
  2435
  2436 				; Restore conditional expression
  2437 1831 AD E2 23			lda IFTMP_45
  2438
  2439 				; else condition
  2440 1834 D0 0D			jne l_04C8
  2441
  2442
  2443 				; optimize OK (intro.pas), line = 54
  2444
  2445 1836 AD AD 23			lda Y
  2446 1839 18 69 02			add #$02
  2447 183C A8				tay
  2448 183D B9 96 23			lda adr.PICCOLORS,y
  2449 1840 8D 94 23			sta adr.GFXCOLORS+$02
  2450 1843			l_04C8
  2451
  2452 				; optimize OK (intro.pas), line = 55
  2453
  2454 1843 AD 95 23			lda adr.GFXCOLORS+$03
  2455 1846 29 0F			and #$0F
  2456 1848 85 A1			sta :STACKORIGIN+9
  2457 184A AD AD 23			lda Y
  2458 184D 18 69 03			add #$03
  2459 1850 A8				tay
  2460 1851 B9 96 23			lda adr.PICCOLORS,y
  2461 1854 29 0F			and #$0F
  2462 1856 85 A2			sta :STACKORIGIN+10
  2463 1858 A0 01			ldy #1
  2464 185A A5 A1			lda :STACKORIGIN+9
  2465 185C C5 A2			cmp :STACKORIGIN+10
  2466 185E D0 01			bne @+
  2467 1860 88				dey
  2468 1861			@
  2469 					.ifdef IFTMP_46
  2470 1861 8C E3 23			sty IFTMP_46
  2471 					eif
  2472 1864 98				tya
  2473 1865 F0 03			jeq l_04FA
  2474
  2475 				; optimize OK (intro.pas), line = 55
  2476
  2477 1867 EE 95 23			inc adr.GFXCOLORS+$03
  2478 186A			l_04FA
  2479
  2480 				; Restore conditional expression
  2481 186A AD E3 23			lda IFTMP_46
  2482
  2483 				; else condition
  2484 186D D0 0D			jne l_0506
  2485
  2486
  2487 				; optimize OK (intro.pas), line = 55
  2488
  2489 186F AD AD 23			lda Y
  2490 1872 18 69 03			add #$03
  2491 1875 A8				tay
  2492 1876 B9 96 23			lda adr.PICCOLORS,y
  2493 1879 8D 95 23			sta adr.GFXCOLORS+$03
  2494 187C			l_0506
  2495
  2496 				; optimize OK (intro.pas), line = 57
  2497
  2498 187C AD A6 23			lda adr.TXTCOLORS+$00
  2499 187F A0 01			ldy #1
  2500 1881 29 0F			and #$0F
  2501 1883 D0 01			bne @+
  2502 1885 88				dey
  2503 1886			@
  2504 					.ifdef IFTMP_47
  2505 1886 8C E4 23			sty IFTMP_47
  2506 					eif
  2507 1889 98				tya
  2508 188A F0 03			jeq l_052B
  2509
  2510 				; optimize OK (intro.pas), line = 57
  2511
  2512 188C EE A6 23			inc adr.TXTCOLORS+$00
  2513 188F			l_052B
  2514
  2515 				; Restore conditional expression
  2516 188F AD E4 23			lda IFTMP_47
  2517
  2518 				; else condition
  2519 1892 D0 05			jne l_0537
  2520
  2521
  2522 				; optimize OK (intro.pas), line = 57
  2523
  2524 1894 A9 00 8D A6 23		mva #$00 adr.TXTCOLORS+$00
  2525 1899			l_0537
  2526
  2527 				; optimize OK (intro.pas), line = 58
  2528
  2529 1899 A0 01			ldy #1
  2530 189B B9 A6 23			lda adr.TXTCOLORS,y
  2531 189E 29 0F			and #$0F
  2532 18A0 C9 0C			cmp #$0C
  2533 18A2 D0 01			bne @+
  2534 18A4 88				dey
  2535 18A5			@
  2536 					.ifdef IFTMP_48
  2537 18A5 8C E5 23			sty IFTMP_48
  2538 					eif
  2539 18A8 98				tya
  2540 18A9 F0 03			jeq l_0553
  2541
  2542 				; optimize OK (intro.pas), line = 58
  2543
  2544 18AB EE A7 23			inc adr.TXTCOLORS+$01
  2545 18AE			l_0553
  2546
  2547 				; Restore conditional expression
  2548 18AE AD E5 23			lda IFTMP_48
  2549
  2550 				; else condition
  2551 18B1 D0 05			jne l_055F
  2552
  2553
  2554 				; optimize OK (intro.pas), line = 58
  2555
  2556 18B3 A9 1C 8D A7 23		mva #$1C adr.TXTCOLORS+$01
  2557 18B8			l_055F
  2558
  2559 				; optimize OK (intro.pas), line = 60
  2560
  2561 18B8 AD 92 23			lda adr.GFXCOLORS+$00
  2562 18BB 85 A1			sta :STACKORIGIN+9
  2563 18BD AC AD 23			ldy Y
  2564 18C0 B9 96 23			lda adr.PICCOLORS,y
  2565 18C3 A0 01			ldy #1
  2566 18C5 C5 A1			cmp :STACKORIGIN+9
  2567 18C7 F0 01			beq @+
  2568 18C9 88				dey
  2569 18CA			@
  2570 18CA 84 A1			sty :STACKORIGIN+9
  2571 18CC AD 93 23			lda adr.GFXCOLORS+$01
  2572 18CF 85 A2			sta :STACKORIGIN+10
  2573 18D1 AC AD 23			ldy Y
  2574 18D4 C8				iny
  2575 18D5 B9 96 23			lda adr.PICCOLORS,y
  2576 18D8 A0 01			ldy #1
  2577 18DA C5 A2			cmp :STACKORIGIN+10
  2578 18DC F0 01			beq @+
  2579 18DE 88				dey
  2580 18DF			@
  2581 18DF 98				tya
  2582 18E0 25 A1			and :STACKORIGIN+9
  2583 18E2 85 A1			sta :STACKORIGIN+9
  2584 18E4 AD 94 23			lda adr.GFXCOLORS+$02
  2585 18E7 85 A2			sta :STACKORIGIN+10
  2586 18E9 AD AD 23			lda Y
  2587 18EC 18 69 02			add #$02
  2588 18EF A8				tay
  2589 18F0 B9 96 23			lda adr.PICCOLORS,y
  2590 18F3 A0 01			ldy #1
  2591 18F5 C5 A2			cmp :STACKORIGIN+10
  2592 18F7 F0 01			beq @+
  2593 18F9 88				dey
  2594 18FA			@
  2595 18FA 98				tya
  2596 18FB 25 A1			and :STACKORIGIN+9
  2597 18FD 85 A1			sta :STACKORIGIN+9
  2598 18FF AD 95 23			lda adr.GFXCOLORS+$03
  2599 1902 85 A2			sta :STACKORIGIN+10
  2600 1904 AD AD 23			lda Y
  2601 1907 18 69 03			add #$03
  2602 190A A8				tay
  2603 190B B9 96 23			lda adr.PICCOLORS,y
  2604 190E A0 01			ldy #1
  2605 1910 C5 A2			cmp :STACKORIGIN+10
  2606 1912 F0 01			beq @+
  2607 1914 88				dey
  2608 1915			@
  2609 1915 98				tya
  2610 1916 25 A1			and :STACKORIGIN+9
  2611 1918 85 A1			sta :STACKORIGIN+9
  2612 191A A0 01			ldy #1
  2613 191C AD A6 23			lda adr.TXTCOLORS+$00
  2614 191F F0 01			beq @+
  2615 1921 88				dey
  2616 1922			@
  2617 1922 98				tya
  2618 1923 25 A1			and :STACKORIGIN+9
  2619 1925 85 A1			sta :STACKORIGIN+9
  2620 1927 A0 01			ldy #1
  2621 1929 B9 A6 23			lda adr.TXTCOLORS,y
  2622 192C C9 1C			cmp #$1C
  2623 192E F0 01			beq @+
  2624 1930 88				dey
  2625 1931			@
  2626 1931 98				tya
  2627 1932 25 A1			and :STACKORIGIN+9
  2628 1934 D0 03			bne *+5
  2629 1936			c_0422
  2630 1936 4C 9E 17			jmp l_0422
  2631 1939			b_0422
  2632
  2633 				; -----------------------------------------------------------
  2634
  2635 = 0000			TEXTCOLOR1	= $0000
  2636 = 001C			TEXTCOLOR2	= $001C
  2637 = 23E0			IFTMP_43	= DATAORIGIN+$0395
  2638 = 23E1			IFTMP_44	= DATAORIGIN+$0396
  2639 = 23E2			IFTMP_45	= DATAORIGIN+$0397
  2640 = 23E3			IFTMP_46	= DATAORIGIN+$0398
  2641 = 23E4			IFTMP_47	= DATAORIGIN+$0399
  2642 = 23E5			IFTMP_48	= DATAORIGIN+$039A
  2643
  2644 = 23E0			@VarData	= IFTMP_43
  2645 = 0006			@VarDataSize	= 6
  2646
  2647
  2648 1939			@exit
  2649 					.ifdef @new
  2650 					@FreeMem #@VarData #@VarDataSize
  2651 					eif
  2652 1939 60				rts						; ret
  2653 				.endl
  2654
  2655 193A			.local	GFX_FADEOUT					; PROCEDURE
  2656
  2657
  2658
  2659
  2660 				; --- RepeatUntilProlog
  2661 193A			l_05D8
  2662
  2663 				; optimize FAIL ('B_SYSTEM.WAITFRAMES', intro.pas), line = 67
  2664 193A E8				inx
  2665 193B A9 02 95 98			mva #$02 :STACKORIGIN,x
  2666 193F 20 66 10			jsr B_SYSTEM.WAITFRAMES
  2667
  2668 				; optimize OK (intro.pas), line = 68
  2669
  2670 1942 AD 92 23			lda adr.GFXCOLORS+$00
  2671 1945 A0 01			ldy #1
  2672 1947 29 0F			and #$0F
  2673 1949 D0 01			bne @+
  2674 194B 88				dey
  2675 194C			@
  2676 					.ifdef IFTMP_49
  2677 194C 8C E6 23			sty IFTMP_49
  2678 					eif
  2679 194F 98				tya
  2680 1950 F0 03			jeq l_05F1
  2681
  2682 				; optimize OK (intro.pas), line = 68
  2683
  2684 1952 CE 92 23			dec adr.GFXCOLORS+$00
  2685 1955			l_05F1
  2686
  2687 				; Restore conditional expression
  2688 1955 AD E6 23			lda IFTMP_49
  2689
  2690 				; else condition
  2691 1958 D0 05			jne l_05FD
  2692
  2693
  2694 				; optimize OK (intro.pas), line = 68
  2695
  2696 195A A9 00 8D 92 23		mva #$00 adr.GFXCOLORS+$00
  2697 195F			l_05FD
  2698
  2699 				; optimize OK (intro.pas), line = 69
  2700
  2701 195F A0 01			ldy #1
  2702 1961 B9 92 23			lda adr.GFXCOLORS,y
  2703 1964 29 0F			and #$0F
  2704 1966 C9 00			cmp #$00
  2705 1968 D0 01			bne @+
  2706 196A 88				dey
  2707 196B			@
  2708 					.ifdef IFTMP_50
  2709 196B 8C E7 23			sty IFTMP_50
  2710 					eif
  2711 196E 98				tya
  2712 196F F0 03			jeq l_0619
  2713
  2714 				; optimize OK (intro.pas), line = 69
  2715
  2716 1971 CE 93 23			dec adr.GFXCOLORS+$01
  2717 1974			l_0619
  2718
  2719 				; Restore conditional expression
  2720 1974 AD E7 23			lda IFTMP_50
  2721
  2722 				; else condition
  2723 1977 D0 05			jne l_0625
  2724
  2725
  2726 				; optimize OK (intro.pas), line = 69
  2727
  2728 1979 A9 00 8D 93 23		mva #$00 adr.GFXCOLORS+$01
  2729 197E			l_0625
  2730
  2731 				; optimize OK (intro.pas), line = 70
  2732
  2733 197E AD 94 23			lda adr.GFXCOLORS+$02
  2734 1981 A0 01			ldy #1
  2735 1983 29 0F			and #$0F
  2736 1985 D0 01			bne @+
  2737 1987 88				dey
  2738 1988			@
  2739 					.ifdef IFTMP_51
  2740 1988 8C E8 23			sty IFTMP_51
  2741 					eif
  2742 198B 98				tya
  2743 198C F0 03			jeq l_0641
  2744
  2745 				; optimize OK (intro.pas), line = 70
  2746
  2747 198E CE 94 23			dec adr.GFXCOLORS+$02
  2748 1991			l_0641
  2749
  2750 				; Restore conditional expression
  2751 1991 AD E8 23			lda IFTMP_51
  2752
  2753 				; else condition
  2754 1994 D0 05			jne l_064D
  2755
  2756
  2757 				; optimize OK (intro.pas), line = 70
  2758
  2759 1996 A9 00 8D 94 23		mva #$00 adr.GFXCOLORS+$02
  2760 199B			l_064D
  2761
  2762 				; optimize OK (intro.pas), line = 71
  2763
  2764 199B AD 95 23			lda adr.GFXCOLORS+$03
  2765 199E A0 01			ldy #1
  2766 19A0 29 0F			and #$0F
  2767 19A2 D0 01			bne @+
  2768 19A4 88				dey
  2769 19A5			@
  2770 					.ifdef IFTMP_52
  2771 19A5 8C E9 23			sty IFTMP_52
  2772 					eif
  2773 19A8 98				tya
  2774 19A9 F0 03			jeq l_0669
  2775
  2776 				; optimize OK (intro.pas), line = 71
  2777
  2778 19AB CE 95 23			dec adr.GFXCOLORS+$03
  2779 19AE			l_0669
  2780
  2781 				; Restore conditional expression
  2782 19AE AD E9 23			lda IFTMP_52
  2783
  2784 				; else condition
  2785 19B1 D0 05			jne l_0675
  2786
  2787
  2788 				; optimize OK (intro.pas), line = 71
  2789
  2790 19B3 A9 00 8D 95 23		mva #$00 adr.GFXCOLORS+$03
  2791 19B8			l_0675
  2792
  2793 				; optimize OK (intro.pas), line = 74
  2794
  2795 19B8 AD A6 23			lda adr.TXTCOLORS+$00
  2796 19BB A0 01			ldy #1
  2797 19BD 29 0F			and #$0F
  2798 19BF D0 01			bne @+
  2799 19C1 88				dey
  2800 19C2			@
  2801 					.ifdef IFTMP_53
  2802 19C2 8C EA 23			sty IFTMP_53
  2803 					eif
  2804 19C5 98				tya
  2805 19C6 F0 03			jeq l_0691
  2806
  2807 				; optimize OK (intro.pas), line = 74
  2808
  2809 19C8 CE A6 23			dec adr.TXTCOLORS+$00
  2810 19CB			l_0691
  2811
  2812 				; Restore conditional expression
  2813 19CB AD EA 23			lda IFTMP_53
  2814
  2815 				; else condition
  2816 19CE D0 05			jne l_069D
  2817
  2818
  2819 				; optimize OK (intro.pas), line = 74
  2820
  2821 19D0 A9 00 8D A6 23		mva #$00 adr.TXTCOLORS+$00
  2822 19D5			l_069D
  2823
  2824 				; optimize OK (intro.pas), line = 75
  2825
  2826 19D5 A0 01			ldy #1
  2827 19D7 B9 A6 23			lda adr.TXTCOLORS,y
  2828 19DA 29 0F			and #$0F
  2829 19DC C9 00			cmp #$00
  2830 19DE D0 01			bne @+
  2831 19E0 88				dey
  2832 19E1			@
  2833 					.ifdef IFTMP_54
  2834 19E1 8C EB 23			sty IFTMP_54
  2835 					eif
  2836 19E4 98				tya
  2837 19E5 F0 03			jeq l_06B9
  2838
  2839 				; optimize OK (intro.pas), line = 75
  2840
  2841 19E7 CE A7 23			dec adr.TXTCOLORS+$01
  2842 19EA			l_06B9
  2843
  2844 				; Restore conditional expression
  2845 19EA AD EB 23			lda IFTMP_54
  2846
  2847 				; else condition
  2848 19ED D0 05			jne l_06C5
  2849
  2850
  2851 				; optimize OK (intro.pas), line = 75
  2852
  2853 19EF A9 00 8D A7 23		mva #$00 adr.TXTCOLORS+$01
  2854 19F4			l_06C5
  2855
  2856 				; optimize OK (intro.pas), line = 77
  2857
  2858 19F4 AD 92 23			lda adr.GFXCOLORS+$00
  2859 19F7 0D 93 23			ora adr.GFXCOLORS+$01
  2860 19FA 0D 94 23			ora adr.GFXCOLORS+$02
  2861 19FD 0D 95 23			ora adr.GFXCOLORS+$03
  2862 1A00 0D A6 23			ora adr.TXTCOLORS+$00
  2863 1A03 85 A1			sta :STACKORIGIN+9
  2864 1A05 A0 01			ldy #1
  2865 1A07 B9 A6 23			lda adr.TXTCOLORS,y
  2866 1A0A 05 A1			ora :STACKORIGIN+9
  2867 1A0C C9 00			cmp #$00
  2868 1A0E F0 01			beq @+
  2869 1A10 88				dey
  2870 1A11			@
  2871 1A11 98				tya
  2872 1A12 D0 03			bne *+5
  2873 1A14			c_05D8
  2874 1A14 4C 3A 19			jmp l_05D8
  2875 1A17			b_05D8
  2876
  2877 				; -----------------------------------------------------------
  2878
  2879 = 23E6			IFTMP_49	= DATAORIGIN+$039B
  2880 = 23E7			IFTMP_50	= DATAORIGIN+$039C
  2881 = 23E8			IFTMP_51	= DATAORIGIN+$039D
  2882 = 23E9			IFTMP_52	= DATAORIGIN+$039E
  2883 = 23EA			IFTMP_53	= DATAORIGIN+$039F
  2884 = 23EB			IFTMP_54	= DATAORIGIN+$03A0
  2885
  2886 = 23E6			@VarData	= IFTMP_49
  2887 = 0006			@VarDataSize	= 6
  2888
  2889
  2890 1A17			@exit
  2891 					.ifdef @new
  2892 					@FreeMem #@VarData #@VarDataSize
  2893 					eif
  2894 1A17 60				rts						; ret
  2895 				.endl
  2896
  2897 1A18			.local	WAIT						; PROCEDURE
  2898
  2899 				; -----------------------------------------------------------
  2900
  2901 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  2902 				; as Pointer
  2903 1A18 B5 98 8D EC 23		mva :STACKORIGIN,x TIME
  2904 1A1D B5 A8 8D ED 23		mva :STACKORIGIN+STACKWIDTH,x TIME+1
  2905 1A22 CA				dex						; sub bx, 1
  2906
  2907
  2908
  2909
  2910 				; optimize OK (intro.pas), line = 102
  2911
  2912 1A23 A9 00 8D B0 23		mva #$00 COUNT
  2913 1A28 8D B1 23			sta COUNT+1
  2914
  2915 				; --- RepeatUntilProlog
  2916 1A2B			l_0707
  2917
  2918 				; optimize FAIL (0, intro.pas), line = 104
  2919 1A2B EE B0 23 D0 03 EE + 	inw COUNT
  2920
  2921 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 105
  2922 1A33 20 5F 10			jsr B_SYSTEM.WAITFRAME
  2923
  2924 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 106
  2925 1A36 20 0E 12			jsr B_CRT.CRT_KEYPRESSED
  2926 					.ifdef IFTMP_55
  2927 					lda :STACKORIGIN,x
  2928 					sta IFTMP_55
  2929 					eif
  2930 1A39 CA				dex
  2931 1A3A B5 99			lda :STACKORIGIN+1,x
  2932 1A3C F0 05			jeq l_0716
  2933
  2934 				; optimize OK (intro.pas), line = 106
  2935
  2936 1A3E A9 01 8D AE 23		mva #$01 SKIP
  2937 1A43			l_0716
  2938
  2939 				; optimize OK (intro.pas), line = 107
  2940
  2941 1A43 A0 01			ldy #1
  2942 1A45 AD B1 23			lda COUNT+1
  2943 1A48 CD ED 23			cmp TIME+1
  2944 1A4B D0 06			bne @+
  2945 1A4D AD B0 23			lda COUNT
  2946 1A50 CD EC 23			cmp TIME
  2947 1A53			@
  2948 1A53 F0 02			seq
  2949 1A55 B0 01			bcs @+
  2950 1A57 88				dey
  2951 1A58			@
  2952 1A58 84 A2			sty :STACKORIGIN+10
  2953 1A5A AD AE 23			lda SKIP
  2954 1A5D 05 A2			ora :STACKORIGIN+10
  2955 1A5F D0 03			bne *+5
  2956 1A61			c_0707
  2957 1A61 4C 2B 1A			jmp l_0707
  2958 1A64			b_0707
  2959
  2960 				; -----------------------------------------------------------
  2961
  2962 = 23EC			TIME	= DATAORIGIN+$03A1
  2963
  2964 = 23EC			@VarData	= TIME
  2965 = 0002			@VarDataSize	= 2
  2966
  2967
  2968 1A64			@exit
  2969 					.ifdef @new
  2970 					@FreeMem #@VarData #@VarDataSize
  2971 					eif
  2972 1A64 60				rts						; ret
  2973 				.endl
  2974 1A65			l_01CF
  2975
  2976 				; optimize FAIL ('B_SYSTEM.SYSTEMOFF_0229', intro.pas), line = 112
  2977 1A65 20 CD 0F			jsr B_SYSTEM.SYSTEMOFF_0229
  2978
  2979 				; optimize FAIL ('B_SYSTEM.SETCHARSET', intro.pas), line = 113
  2980 1A68 E8				inx
  2981 1A69 A9 E4 95 98			mva #$E4 :STACKORIGIN,x
  2982 1A6D 20 82 10			jsr B_SYSTEM.SETCHARSET
  2983
  2984 				; optimize FAIL ('B_CRT.CRT_INIT_02B0', intro.pas), line = 114
  2985 1A70 E8				inx
  2986 1A71 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2987 1A75 A9 E8 95 A8			mva #$E8 :STACKORIGIN+STACKWIDTH,x
  2988 1A79 20 E7 10			jsr B_CRT.CRT_INIT_02B0
  2989
  2990 				; optimize OK (intro.pas), line = 117
  2991
  2992 1A7C A9 00 8D A8 23		mva #$00 MSX.PLAYER
  2993 1A81 A9 39 8D A9 23		mva #$39 MSX.PLAYER+1
  2994
  2995 				; optimize OK (intro.pas), line = 118
  2996
  2997 1A86 A9 00 8D AA 23		mva #$00 MSX.MODUL
  2998 1A8B A9 41 8D AB 23		mva #$41 MSX.MODUL+1
  2999
  3000 				; optimize FAIL ('RMT.TRMT.INIT', intro.pas), line = 120
  3001 1A90 E8				inx
  3002 1A91 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3003 1A95 AD 53 1F			lda MSX
  3004 1A98 AC 54 1F			ldy MSX+1
  3005 1A9B 20 6A 13			jsr RMT.TRMT.INIT
  3006
  3007 				; optimize OK (intro.pas), line = 122
  3008
  3009 1A9E A9 00 8D AE 23		mva #$00 SKIP
  3010
  3011 				; optimize OK (intro.pas), line = 123
  3012
  3013 1AA3 A9 01 8D AF 23		mva #$01 MUSIC
  3014
  3015 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 125
  3016 1AA8 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3017
  3018 				; optimize OK (intro.pas), line = 126
  3019
  3020 1AAB A9 72 8D B2 23		mva <DLI_TITLE FIRSTDLI
  3021 1AB0 A9 17 8D B3 23		mva >DLI_TITLE FIRSTDLI+1
  3022
  3023 				; optimize FAIL ('B_SYSTEM.ENABLEVBLI', intro.pas), line = 127
  3024 1AB5 E8				inx
  3025 1AB6 A9 4D 95 98			mva <VBL :STACKORIGIN,x
  3026 1ABA A9 17 95 A8			mva >VBL :STACKORIGIN+STACKWIDTH,x
  3027 1ABE 20 D6 0F			jsr B_SYSTEM.ENABLEVBLI
  3028
  3029 				; optimize FAIL ('B_SYSTEM.ENABLEDLI', intro.pas), line = 128
  3030 1AC1 E8				inx
  3031 1AC2 A9 72 95 98			mva <DLI_TITLE :STACKORIGIN,x
  3032 1AC6 A9 17 95 A8			mva >DLI_TITLE :STACKORIGIN+STACKWIDTH,x
  3033 1ACA 20 25 10			jsr B_SYSTEM.ENABLEDLI
  3034
  3035 				; optimize OK (intro.pas), line = 129
  3036
  3037 1ACD A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3038 1AD2 A9 30 8D 03 D4		mva #$30 ATARI.DLISTL+1
  3039
  3040 				; optimize OK (intro.pas), line = 130
  3041
  3042 1AD7 A9 22 8D 00 D4		mva #$22 ATARI.DMACTL
  3043
  3044 				; optimize OK (intro.pas), line = 133
  3045
  3046 1ADC A9 00			lda #$00
  3047 1ADE 85 86			sta :edx
  3048 1AE0 A9 E8			lda #$E8
  3049 1AE2 85 87			sta :edx+1
  3050 1AE4 A9 28			lda #$28
  3051 1AE6 85 8A			sta :ecx
  3052 1AE8 A9 05			lda #$05
  3053 1AEA 85 8B			sta :ecx+1
  3054 1AEC A9 00			lda #$00
  3055 1AEE 85 82			sta :eax
  3056 1AF0 20 03 20			jsr @fill
  3057
  3058 				; optimize FAIL ('WAIT', intro.pas), line = 141
  3059 1AF3 E8				inx
  3060 1AF4 A9 4B 95 98			mva #$4B :STACKORIGIN,x
  3061 1AF8 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  3062 1AFC 20 18 1A			jsr WAIT
  3063
  3064 				; optimize OK (intro.pas), line = 143
  3065
  3066 1AFF A0 01			ldy #1
  3067 1B01 AD AE 23			lda SKIP
  3068 1B04 F0 01			beq @+
  3069 1B06 88				dey
  3070 1B07			@
  3071 					.ifdef IFTMP_56
  3072 					sty IFTMP_56
  3073 					eif
  3074 1B07 98				tya
  3075 1B08 F0 23			jeq l_076E
  3076
  3077 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 144
  3078 1B0A 20 3A 19			jsr GFX_FADEOUT
  3079
  3080 				; optimize FAIL ('B_CRT.CRT_GOTOXY', intro.pas), line = 145
  3081 1B0D E8				inx
  3082 1B0E A9 00 95 98			mva #$00 :STACKORIGIN,x
  3083 1B12 E8				inx
  3084 1B13 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3085 1B17 20 0B 11			jsr B_CRT.CRT_GOTOXY
  3086
  3087 				; optimize FAIL ('B_CRT.CRT_WRITE_02DD', intro.pas), line = 146
  3088 1B1A E8				inx
  3089 1B1B A0 00			ldy #$00 
  3090 1B1D B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3091 1B22 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3092 1B27 20 44 11			jsr B_CRT.CRT_WRITE_02DD
  3093
  3094 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 147
  3095 1B2A 20 96 17			jsr GFX_FADEIN
  3096 1B2D			l_076E
  3097
  3098 				; optimize FAIL ('WAIT', intro.pas), line = 156
  3099 1B2D E8				inx
  3100 1B2E A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3101 1B32 A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3102 1B36 20 18 1A			jsr WAIT
  3103
  3104 				; optimize OK (intro.pas), line = 158
  3105
  3106 1B39 A0 01			ldy #1
  3107 1B3B AD AE 23			lda SKIP
  3108 1B3E F0 01			beq @+
  3109 1B40 88				dey
  3110 1B41			@
  3111 					.ifdef IFTMP_57
  3112 					sty IFTMP_57
  3113 					eif
  3114 1B41 98				tya
  3115 1B42 F0 28			jeq l_078E
  3116
  3117 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 159
  3118 1B44 20 3A 19			jsr GFX_FADEOUT
  3119
  3120 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 160
  3121 1B47 E8				inx
  3122 1B48 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3123 1B4C 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3124
  3125 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 161
  3126 1B4F E8				inx
  3127 1B50 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3128 1B54 E8				inx
  3129 1B55 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3130 1B59 E8				inx
  3131 1B5A A0 02			ldy #$02 
  3132 1B5C B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3133 1B61 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3134 1B66 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3135
  3136 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 162
  3137 1B69 20 96 17			jsr GFX_FADEIN
  3138 1B6C			l_078E
  3139
  3140 				; optimize FAIL ('WAIT', intro.pas), line = 171
  3141 1B6C E8				inx
  3142 1B6D A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3143 1B71 A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3144 1B75 20 18 1A			jsr WAIT
  3145
  3146 				; optimize OK (intro.pas), line = 173
  3147
  3148 1B78 A0 01			ldy #1
  3149 1B7A AD AE 23			lda SKIP
  3150 1B7D F0 01			beq @+
  3151 1B7F 88				dey
  3152 1B80			@
  3153 					.ifdef IFTMP_58
  3154 					sty IFTMP_58
  3155 					eif
  3156 1B80 98				tya
  3157 1B81 D0 03 4C 0F 1C		jeq l_07AF
  3158
  3159 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 174
  3160 1B86 20 3A 19			jsr GFX_FADEOUT
  3161
  3162 				; optimize OK (intro.pas), line = 175
  3163
  3164 1B89 A9 00 8D AC 23		mva #$00 PICNUMBER
  3165
  3166 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 178
  3167 1B8E 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3168
  3169 				; optimize OK (intro.pas), line = 179
  3170
  3171 1B91 A9 2A 8D B2 23		mva <DLI_PIC1_F1 FIRSTDLI
  3172 1B96 A9 14 8D B3 23		mva >DLI_PIC1_F1 FIRSTDLI+1
  3173
  3174 				; optimize OK (intro.pas), line = 180
  3175
  3176 1B9B A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3177 1BA0 A9 31 8D 03 D4		mva #$31 ATARI.DLISTL+1
  3178
  3179 				; optimize OK (intro.pas), line = 183
  3180
  3181 1BA5 A9 00			lda #$00
  3182 1BA7 85 86			sta :edx
  3183 1BA9 A9 B8			lda #$B8
  3184 1BAB 85 87			sta :edx+1
  3185 1BAD A9 00			lda #$00
  3186 1BAF 85 8A			sta :ecx
  3187 1BB1 A9 E8			lda #$E8
  3188 1BB3 85 8B			sta :ecx+1
  3189 1BB5 A9 B0			lda #$B0
  3190 1BB7 85 82			sta :eax
  3191 1BB9 A9 04			lda #$04
  3192 1BBB 85 83			sta :eax+1
  3193 1BBD 20 AE 1F			jsr @move
  3194
  3195 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 185
  3196 1BC0 E8				inx
  3197 1BC1 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3198 1BC5 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3199
  3200 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 186
  3201 1BC8 E8				inx
  3202 1BC9 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3203 1BCD 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3204
  3205 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 187
  3206 1BD0 E8				inx
  3207 1BD1 A9 1A 95 98			mva #$1A :STACKORIGIN,x
  3208 1BD5 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3209
  3210 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 188
  3211 1BD8 E8				inx
  3212 1BD9 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3213 1BDD E8				inx
  3214 1BDE A9 18 95 98			mva #$18 :STACKORIGIN,x
  3215 1BE2 E8				inx
  3216 1BE3 A0 04			ldy #$04 
  3217 1BE5 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3218 1BEA B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3219 1BEF 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3220
  3221 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 189
  3222 1BF2 E8				inx
  3223 1BF3 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3224 1BF7 E8				inx
  3225 1BF8 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3226 1BFC E8				inx
  3227 1BFD A0 06			ldy #$06 
  3228 1BFF B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3229 1C04 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3230 1C09 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3231
  3232 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 190
  3233 1C0C 20 96 17			jsr GFX_FADEIN
  3234 1C0F			l_07AF
  3235
  3236 				; optimize FAIL ('WAIT', intro.pas), line = 199
  3237 1C0F E8				inx
  3238 1C10 A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3239 1C14 A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3240 1C18 20 18 1A			jsr WAIT
  3241
  3242 				; optimize OK (intro.pas), line = 201
  3243
  3244 1C1B A0 01			ldy #1
  3245 1C1D AD AE 23			lda SKIP
  3246 1C20 F0 01			beq @+
  3247 1C22 88				dey
  3248 1C23			@
  3249 					.ifdef IFTMP_59
  3250 					sty IFTMP_59
  3251 					eif
  3252 1C23 98				tya
  3253 1C24 D0 03 4C CC 1C		jeq l_07EA
  3254
  3255 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 202
  3256 1C29 20 3A 19			jsr GFX_FADEOUT
  3257
  3258 				; optimize OK (intro.pas), line = 203
  3259
  3260 1C2C A9 01 8D AC 23		mva #$01 PICNUMBER
  3261
  3262 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 205
  3263 1C31 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3264
  3265 				; optimize OK (intro.pas), line = 206
  3266
  3267 1C34 A9 0D 8D B2 23		mva <DLI_PIC2_F1 FIRSTDLI
  3268 1C39 A9 15 8D B3 23		mva >DLI_PIC2_F1 FIRSTDLI+1
  3269
  3270 				; optimize OK (intro.pas), line = 207
  3271
  3272 1C3E A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3273 1C43 A9 32 8D 03 D4		mva #$32 ATARI.DLISTL+1
  3274
  3275 				; optimize OK (intro.pas), line = 209
  3276
  3277 1C48 A9 B0			lda #$B0
  3278 1C4A 85 86			sta :edx
  3279 1C4C A9 BC			lda #$BC
  3280 1C4E 85 87			sta :edx+1
  3281 1C50 A9 00			lda #$00
  3282 1C52 85 8A			sta :ecx
  3283 1C54 A9 E8			lda #$E8
  3284 1C56 85 8B			sta :ecx+1
  3285 1C58 A9 B0			lda #$B0
  3286 1C5A 85 82			sta :eax
  3287 1C5C A9 04			lda #$04
  3288 1C5E 85 83			sta :eax+1
  3289 1C60 20 AE 1F			jsr @move
  3290
  3291 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 211
  3292 1C63 E8				inx
  3293 1C64 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3294 1C68 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3295
  3296 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 212
  3297 1C6B E8				inx
  3298 1C6C A9 19 95 98			mva #$19 :STACKORIGIN,x
  3299 1C70 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3300
  3301 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 213
  3302 1C73 E8				inx
  3303 1C74 A9 1A 95 98			mva #$1A :STACKORIGIN,x
  3304 1C78 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3305
  3306 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 214
  3307 1C7B E8				inx
  3308 1C7C A9 00 95 98			mva #$00 :STACKORIGIN,x
  3309 1C80 E8				inx
  3310 1C81 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3311 1C85 E8				inx
  3312 1C86 A0 08			ldy #$08 
  3313 1C88 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3314 1C8D B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3315 1C92 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3316
  3317 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 215
  3318 1C95 E8				inx
  3319 1C96 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3320 1C9A E8				inx
  3321 1C9B A9 19 95 98			mva #$19 :STACKORIGIN,x
  3322 1C9F E8				inx
  3323 1CA0 A0 0A			ldy #$0A 
  3324 1CA2 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3325 1CA7 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3326 1CAC 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3327
  3328 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 216
  3329 1CAF E8				inx
  3330 1CB0 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3331 1CB4 E8				inx
  3332 1CB5 A9 1A 95 98			mva #$1A :STACKORIGIN,x
  3333 1CB9 E8				inx
  3334 1CBA A0 0C			ldy #$0C 
  3335 1CBC B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3336 1CC1 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3337 1CC6 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3338
  3339 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 217
  3340 1CC9 20 96 17			jsr GFX_FADEIN
  3341 1CCC			l_07EA
  3342
  3343 				; optimize FAIL ('WAIT', intro.pas), line = 226
  3344 1CCC E8				inx
  3345 1CCD A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3346 1CD1 A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3347 1CD5 20 18 1A			jsr WAIT
  3348
  3349 				; optimize OK (intro.pas), line = 228
  3350
  3351 1CD8 A0 01			ldy #1
  3352 1CDA AD AE 23			lda SKIP
  3353 1CDD F0 01			beq @+
  3354 1CDF 88				dey
  3355 1CE0			@
  3356 					.ifdef IFTMP_60
  3357 					sty IFTMP_60
  3358 					eif
  3359 1CE0 98				tya
  3360 1CE1 D0 03 4C 89 1D		jeq l_082B
  3361
  3362 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 229
  3363 1CE6 20 3A 19			jsr GFX_FADEOUT
  3364
  3365 				; optimize OK (intro.pas), line = 230
  3366
  3367 1CE9 A9 02 8D AC 23		mva #$02 PICNUMBER
  3368
  3369 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 232
  3370 1CEE 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3371
  3372 				; optimize OK (intro.pas), line = 233
  3373
  3374 1CF1 A9 DB 8D B2 23		mva <DLI_PIC3_F1 FIRSTDLI
  3375 1CF6 A9 15 8D B3 23		mva >DLI_PIC3_F1 FIRSTDLI+1
  3376
  3377 				; optimize OK (intro.pas), line = 234
  3378
  3379 1CFB A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3380 1D00 A9 33 8D 03 D4		mva #$33 ATARI.DLISTL+1
  3381
  3382 				; optimize OK (intro.pas), line = 236
  3383
  3384 1D05 A9 60			lda #$60
  3385 1D07 85 86			sta :edx
  3386 1D09 A9 C1			lda #$C1
  3387 1D0B 85 87			sta :edx+1
  3388 1D0D A9 00			lda #$00
  3389 1D0F 85 8A			sta :ecx
  3390 1D11 A9 E8			lda #$E8
  3391 1D13 85 8B			sta :ecx+1
  3392 1D15 A9 B0			lda #$B0
  3393 1D17 85 82			sta :eax
  3394 1D19 A9 04			lda #$04
  3395 1D1B 85 83			sta :eax+1
  3396 1D1D 20 AE 1F			jsr @move
  3397
  3398 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 238
  3399 1D20 E8				inx
  3400 1D21 A9 18 95 98			mva #$18 :STACKORIGIN,x
  3401 1D25 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3402
  3403 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 239
  3404 1D28 E8				inx
  3405 1D29 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3406 1D2D 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3407
  3408 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 240
  3409 1D30 E8				inx
  3410 1D31 A9 1A 95 98			mva #$1A :STACKORIGIN,x
  3411 1D35 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3412
  3413 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 241
  3414 1D38 E8				inx
  3415 1D39 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3416 1D3D E8				inx
  3417 1D3E A9 18 95 98			mva #$18 :STACKORIGIN,x
  3418 1D42 E8				inx
  3419 1D43 A0 0E			ldy #$0E 
  3420 1D45 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3421 1D4A B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3422 1D4F 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3423
  3424 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 242
  3425 1D52 E8				inx
  3426 1D53 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3427 1D57 E8				inx
  3428 1D58 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3429 1D5C E8				inx
  3430 1D5D A0 10			ldy #$10 
  3431 1D5F B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3432 1D64 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3433 1D69 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3434
  3435 				; optimize FAIL ('B_CRT.CRT_WRITEXY', intro.pas), line = 243
  3436 1D6C E8				inx
  3437 1D6D A9 00 95 98			mva #$00 :STACKORIGIN,x
  3438 1D71 E8				inx
  3439 1D72 A9 1A 95 98			mva #$1A :STACKORIGIN,x
  3440 1D76 E8				inx
  3441 1D77 A0 12			ldy #$12 
  3442 1D79 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3443 1D7E B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3444 1D83 20 B0 11			jsr B_CRT.CRT_WRITEXY
  3445
  3446 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 244
  3447 1D86 20 96 17			jsr GFX_FADEIN
  3448 1D89			l_082B
  3449
  3450 				; optimize FAIL ('WAIT', intro.pas), line = 253
  3451 1D89 E8				inx
  3452 1D8A A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3453 1D8E A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3454 1D92 20 18 1A			jsr WAIT
  3455
  3456 				; optimize OK (intro.pas), line = 255
  3457
  3458 1D95 A0 01			ldy #1
  3459 1D97 AD AE 23			lda SKIP
  3460 1D9A F0 01			beq @+
  3461 1D9C 88				dey
  3462 1D9D			@
  3463 					.ifdef IFTMP_61
  3464 					sty IFTMP_61
  3465 					eif
  3466 1D9D 98				tya
  3467 1D9E F0 59			jeq l_086C
  3468
  3469 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 256
  3470 1DA0 20 3A 19			jsr GFX_FADEOUT
  3471
  3472 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 258
  3473 1DA3 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3474
  3475 				; optimize OK (intro.pas), line = 259
  3476
  3477 1DA6 A9 72 8D B2 23		mva <DLI_TITLE FIRSTDLI
  3478 1DAB A9 17 8D B3 23		mva >DLI_TITLE FIRSTDLI+1
  3479
  3480 				; optimize OK (intro.pas), line = 260
  3481
  3482 1DB0 A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3483 1DB5 A9 30 8D 03 D4		mva #$30 ATARI.DLISTL+1
  3484
  3485 				; optimize OK (intro.pas), line = 263
  3486
  3487 1DBA A9 00			lda #$00
  3488 1DBC 85 86			sta :edx
  3489 1DBE A9 E8			lda #$E8
  3490 1DC0 85 87			sta :edx+1
  3491 1DC2 A9 28			lda #$28
  3492 1DC4 85 8A			sta :ecx
  3493 1DC6 A9 05			lda #$05
  3494 1DC8 85 8B			sta :ecx+1
  3495 1DCA A9 00			lda #$00
  3496 1DCC 85 82			sta :eax
  3497 1DCE 20 03 20			jsr @fill
  3498
  3499 				; optimize FAIL ('B_SYSTEM.SETCHARSET', intro.pas), line = 264
  3500 1DD1 E8				inx
  3501 1DD2 A9 E4 95 98			mva #$E4 :STACKORIGIN,x
  3502 1DD6 20 82 10			jsr B_SYSTEM.SETCHARSET
  3503
  3504 				; optimize FAIL ('B_CRT.CRT_GOTOXY', intro.pas), line = 266
  3505 1DD9 E8				inx
  3506 1DDA A9 00 95 98			mva #$00 :STACKORIGIN,x
  3507 1DDE E8				inx
  3508 1DDF A9 18 95 98			mva #$18 :STACKORIGIN,x
  3509 1DE3 20 0B 11			jsr B_CRT.CRT_GOTOXY
  3510
  3511 				; optimize FAIL ('B_CRT.CRT_WRITE_02DD', intro.pas), line = 267
  3512 1DE6 E8				inx
  3513 1DE7 A0 14			ldy #$14 
  3514 1DE9 B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3515 1DEE B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3516 1DF3 20 44 11			jsr B_CRT.CRT_WRITE_02DD
  3517
  3518 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 268
  3519 1DF6 20 96 17			jsr GFX_FADEIN
  3520 1DF9			l_086C
  3521
  3522 				; optimize FAIL ('WAIT', intro.pas), line = 278
  3523 1DF9 E8				inx
  3524 1DFA A9 C2 95 98			mva #$C2 :STACKORIGIN,x
  3525 1DFE A9 01 95 A8			mva #$01 :STACKORIGIN+STACKWIDTH,x
  3526 1E02 20 18 1A			jsr WAIT
  3527
  3528 				; optimize OK (intro.pas), line = 279
  3529
  3530 1E05 A0 01			ldy #1
  3531 1E07 AD AE 23			lda SKIP
  3532 1E0A F0 01			beq @+
  3533 1E0C 88				dey
  3534 1E0D			@
  3535 					.ifdef IFTMP_62
  3536 					sty IFTMP_62
  3537 					eif
  3538 1E0D 98				tya
  3539 1E0E D0 03 4C BF 1E		jeq l_089A
  3540
  3541 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 280
  3542 1E13 20 3A 19			jsr GFX_FADEOUT
  3543
  3544 				; optimize OK (intro.pas), line = 281
  3545
  3546 1E16 A9 03 8D AC 23		mva #$03 PICNUMBER
  3547
  3548 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 283
  3549 1E1B 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3550
  3551 				; optimize OK (intro.pas), line = 284
  3552
  3553 1E1E A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  3554 1E23 A9 34 8D 03 D4		mva #$34 ATARI.DLISTL+1
  3555
  3556 				; optimize OK (intro.pas), line = 285
  3557
  3558 1E28 A9 BE 8D B2 23		mva <DLI_PIC4_F1 FIRSTDLI
  3559 1E2D A9 16 8D B3 23		mva >DLI_PIC4_F1 FIRSTDLI+1
  3560
  3561 				; optimize OK (intro.pas), line = 288
  3562
  3563 1E32 A9 10			lda #$10
  3564 1E34 85 86			sta :edx
  3565 1E36 A9 C6			lda #$C6
  3566 1E38 85 87			sta :edx+1
  3567 1E3A A9 00			lda #$00
  3568 1E3C 85 8A			sta :ecx
  3569 1E3E A9 E8			lda #$E8
  3570 1E40 85 8B			sta :ecx+1
  3571 1E42 A9 B0			lda #$B0
  3572 1E44 85 82			sta :eax
  3573 1E46 A9 04			lda #$04
  3574 1E48 85 83			sta :eax+1
  3575 1E4A 20 AE 1F			jsr @move
  3576 				; For
  3577
  3578 				; optimize OK (intro.pas), line = 290
  3579
  3580 1E4D A9 00 8D AD 23		mva #$00 Y
  3581
  3582 				; optimize OK (intro.pas), line = 290
  3583
  3584 				; To
  3585 1E52			l_08B5
  3586
  3587 				; ForToDoCondition
  3588
  3589 				; optimize OK (intro.pas), line = 290
  3590
  3591 1E52 AD AD 23			lda Y
  3592 1E55 C9 09			cmp #$09
  3593 1E57 90 05			bcc *+7
  3594 1E59 F0 03			beq *+5
  3595 1E5B 4C 9F 1E			jmp l_08C3
  3596
  3597 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 292
  3598 1E5E E8				inx
  3599 1E5F AD AD 23 95 98		mva Y :STACKORIGIN,x
  3600 1E64 E8				inx
  3601 1E65 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  3602 1E69 20 59 1F			jsr addAL_CL
  3603 1E6C CA				dex
  3604 1E6D 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3605
  3606 				; optimize FAIL ('B_CRT.CRT_WRITECENTERED_0337', intro.pas), line = 293
  3607 1E70 E8				inx
  3608 1E71 AD AD 23 95 98		mva Y :STACKORIGIN,x
  3609 1E76 E8				inx
  3610 1E77 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  3611 1E7B 20 59 1F			jsr addAL_CL
  3612 1E7E AD AD 23 95 98		mva Y :STACKORIGIN,x
  3613 1E83 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  3614 1E87				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 1E87 16 98			asl :STACKORIGIN-0,x
     2 1E89 36 A8			rol :STACKORIGIN-0+STACKWIDTH,x
Source: intro.a65
  3615 1E8B B4 98			ldy :STACKORIGIN,x
  3616 1E8D B9 CC 23 95 98		mva adr.CREDITSTXT,y :STACKORIGIN,x
  3617 1E92 B9 CD 23 95 A8		mva adr.CREDITSTXT+1,y :STACKORIGIN+STACKWIDTH,x
  3618 1E97 20 2C 12			jsr B_CRT.CRT_WRITECENTERED_0337
  3619
  3620 				; ForToDoEpilog
  3621 1E9A			c_08B5
  3622 1E9A EE AD 23			inc Y						; inc ptr byte [CounterAddress]
  3623
  3624 1E9D D0 B3			jne l_08B5
  3625
  3626 1E9F			l_08C3
  3627 1E9F			b_08B5
  3628
  3629 				; optimize FAIL ('B_CRT.CRT_CLEARROW_0363', intro.pas), line = 295
  3630 1E9F E8				inx
  3631 1EA0 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3632 1EA4 20 B8 12			jsr B_CRT.CRT_CLEARROW_0363
  3633
  3634 				; optimize FAIL ('B_CRT.CRT_WRITECENTERED_0337', intro.pas), line = 296
  3635 1EA7 E8				inx
  3636 1EA8 A9 19 95 98			mva #$19 :STACKORIGIN,x
  3637 1EAC E8				inx
  3638 1EAD A0 16			ldy #$16 
  3639 1EAF B9 B4 23 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3640 1EB4 B9 B5 23 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3641 1EB9 20 2C 12			jsr B_CRT.CRT_WRITECENTERED_0337
  3642
  3643 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 297
  3644 1EBC 20 96 17			jsr GFX_FADEIN
  3645 1EBF			l_089A
  3646
  3647 				; optimize OK (intro.pas), line = 300
  3648
  3649 1EBF A9 00 8D B0 23		mva #$00 COUNT
  3650 1EC4 8D B1 23			sta COUNT+1
  3651
  3652 				; --- RepeatUntilProlog
  3653 1EC7			l_08EC
  3654
  3655 				; optimize FAIL (0, intro.pas), line = 302
  3656 1EC7 EE B0 23 D0 03 EE + 	inw COUNT
  3657
  3658 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 303
  3659 1ECF 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3660
  3661 				; optimize OK (intro.pas), line = 304
  3662
  3663 1ED2 A0 01			ldy #1
  3664 1ED4 AD B1 23			lda COUNT+1
  3665 1ED7 C9 00			cmp #$00
  3666 1ED9 D0 05			bne @+
  3667 1EDB AD B0 23			lda COUNT
  3668 1EDE C9 32			cmp #$32
  3669 1EE0			@
  3670 1EE0 F0 01			beq @+
  3671 1EE2 88				dey
  3672 1EE3			@
  3673 					.ifdef IFTMP_63
  3674 					sty IFTMP_63
  3675 					eif
  3676 1EE3 98				tya
  3677 1EE4 F0 1A			jeq l_0902
  3678
  3679 				; optimize FAIL ('B_CRT.CRT_INVERT', intro.pas), line = 306
  3680 1EE6 E8				inx
  3681 1EE7 A9 05 95 98			mva #$05 :STACKORIGIN,x
  3682 1EEB E8				inx
  3683 1EEC A9 19 95 98			mva #$19 :STACKORIGIN,x
  3684 1EF0 E8				inx
  3685 1EF1 A9 1D 95 98			mva #$1D :STACKORIGIN,x
  3686 1EF5 20 F8 12			jsr B_CRT.CRT_INVERT
  3687
  3688 				; optimize OK (intro.pas), line = 307
  3689
  3690 1EF8 A9 00 8D B0 23		mva #$00 COUNT
  3691 1EFD 8D B1 23			sta COUNT+1
  3692 1F00			l_0902
  3693
  3694 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 309
  3695 1F00 20 0E 12			jsr B_CRT.CRT_KEYPRESSED
  3696 					.ifdef IFTMP_64
  3697 					lda :STACKORIGIN,x
  3698 					sta IFTMP_64
  3699 					eif
  3700 1F03 CA				dex
  3701 1F04 B5 99			lda :STACKORIGIN+1,x
  3702 1F06 F0 05			jeq l_0917
  3703
  3704 				; optimize OK (intro.pas), line = 309
  3705
  3706 1F08 A9 01 8D AE 23		mva #$01 SKIP
  3707 1F0D			l_0917
  3708
  3709 				; optimize OK (intro.pas), line = 310
  3710
  3711 1F0D AD AE 23			lda SKIP
  3712 1F10 D0 03			bne *+5
  3713 1F12			c_08EC
  3714 1F12 4C C7 1E			jmp l_08EC
  3715 1F15			b_08EC
  3716
  3717 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 312
  3718 1F15 20 3A 19			jsr GFX_FADEOUT
  3719
  3720 				; optimize OK (intro.pas), line = 313
  3721
  3722 1F18 A9 00 8D AF 23		mva #$00 MUSIC
  3723
  3724 				; optimize FAIL ('RMT.TRMT.STOP', intro.pas), line = 314
  3725 1F1D AD 53 1F			lda MSX
  3726 1F20 AC 54 1F			ldy MSX+1
  3727 1F23 20 EE 13			jsr RMT.TRMT.STOP
  3728
  3729 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 315
  3730 1F26 20 5F 10			jsr B_SYSTEM.WAITFRAME
  3731
  3732 				; optimize FAIL ('B_SYSTEM.DISABLEDLI', intro.pas), line = 316
  3733 1F29 20 50 10			jsr B_SYSTEM.DISABLEDLI
  3734
  3735 				; optimize FAIL ('B_SYSTEM.DISABLEVBLI', intro.pas), line = 317
  3736 1F2C 20 04 10			jsr B_SYSTEM.DISABLEVBLI
  3737
  3738 				; optimize OK (intro.pas), line = 318
  3739
  3740 1F2F A9 00 8D 0E D4		mva #$00 ATARI.NMIEN
  3741
  3742 				; optimize OK (intro.pas), line = 319
  3743
  3744 1F34 8D 00 D4			sta ATARI.DMACTL
  3745
  3746 				; ---------------------  ASM Block 115  ---------------------
  3747
  3748
  3749 1F37 18			        clc
  3750 1F38 60			        rts
  3751 				      
  3752
  3753 				; -----------------------------------------------------------
  3754
  3755 = 3000			FREE_TOP	= $3000
  3756 = 3000			DISPLAY_LIST_ADDRESS_TITLE	= $3000
  3757 = 3100			DISPLAY_LIST_ADDRESS_PIC1	= $3100
  3758 = 3200			DISPLAY_LIST_ADDRESS_PIC2	= $3200
  3759 = 3300			DISPLAY_LIST_ADDRESS_PIC3	= $3300
  3760 = 3400			DISPLAY_LIST_ADDRESS_PIC4	= $3400
  3761 = 3900			PLAYER_ADDRESS	= $3900
  3762 = 4100			MODULE_ADDRESS	= $4100
  3763 = 4800			CHAR_ADDRESS_PIC1_F1	= $4800
  3764 = 4C00			CHAR_ADDRESS_PIC1_F2	= $4C00
  3765 = 5000			CHAR_ADDRESS_PIC1_F3	= $5000
  3766 = 5400			CHAR_ADDRESS_PIC1_F4	= $5400
  3767 = 5800			CHAR_ADDRESS_PIC1_F5	= $5800
  3768 = 5C00			CHAR_ADDRESS_PIC1_F6	= $5C00
  3769 = 6000			CHAR_ADDRESS_PIC1_F7	= $6000
  3770 = 6400			CHAR_ADDRESS_PIC1_F8	= $6400
  3771 = 6800			CHAR_ADDRESS_PIC2_F1	= $6800
  3772 = 6C00			CHAR_ADDRESS_PIC2_F2	= $6C00
  3773 = 7000			CHAR_ADDRESS_PIC2_F3	= $7000
  3774 = 7400			CHAR_ADDRESS_PIC2_F4	= $7400
  3775 = 7800			CHAR_ADDRESS_PIC2_F5	= $7800
  3776 = 7C00			CHAR_ADDRESS_PIC2_F6	= $7C00
  3777 = 8000			CHAR_ADDRESS_PIC2_F7	= $8000
  3778 = 8400			CHAR_ADDRESS_PIC3_F1	= $8400
  3779 = 8800			CHAR_ADDRESS_PIC3_F2	= $8800
  3780 = 8C00			CHAR_ADDRESS_PIC3_F3	= $8C00
  3781 = 9000			CHAR_ADDRESS_PIC3_F4	= $9000
  3782 = 9400			CHAR_ADDRESS_PIC3_F5	= $9400
  3783 = 9800			CHAR_ADDRESS_PIC4_F1	= $9800
  3784 = 9C00			CHAR_ADDRESS_PIC4_F2	= $9C00
  3785 = B800			SCREEN_ADDRESS_PIC1	= $B800
  3786 = BCB0			SCREEN_ADDRESS_PIC2	= $BCB0
  3787 = C160			SCREEN_ADDRESS_PIC3	= $C160
  3788 = C610			SCREEN_ADDRESS_PIC4	= $C610
  3789 = E400			CHARSET_ADDRESS	= $E400
  3790 = E800			TXT_ADDRESS	= $E800
  3791 = 0004			NUMBEROFPICS	= $0004
  3792 = 2392			adr.GFXCOLORS	= DATAORIGIN+$0347
  3793 1F39			.var GFXCOLORS	= adr.GFXCOLORS .word
  3794 = 2396			adr.PICCOLORS	= DATAORIGIN+$034B
  3795 1F39			.var PICCOLORS	= adr.PICCOLORS .word
  3796 = 23A6			adr.TXTCOLORS	= DATAORIGIN+$035B
  3797 1F39			.var TXTCOLORS	= adr.TXTCOLORS .word
  3798 = 23A8			adr.MSX	= DATAORIGIN+$035D
  3799 1F39			.var MSX	= adr.MSX .word
  3800 = 23A8			MSX.PLAYER	= DATAORIGIN+$035D
  3801 = 23AA			MSX.MODUL	= DATAORIGIN+$035F
  3802 = 23AC			PICNUMBER	= DATAORIGIN+$0361
  3803 = 23AD			Y	= DATAORIGIN+$0362
  3804 = 23AE			SKIP	= DATAORIGIN+$0363
  3805 = 23AF			MUSIC	= DATAORIGIN+$0364
  3806 = 23B0			COUNT	= DATAORIGIN+$0365
  3807 = 23B2			FIRSTDLI	= DATAORIGIN+$0367
  3808 = 23B4			adr.STRINGS	= DATAORIGIN+$0369
  3809 1F39			.var STRINGS	= adr.STRINGS .word
  3810 = 23CC			adr.CREDITSTXT	= DATAORIGIN+$0381
  3811 1F39			.var CREDITSTXT	= adr.CREDITSTXT .word
  3812 = 0009			@FORTMP_2226	= $0009
  3813
  3814 1F39			@exit
  3815
  3816 1F39 A2 00		@halt	ldx #0
  3817 1F3B 9A				txs
  3818
  3819 1F3C 60				rts
  3820
  3821 1F3D 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  3822
  3823 1F4D			.local	@DEFINES
  3824 1F4D			ATARI
  3825 				.endl
  3826
  3827 = 1F4D 92 23		GFXCOLORS
  3827 = 1F4F 96 23		PICCOLORS
  3827 = 1F51 A6 23		TXTCOLORS
  3827 = 1F53 A8 23		MSX
  3827 = 1F55 B4 23		STRINGS
  3827 = 1F57 CC 23		CREDITSTXT
  3827 				.endl
  3828
  3829 				; -----------------------------------------------------------
  3830
  3831 1F59				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   227 					opt l+
   228
   229 				/* ----------------------------------------------------------------------- */
   230
   231
   232 1F59			.proc	hiBYTE
   233 					lda :STACKORIGIN,x
   234 1F59				:4 lsr @
   235 					sta :STACKORIGIN,x
   236 					rts
   237 				.endp
   238
   239 1F59			.proc	hiWORD
   240 					lda :STACKORIGIN+STACKWIDTH,x
   241 					sta :STACKORIGIN,x
   242 					rts
   243 				.endp
   244
   245 1F59			.proc	hiCARD
   246 					lda :STACKORIGIN+STACKWIDTH*3,x
   247 					sta :STACKORIGIN+STACKWIDTH,x
   248
   249 					lda :STACKORIGIN+STACKWIDTH*2,x
   250 					sta :STACKORIGIN,x
   251 					rts
   252 				.endp
   253
   254
   255 1F59			.proc	movaBX_EAX		; mov [BX], EAX
   256 1F59				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   257 					rts
   258 				.endp
   259
   260 				/*
   261 				.proc	@pushBYTE
   262 					adc :STACKORIGIN+STACKWIDTH,x
   263 					sta bp+1
   264
   265 					mva (bp),y :STACKORIGIN,x
   266
   267 				;	lda #$00
   268 				;	sta :STACKORIGIN+STACKWIDTH,x
   269 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   270 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   271
   272 					rts
   273 				.endp
   274
   275
   276 				.proc	@pullWORD (.word ya) .reg
   277 					add :STACKORIGIN-1,x
   278 					sta bp2
   279 					tya
   280 					adc :STACKORIGIN-1+STACKWIDTH,x
   281 					sta bp2+1
   282
   283 					ldy #$00
   284
   285 					mva :STACKORIGIN,x (bp2),y
   286 					iny
   287 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   288
   289 					rts
   290 				.endp
   291
   292
   293 				.proc	@pullCARD (.word ya) .reg
   294 					add :STACKORIGIN-1,x
   295 					sta bp2
   296 					tya
   297 					adc :STACKORIGIN-1+STACKWIDTH,x
   298 					sta bp2+1
   299
   300 					ldy #$00
   301
   302 					mva :STACKORIGIN,x (bp2),y
   303 					iny
   304 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   305 					iny
   306 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   307 					iny
   308 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   309
   310 					rts
   311 				.endp
   312
   313
   314 				.proc	@pushWORD (.word ya) .reg
   315 					add :STACKORIGIN,x
   316 					sta bp2
   317 					tya
   318 					adc :STACKORIGIN+STACKWIDTH,x
   319 					sta bp2+1
   320
   321 					ldy #$00
   322
   323 					mva (bp2),y :STACKORIGIN,x
   324 					iny
   325 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   326
   327 					rts
   328 				.endp
   329
   330
   331 				.proc	@pushCARD (.word ya) .reg
   332 					add :STACKORIGIN,x
   333 					sta bp2
   334 					tya
   335 					adc :STACKORIGIN+STACKWIDTH,x
   336 					sta bp2+1
   337
   338 					ldy #$00
   339
   340 					mva (bp2),y :STACKORIGIN,x
   341 					iny
   342 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   343 					iny
   344 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   345 					iny
   346 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   347
   348 					rts
   349 				.endp
   350 				*/
   350
   351
   352 1F59			.proc	shlEAX_CL
   353
   354 				;SHORT	jsr @expandToCARD1.SHORT
   355 				;	jmp CARD
   356
   357 				;SMALL	jsr @expandToCARD1.SMALL
   358 				;	jmp CARD
   359
   360 1F59			BYTE	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH,x
   362
   363 1F59			WORD	lda #0
   364 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   365 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   366
   367 1F59			CARD	clc
   368 					ldy :STACKORIGIN,x	; cl
   369 					beq stop
   370 1F59			@	asl :STACKORIGIN-1,x	; eax
   371 					rol :STACKORIGIN-1+STACKWIDTH,x
   372 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   373 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   374 					dey
   375 					bne @-
   376
   377 1F59			stop	rts
   378 				.endp
   379
   380
   381 1F59			.proc	shrAL_CL
   382
   383 				;SHORT	jsr @expandToCARD1.SHORT
   384 				;	jmp shrEAX_CL
   385
   386 1F59			BYTE	ldy :STACKORIGIN,x	; cl
   387 					beq stop
   388 1F59			@	lsr :STACKORIGIN-1,x
   389 					dey
   390 					bne @-
   391
   392 1F59			stop	lda #0
   393 					sta :STACKORIGIN-1+STACKWIDTH,x
   394 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   395 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   396
   397 					rts
   398 				.endp
   399
   400 1F59			.proc	shrAX_CL
   401
   402 				;SMALL	jsr @expandToCARD1.SMALL
   403 				;	jmp shrEAX_CL
   404
   405 1F59			WORD	ldy :STACKORIGIN,x	; cl
   406 					beq stop
   407 1F59			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   408 					ror :STACKORIGIN-1,x
   409 					dey
   410 					bne @-
   411
   412 1F59			stop	lda #0
   413 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   414 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   415
   416 					rts
   417 				.endp
   418
   419 1F59			.proc	shrEAX_CL
   420
   421 					ldy :STACKORIGIN,x	; cl
   422 					beq stop
   423 1F59			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   424 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   425 					ror :STACKORIGIN-1+STACKWIDTH,x
   426 					ror :STACKORIGIN-1,x
   427 					dey
   428 					bne @-
   429
   430 1F59			stop	rts
   431 				.endp
   432
   433 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   434 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   435 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   436
   437 1F59			.proc	addAL_CL
   438
   439 1F59 A0 00			ldy #0
   440
   441 1F5B 94 B7			sty :STACKORIGIN-1+STACKWIDTH*2,x
   442 1F5D 94 C7			sty :STACKORIGIN-1+STACKWIDTH*3,x
   443
   444 1F5F B5 97			lda :STACKORIGIN-1,x
   445 1F61 18 75 98			add :STACKORIGIN,x
   446 1F64 95 97			sta :STACKORIGIN-1,x
   447 1F66 90 01			scc
   448 1F68 C8				iny
   449
   450 1F69 94 A7			sty :STACKORIGIN-1+STACKWIDTH,x
   451
   452 1F6B 60				rts
   453 				.endp
   454
   455 1F6C			.proc	addAX_CX
   456
   457 					ldy #0
   458
   459 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   460
   461 					lda :STACKORIGIN-1,x
   462 					add :STACKORIGIN,x
   463 					sta :STACKORIGIN-1,x
   464
   465 					lda :STACKORIGIN-1+STACKWIDTH,x
   466 					adc :STACKORIGIN+STACKWIDTH,x
   467 					sta :STACKORIGIN-1+STACKWIDTH,x
   468 					scc
   469 					iny
   470
   471 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   472
   473 					rts
   474 				.endp
   475
   476
   477 1F6C			.proc	addEAX_ECX
   478 				/*
   479 				SHORT	jsr @expandToCARD.SHORT
   480 					jsr @expandToCARD1.SHORT
   481 					jmp CARD
   482
   483 				SMALL	jsr @expandToCARD.SMALL
   484 					jsr @expandToCARD1.SMALL
   485 				*/
   485
   486 1F6C			CARD	lda :STACKORIGIN-1,x
   487 					add :STACKORIGIN,x
   488 					sta :STACKORIGIN-1,x
   489
   490 					lda :STACKORIGIN-1+STACKWIDTH,x
   491 					adc :STACKORIGIN+STACKWIDTH,x
   492 					sta :STACKORIGIN-1+STACKWIDTH,x
   493
   494 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   495 					adc :STACKORIGIN+STACKWIDTH*2,x
   496 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   497
   498 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   499 					adc :STACKORIGIN+STACKWIDTH*3,x
   500 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   501
   502 					rts
   503 				.endp
   504
   505
   506 1F6C			.proc	subAL_CL
   507
   508 					ldy #0
   509
   510 					lda :STACKORIGIN-1,x
   511 					sub :STACKORIGIN,x
   512 					sta :STACKORIGIN-1,x
   513 					scs
   514 					dey
   515
   516 					sty :STACKORIGIN-1+STACKWIDTH,x
   517 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   518 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   519
   520 					rts
   521 				.endp
   522
   523 1F6C			.proc	subAX_CX
   524
   525 					ldy #0
   526
   527 					lda :STACKORIGIN-1,x		; ax
   528 					sub :STACKORIGIN,x		; cx
   529 					sta :STACKORIGIN-1,x
   530
   531 					lda :STACKORIGIN-1+STACKWIDTH,x
   532 					sbc :STACKORIGIN+STACKWIDTH,x
   533 					sta :STACKORIGIN-1+STACKWIDTH,x
   534 					scs
   535 					dey
   536
   537 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   538 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   539
   540 					rts
   541 				.endp
   542
   543 1F6C			.proc	subEAX_ECX
   544
   545 					lda :STACKORIGIN-1,x
   546 					sub :STACKORIGIN,x
   547 					sta :STACKORIGIN-1,x
   548
   549 					lda :STACKORIGIN-1+STACKWIDTH,x
   550 					sbc :STACKORIGIN+STACKWIDTH,x
   551 					sta :STACKORIGIN-1+STACKWIDTH,x
   552
   553 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   554 					sbc :STACKORIGIN+STACKWIDTH*2,x
   555 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   556
   557 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   558 					sbc :STACKORIGIN+STACKWIDTH*3,x
   559 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   560
   561 					rts
   562 				.endp
   563
   564
   565 1F6C			.proc	@expandSHORT2SMALL
   566 					ldy #$00
   567 					lda :STACKORIGIN,x
   568 					spl
   569 					dey
   570 					sty :STACKORIGIN+STACKWIDTH,x
   571
   572 					rts
   573 				.endp
   574
   575 1F6C			.proc	@expandSHORT2SMALL1
   576 					ldy #$00
   577 					lda :STACKORIGIN-1,x
   578 					spl
   579 					dey
   580 					sty :STACKORIGIN-1+STACKWIDTH,x
   581
   582 					rts
   583 				.endp
   584
   585
   586 1F6C			.proc	@expandToCARD
   587
   588 1F6C			SMALL	lda :STACKORIGIN+STACKWIDTH,x
   589 					bpl WORD
   590
   591 					lda #$ff
   592 					bne _wo
   593
   594 1F6C			WORD	lda #$00
   595 					beq _wo
   596
   597 1F6C			SHORT	lda :STACKORIGIN,x
   598 					bpl BYTE
   599
   600 					lda #$ff
   601 					bne _by
   602
   603 1F6C			BYTE	lda #$00
   604
   605 1F6C			_by	sta :STACKORIGIN+STACKWIDTH,x
   606 1F6C			_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   607 1F6C			_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   608 					rts
   609 				.endp
   610
   611
   612 1F6C			.proc	@expandToCARD1
   613
   614 1F6C			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   615 					bpl WORD
   616
   617 					lda #$ff
   618 					bne _wo
   619
   620 1F6C			WORD	lda #$00
   621 					beq _wo
   622
   623 1F6C			SHORT	lda :STACKORIGIN-1,x
   624 					bpl BYTE
   625
   626 					lda #$ff
   627 					bne _by
   628
   629 1F6C			BYTE	lda #$00
   630
   631 1F6C			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   632 1F6C			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   633 1F6C			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   634 					rts
   635 				.endp
   636
   637 				/*
   638 				.proc	@cmpFor_WORD (.word ya) .reg
   639 					sta ztmp
   640 					sty ztmp+1
   641
   642 					ldy #1
   643 					lda (ztmp),y
   644 					cmp :STACKORIGIN+1+STACKWIDTH,x
   645 					bne stop
   646 					dey
   647 					lda (ztmp),y
   648 					cmp :STACKORIGIN+1,x
   649 				stop	rts
   650 				.endp
   651
   652
   653 				.proc	@cmpFor_CARD (.word ya) .reg
   654 					sta ztmp
   655 					sty ztmp+1
   656
   657 					ldy #3
   658 					lda (ztmp),y
   659 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   660 					bne stop
   661 					dey
   662 					lda (ztmp),y
   663 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   664 					bne stop
   665 					dey
   666 					lda (ztmp),y
   667 					cmp :STACKORIGIN+1+STACKWIDTH,x
   668 					bne stop
   669 					dey
   670 					lda (ztmp),y
   671 					cmp :STACKORIGIN+1,x
   672
   673 				stop	rts
   674 				.endp
   675
   676
   677 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   678 					sta ztmp
   679 					sty ztmp+1
   680
   681 					ldy	#0
   682 					lda	(ztmp),y
   683 					sec
   684 					sbc	:STACKORIGIN+1,x
   685 					bne	@cmpFor_INT.L4
   686
   687 					jmp	@cmpFor_INT.L1
   688 				.endp
   689
   690
   691 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   692 					sta ztmp
   693 					sty ztmp+1
   694
   695 					ldy	#1
   696 					lda	(ztmp),y
   697 					sec
   698 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   699 					bne	@cmpFor_INT.L4
   700
   701 					dey
   702 					lda	(ztmp),y
   703 					cmp	:STACKORIGIN+1,x
   704
   705 					jmp	@cmpFor_INT.L1
   706 				.endp
   707
   708
   709 				.proc	@cmpFor_INT(.word ya) .reg
   710 					sta ztmp
   711 					sty ztmp+1
   712
   713 					ldy	#3
   714 					lda	(ztmp),y
   715 					sec
   716 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   717 					bne	L4
   718
   719 					dey
   720 					lda	(ztmp),y
   721 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   722 					bne	L1
   723
   724 					dey
   725 					lda	(ztmp),y
   726 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   727 					bne	L1
   728
   729 					dey
   730 					lda	(ztmp),y
   731 					cmp	:STACKORIGIN+1,x
   732
   733 				L1	beq	L2
   734 					bcs	L3
   735
   736 					lda	#$FF	; Set the N flag
   737 				L2	rts
   738
   739 				L3	lda	#$01	; Clear the N flag
   740 					rts
   741
   742 				L4	bvc	L5
   743 					eor	#$FF	; Fix the N flag if overflow
   744 					ora	#$01	; Clear the Z flag
   745 				L5	rts
   746 				.endp
   747 				*/
   747
   748
   749 				; Piotr Fusik, 15.04.2002
   750 				; originally by Ullrich von Bassewitz
   751
   752 1F6C			.proc	cmpSHORTINT
   753 					lda	:STACKORIGIN-1,x
   754 					clv:sec
   755 					sbc	:STACKORIGIN,x
   756 					bne	cmpINT.L4
   757
   758 					jmp	cmpINT.L1
   759 				.endp
   760
   761
   762 1F6C			.proc	cmpSMALLINT
   763 					lda	:STACKORIGIN-1+STACKWIDTH,x
   764 					clv:sec
   765 					sbc	:STACKORIGIN+STACKWIDTH,x
   766 					bne	cmpINT.L4
   767
   768 					lda	:STACKORIGIN-1,x
   769 					cmp	:STACKORIGIN,x
   770
   771 					jmp	cmpINT.L1
   772 				.endp
   773
   774
   775 1F6C			.proc	cmpINT
   776 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   777 					clv:sec
   778 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   779 					bne	L4
   780
   781 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   782 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   783 					bne	L1
   784
   785 					lda	:STACKORIGIN-1+STACKWIDTH,x
   786 					cmp	:STACKORIGIN+STACKWIDTH,x
   787 					bne	L1
   788
   789 					lda	:STACKORIGIN-1,x
   790 					cmp	:STACKORIGIN,x
   791
   792 1F6C			L1	beq	L2
   793 					bcs	L3
   794
   795 					lda	#$FF	; Set the N flag
   796 1F6C			L2	rts
   797
   798 1F6C			L3	lda	#$01	; Clear the N flag
   799 					rts
   800
   801 1F6C			L4	bvc	L5
   802 					eor	#$FF	; Fix the N flag if overflow
   803 					ora	#$01	; Clear the Z flag
   804 1F6C			L5	rts
   805 				.endp
   806
   807
   808 1F6C			.proc	cmpEAX_ECX
   809 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   810 					cmp :STACKORIGIN+STACKWIDTH*3,x
   811 					bne _done
   812 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   813 					cmp :STACKORIGIN+STACKWIDTH*2,x
   814 					bne _done
   815 1F6C			AX_CX
   816 					lda :STACKORIGIN-1+STACKWIDTH,x
   817 					cmp :STACKORIGIN+STACKWIDTH,x
   818 					bne _done
   819 					lda :STACKORIGIN-1,x
   820 					cmp :STACKORIGIN,x
   821
   822 1F6C			_done	rts
   823 				.endp
   824
   825
   826 1F6C			.proc	cmpSTRING2CHAR
   827
   828 					lda :STACKORIGIN-1,x
   829 					sta ztmp8
   830 					lda :STACKORIGIN-1+STACKWIDTH,x
   831 					sta ztmp8+1
   832
   833 					lda :STACKORIGIN,x
   834 					sta ztmp10
   835
   836 					ldy #0
   837
   838 					lda (ztmp8),y		; if length <> 1
   839 					cmp #1
   840 					bne fail
   841
   842 					iny
   843
   844 1F6C			loop	lda (ztmp8),y
   845 					cmp ztmp10
   846 					bne fail
   847
   848 					lda #0
   849 					seq
   850
   851 1F6C			fail	lda #$ff
   852
   853 					ldy #1
   854
   855 					cmp #0
   856 					rts
   857 				.endp
   858
   859
   860
   861 1F6C			.proc	cmpCHAR2STRING
   862
   863 					lda :STACKORIGIN-1,x
   864 					sta ztmp8
   865
   866 					lda :STACKORIGIN,x
   867 					sta ztmp10
   868 					lda :STACKORIGIN+STACKWIDTH,x
   869 					sta ztmp10+1
   870
   871 					ldy #0
   872
   873 					lda (ztmp10),y		; if length <> 1
   874 					cmp #1
   875 					bne fail
   876
   877 					iny
   878
   879 1F6C			loop	lda (ztmp10),y
   880 					cmp ztmp8
   881 					bne fail
   882
   883 					lda #0
   884 					seq
   885
   886 1F6C			fail	lda #$ff
   887
   888 					ldy #1
   889
   890 					cmp #0
   891 					rts
   892 				.endp
   893
   894
   895 1F6C			.proc	cmpSTRING
   896
   897 					lda :STACKORIGIN-1,x
   898 					sta ztmp8
   899 					lda :STACKORIGIN-1+STACKWIDTH,x
   900 					sta ztmp8+1
   901
   902 					lda :STACKORIGIN,x
   903 					sta ztmp10
   904 					lda :STACKORIGIN+STACKWIDTH,x
   905 					sta ztmp10+1
   906
   907 					ldy #0
   908
   909 					lda (ztmp8),y		; if length1 = 0
   910 					beq fail
   911 					lda (ztmp10),y		; if length2 = 0
   912 					beq fail
   913
   914 					lda (ztmp8),y		; if length1 <> length2
   915 					cmp (ztmp10),y
   916 					bne fail
   917
   918 					sta max
   919
   920 					inw ztmp8
   921 					inw ztmp10
   922
   923 1F6C			loop	lda (ztmp8),y
   924 					cmp (ztmp10),y
   925 					bne fail
   926
   927 					iny
   928
   929 					cpy #0
   930 1F6C			max	equ *-1
   931 					bne loop
   932
   933 					lda #0
   934 					seq
   935
   936 1F6C			fail	lda #$ff
   937
   938 					ldy #1
   939
   940 					cmp #0
   941 					rts
   942 				.endp
   943
   944
   945 1F6C			.proc	notaBX
   946
   947 					.rept MAXSIZE
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   949 					EOR #$FF
   950 					STA :STACKORIGIN+#*STACKWIDTH,X
   951 					.ENDR
   951 					.endr
Source: REPT
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   952
   953 					rts
   954 				.endp
   955
   956
   957 1F6C			.proc	notBOOLEAN
   958 					lda :STACKORIGIN,x
   959 					bne _0
   960
   961 					lda #true
   962 					sne
   963
   964 1F6C			_0	lda #false
   965 					sta :STACKORIGIN,x
   966
   967 					rts
   968 				.endp
   969
   970
   971 1F6C			.proc	negBYTE
   972 					lda #$00
   973 					sub :STACKORIGIN,x
   974 					sta :STACKORIGIN,x
   975
   976 					lda #$00
   977 					sbc #$00
   978 					sta :STACKORIGIN+STACKWIDTH,x
   979
   980 					lda #$00
   981 					sbc #$00
   982 					sta :STACKORIGIN+STACKWIDTH*2,x
   983
   984 					lda #$00
   985 					sbc #$00
   986 					sta :STACKORIGIN+STACKWIDTH*3,x
   987
   988 					rts
   989 				.endp
   990
   991 1F6C			.proc	negWORD
   992 					lda #$00
   993 					sub :STACKORIGIN,x
   994 					sta :STACKORIGIN,x
   995
   996 					lda #$00
   997 					sbc :STACKORIGIN+STACKWIDTH,x
   998 					sta :STACKORIGIN+STACKWIDTH,x
   999
  1000 					lda #$00
  1001 					sbc #$00
  1002 					sta :STACKORIGIN+STACKWIDTH*2,x
  1003
  1004 					lda #$00
  1005 					sbc #$00
  1006 					sta :STACKORIGIN+STACKWIDTH*3,x
  1007
  1008 					rts
  1009 				.endp
  1010
  1011 1F6C			.proc	negCARD
  1012 					lda #$00
  1013 					sub :STACKORIGIN,x
  1014 					sta :STACKORIGIN,x
  1015
  1016 					lda #$00
  1017 					sbc :STACKORIGIN+STACKWIDTH,x
  1018 					sta :STACKORIGIN+STACKWIDTH,x
  1019
  1020 					lda #$00
  1021 					sbc :STACKORIGIN+STACKWIDTH*2,x
  1022 					sta :STACKORIGIN+STACKWIDTH*2,x
  1023
  1024 					lda #$00
  1025 					sbc :STACKORIGIN+STACKWIDTH*3,x
  1026 					sta :STACKORIGIN+STACKWIDTH*3,x
  1027
  1028 					rts
  1029 				.endp
  1030
  1031
  1032 1F6C			.proc	negBYTE1
  1033 					lda #$00
  1034 					sub :STACKORIGIN-1,x
  1035 					sta :STACKORIGIN-1,x
  1036
  1037 					lda #$00
  1038 					sbc #$00
  1039 					sta :STACKORIGIN-1+STACKWIDTH,x
  1040
  1041 					lda #$00
  1042 					sbc #$00
  1043 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1044
  1045 					lda #$00
  1046 					sbc #$00
  1047 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1048
  1049 					rts
  1050 				.endp
  1051
  1052 1F6C			.proc	negWORD1
  1053 					lda #$00
  1054 					sub :STACKORIGIN-1,x
  1055 					sta :STACKORIGIN-1,x
  1056
  1057 					lda #$00
  1058 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1059 					sta :STACKORIGIN-1+STACKWIDTH,x
  1060
  1061 					lda #$00
  1062 					sbc #$00
  1063 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1064
  1065 					lda #$00
  1066 					sbc #$00
  1067 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1068
  1069 					rts
  1070 				.endp
  1071
  1072 1F6C			.proc	negCARD1
  1073 					lda #$00
  1074 					sub :STACKORIGIN-1,x
  1075 					sta :STACKORIGIN-1,x
  1076
  1077 					lda #$00
  1078 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1079 					sta :STACKORIGIN-1+STACKWIDTH,x
  1080
  1081 					lda #$00
  1082 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1083 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1084
  1085 					lda #$00
  1086 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1087 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1088
  1089 					rts
  1090 				.endp
  1091
  1092
  1093 1F6C			.proc	andAL_CL
  1094
  1095 					lda :STACKORIGIN-1,x
  1096 					and :STACKORIGIN,x
  1097 					sta :STACKORIGIN-1,x
  1098
  1099 					rts
  1100 				.endp
  1101
  1102 1F6C			.proc	andAX_CX
  1103
  1104 					.rept 2
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1106 					AND :STACKORIGIN+#*STACKWIDTH,X
  1107 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1108 					.ENDR
  1108 					.endr
Source: REPT
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1109
  1110 					rts
  1111 				.endp
  1112
  1113 1F6C			.proc	andEAX_ECX
  1114
  1115 					.rept MAXSIZE
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1117 					AND :STACKORIGIN+#*STACKWIDTH,X
  1118 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1119 					.ENDR
  1119 					.endr
Source: REPT
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1120
  1121 					rts
  1122 				.endp
  1123
  1124
  1125 1F6C			.proc	orAL_CL
  1126
  1127 					lda :STACKORIGIN-1,x
  1128 					ora :STACKORIGIN,x
  1129 					sta :STACKORIGIN-1,x
  1130
  1131 					rts
  1132 				.endp
  1133
  1134 1F6C			.proc	orAX_CX
  1135
  1136 					.rept 2
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1138 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1139 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1140 					.ENDR
  1140 					.endr
Source: REPT
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1141
  1142 					rts
  1143 				.endp
  1144
  1145 1F6C			.proc	orEAX_ECX
  1146
  1147 					.rept MAXSIZE
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1149 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1150 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1151 					.ENDR
  1151 					.endr
Source: REPT
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1152
  1153 					rts
  1154 				.endp
  1155
  1156
  1157 1F6C			.proc	xorAL_CL
  1158
  1159 					lda :STACKORIGIN-1,x
  1160 					eor :STACKORIGIN,x
  1161 					sta :STACKORIGIN-1,x
  1162
  1163 					rts
  1164 				.endp
  1165
  1166 1F6C			.proc	xorAX_CX
  1167
  1168 					.rept 2
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1170 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1171 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1172 					.ENDR
  1172 					.endr
Source: REPT
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1173
  1174 					rts
  1175 				.endp
  1176
  1177 1F6C			.proc	xorEAX_ECX
  1178
  1179 					.rept MAXSIZE
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1181 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1182 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1183 					.ENDR
  1183 					.endr
Source: REPT
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1184
  1185 					rts
  1186 				.endp
  1187
  1188
  1189 				/*
  1190 				.proc	iniEAX_ECX_BYTE
  1191
  1192 					mva :STACKORIGIN,x ecx
  1193 					mva :STACKORIGIN-1,x eax
  1194
  1195 					rts
  1196 				.endp
  1197 				*/
  1197
  1198
  1199
  1200 1F6C			.proc	iniEAX_ECX_WORD
  1201
  1202 					mva :STACKORIGIN,x ecx
  1203 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1204
  1205 					mva :STACKORIGIN-1,x eax
  1206 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1207
  1208 					mva #$00 ecx+2
  1209 					sta ecx+3
  1210
  1211 					sta eax+2
  1212 					sta eax+3
  1213
  1214 					rts
  1215 				.endp
  1216
  1217
  1218 1F6C			.proc	iniEAX_ECX_CARD
  1219 					mva :STACKORIGIN,x ecx
  1220 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1221 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1222 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1223
  1224 					mva :STACKORIGIN-1,x eax
  1225 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1226 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1227 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1228
  1229 					rts
  1230 				.endp
  1231
  1232 1F6C			.proc	movZTMP_aBX
  1233 					mva ZTMP8 :STACKORIGIN-1,x
  1234 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1235 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1236 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1237
  1238 					rts
  1239 				.endp
  1240
  1241
  1242 1F6C				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 1F6C			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 1F6C			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 1F6C			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 1F6C			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 1F6C			lsector	:8 dta l(256)
    55 1F6C			hsector	:8 dta h(256)
    56
    57 				.endp
  1243 1F6C				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 1F6C			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 1F6C			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 1F6C			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 1F6C			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 1F6C			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 1F6C			msg	lda #true
    64 1F6C			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 1F6C			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 1F6C			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 1F6C			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 1F6C			lookup	ldx #$00
   110 					ldy #$01
   111 1F6C			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 1F6C			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 1F6C			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 1F6C			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 1F6C			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 1F6C			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 1F6C			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 1F6C			done	jsr eof
   247
   248 1F6C			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 1F6C			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 1F6C			quit	rts
   265
   266 1F6C			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 1F6C			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 1F6C			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 1F6C			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 1F6C			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 1F6C			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 1F6C			stp2
   336 					dey
   337 					tya
   338 1F6C			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 1F6C			attr	equ *-1
   343 					rts
   344
   345 1F6C			cpName	sta ln
   346 1F6C			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 1F6C			ln	equ *-1
   354 					bne cp
   355 1F6C			stp	rts
   356 				.endp
   357
  1244
  1245 1F6C				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 1F6C			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 1F6C			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 1F6C			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 1F6C			.proc	divmulSHORTINT
    31
    32 1F6C			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 1F6C			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 1F6C			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 1F6C			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 1F6C			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 1F6C			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 1F6C			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1246 1F6C				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 1F6C			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 1F6C			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 1F6C			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 1F6C			.proc	divmulSMALLINT
    37
    38 1F6C			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 1F6C			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 1F6C			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 1F6C			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 1F6C			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 1F6C			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 1F6C			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 1F6C			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1247 1F6C				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 1F6C			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 1F6C			.proc	divmulINT
    16
    17 1F6C			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 1F6C			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 1F6C			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 1F6C			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 1F6C			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 1F6C			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 1F6C			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 1F6C			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1248
  1249 1F6C				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 1F6C			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 1F6C			sm1:		lda square1_lo,x
    49 1F6C			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 1F6C			sm3:		lda square1_hi,x
    52 1F6C			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 1F6C			.proc	imulCL
    75
    76 1F6C A9 00			lda #$00
    77
    78 1F6E A0 09			LDY #$09
    79 1F70 18				CLC
    80 1F71 6A			LOOP	ROR @
    81 1F72 66 82			ROR eax
    82 1F74 90 03			BCC MUL2
    83 1F76 18				CLC		;DEC AUX above to remove CLC
    84 1F77 65 8A			ADC ecx
    85 1F79 88			MUL2	DEY
    86 1F7A D0 F5			BNE LOOP
    87
    88 1F7C 85 83			STA eax+1
    89
    90 1F7E 60				RTS
    91 				.endp
    92
    93
    94 1F7F			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 1F7F			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 1F7F			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 1F7F			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 1F7F			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1250 1F7F				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 1F7F			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 1F7F			sm1a:		lda square1_lo,x
    78 1F7F			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 1F7F			sm3a:		lda square1_hi,x
    81 1F7F			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 1F7F			sm1b:		lda square1_lo,x
    88 1F7F			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 1F7F			sm3b:		lda square1_hi,x
    91 1F7F			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 1F7F			sm5a:		lda square1_lo,x
    98 1F7F			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 1F7F			sm7a:		lda square1_hi,x
   101 1F7F			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 1F7F			sm5b:		lda square1_lo,x
   107 1F7F			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 1F7F			sm7b:		lda square1_hi,x
   110 1F7F			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 1F7F			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 1F7F			_BB_:		lda #0
   122 1F7F			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 1F7F			@
   129 						tya
   130 1F7F			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 1F7F			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 1F7F			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 1F7F			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 1F7F			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 1F7F			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 1F7F			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 1F7F			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 1F7F			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 1F7F			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 1F7F			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1251 1F7F				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 1F7F			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 1F7F			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 1F7F			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 1F7F			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 1F7F			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 1F7F			.proc	idivEAX_ECX
    74
    75 1F7F			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 1F7F			CARD	;jsr iniEAX_ECX_CARD
    81
    82 1F7F			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 1F7F			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 1F7F			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1252
  1253 1F7F				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 1F7F			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 1F7F			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 1F7F			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 1F7F			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1254 1F7F				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 1F7F			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 1F7F			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 1F7F			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 1F7F			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 1F7F			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 1F7F			ecx3	equ *-1
    59 1F7F			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 1F7F			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 1F7F			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 1F7F			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 1F7F			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 1F7F			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 1F7F			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 1F7F			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 1F7F			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 1F7F			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 1F7F			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 1F7F			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 1F7F			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1255 1F7F				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 1F7F			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 1F7F			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 1F7F			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 1F7F			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 1F7F			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 1F7F			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 1F7F			FADD:	LDA	#$00
   159 1F7F			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 1F7F			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 1F7F			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 1F7F			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 1F7F			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 1F7F			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 1F7F			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 1F7F			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 1F7F			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 1F7F			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 1F7F			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 1F7F			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 1F7F			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 1F7F			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 1F7F			FPNORMLEFT1:	BMI	FPNORMDONE
   367 1F7F			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 1F7F			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 1F7F			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 1F7F			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 1F7F			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 1F7F			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 1F7F			@	EOR	#$FF
   480 					LDX	#$08
   481 1F7F			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 1F7F			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 1F7F			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 1F7F			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 1F7F			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 1F7F			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 1F7F			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 1F7F			.proc	FCMPL
   605 1F7F			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 1F7F			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 1F7F			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 1F7F			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 1F7F			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 1F7F			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 1F7F			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 1F7F			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 1F7F			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 1F7F			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 1F7F			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 1F7F			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 1F7F			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 1F7F			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 1F7F			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 1F7F			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 1F7F			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 1F7F			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 1F7F			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 1F7F			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 1F7F			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 1F7F			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 1F7F			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 1F7F			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1256
  1257
  1258 1F7F			.proc	@printCHAR
  1259 					ldy :STACKORIGIN,x
  1260 					jmp @print
  1261 				.endp
  1262
  1263
  1264 1F7F			.proc	@printEOL
  1265 					ldy #eol
  1266 					jmp @print
  1267 				.endp
  1268
  1269
  1270 1F7F			.proc	@print (.byte y) .reg
  1271 					txa:pha
  1272
  1273 					tya
  1274 					jsr @putchar
  1275
  1276 					pla:tax
  1277 					rts
  1278 				.endp
  1279
  1280
  1281 1F7F			.proc	@printPCHAR (.word ya) .reg
  1282
  1283 					cpy #0
  1284 					beq empty
  1285
  1286 					sta ztmp
  1287 					sty ztmp+1
  1288
  1289 					stx @sp
  1290
  1291 					lda #0
  1292 					sta loop+1
  1293
  1294 1F7F			loop	ldy #0
  1295 					lda (ztmp),y
  1296 					beq stop
  1297
  1298 					inc loop+1
  1299 					beq stop
  1300
  1301 					jsr @putchar
  1302
  1303 					jmp loop
  1304
  1305 1F7F			stop	ldx #0
  1306 1F7F			@sp	equ *-1
  1307
  1308 1F7F			empty	rts
  1309 				.endp
  1310
  1311
  1312 1F7F			.proc	@printSTRING (.word ya) .reg
  1313
  1314 					cpy #0
  1315 					beq empty
  1316
  1317 					sta ztmp
  1318 					sty ztmp+1
  1319
  1320 					stx @sp
  1321
  1322 					ldy #0
  1323 					sty loop+1
  1324 					lda (ztmp),y
  1325 					sta ln
  1326
  1327 					inw ztmp
  1328
  1329 1F7F			loop	ldy #0
  1330 					lda (ztmp),y
  1331 				;	beq stop
  1332
  1333 					cpy #0
  1334 1F7F			ln	equ *-1
  1335 					beq stop
  1336
  1337 					inc loop+1
  1338
  1339 					jsr @putchar
  1340
  1341 					jmp loop
  1342
  1343 1F7F			stop	ldx #0
  1344 1F7F			@sp	equ *-1
  1345
  1346 1F7F			empty	rts
  1347 				.endp
  1348
  1349
  1350 1F7F			.proc	@printBOOLEAN
  1351 					lda :STACKORIGIN,x
  1352 					beq _0
  1353
  1354 1F7F			_1	lda <_true
  1355 					ldy >_true
  1356 					jmp @printSTRING
  1357
  1358 1F7F			_0	lda <_false
  1359 					ldy >_false
  1360 					jmp @printSTRING
  1361
  1362 1F7F			_true	dta 4,c'TRUE'
  1363 1F7F			_false	dta 5,c'FALSE'
  1364 				.endp
  1365
  1366
  1367 1F7F			.proc	mov_BYTE_DX
  1368 					mva :STACKORIGIN,x dx
  1369 					mva #$00 dx+1
  1370 					sta dx+2
  1371 					sta dx+3
  1372
  1373 					rts
  1374 				.endp
  1375
  1376 1F7F			.proc	mov_WORD_DX
  1377 					mva :STACKORIGIN,x dx
  1378 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1379 					mva #$00 dx+2
  1380 					sta dx+3
  1381
  1382 					rts
  1383 				.endp
  1384
  1385 1F7F			.proc	mov_CARD_DX
  1386 					mva :STACKORIGIN,x dx
  1387 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1388 					mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1389 					mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1390
  1391 					rts
  1392 				.endp
  1393
  1394
  1395 1F7F			.proc	@printMINUS
  1396 					ldy #'-'
  1397 					jsr @printVALUE.pout
  1398
  1399 					jmp negCARD
  1400 				.endp
  1401
  1402
  1403 1F7F			.proc	@printSHORTREAL
  1404 					jsr @expandToCARD.SMALL
  1405 					jmp @printREAL
  1406 				.endp
  1407
  1408
  1409 1F7F			.proc	@FTOA
  1410
  1411 = 0086			i	= edx
  1412 = 008A			fra	= ecx
  1413 = 0082			hlp	= eax
  1414
  1415 = 0092			exp	= ztmp
  1416 = 0093			b	= ztmp+1
  1417 = 0094			sht	= ztmp+2
  1418
  1419 = 0440			bit	= @buf+64
  1420
  1421 					stx @sp
  1422
  1423 					mva :STACKORIGIN,x I
  1424 					sta :STACKORIGIN+9
  1425 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1426 					sta :STACKORIGIN+STACKWIDTH+9
  1427 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1428 					sta :STACKORIGIN+STACKWIDTH*2+9
  1429 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1430 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1431
  1432 					bpl skp
  1433
  1434 					ldy #'-'
  1435 					jsr @printVALUE.pout
  1436
  1437 1F7F			skp
  1438 				; optimize OK (test_3.pas), line = 32
  1439
  1440 					lda :STACKORIGIN+STACKWIDTH*3+9
  1441 					asl :STACKORIGIN+9
  1442 					rol :STACKORIGIN+STACKWIDTH+9
  1443 					rol :STACKORIGIN+STACKWIDTH*2+9
  1444 					rol @
  1445 					sta EXP				; Exponent
  1446
  1447 				; optimize OK (test_3.pas), line = 33
  1448
  1449 					lda I
  1450 					sta FRA
  1451 					lda I+1
  1452 					sta FRA+1
  1453 					lda I+2
  1454 					sta FRA+2
  1455 					lda I+3
  1456 					sta FRA+3
  1457 					asl FRA
  1458 					rol FRA+1
  1459 					rol FRA+2
  1460 					rol FRA+3
  1461
  1462 				; optimize OK (test_3.pas), line = 35
  1463
  1464 					lda EXP
  1465 					sub #$7F
  1466 					sta SHT
  1467
  1468 				; optimize OK (test_3.pas), line = 37
  1469
  1470 					ldx #$3f
  1471 					lda #0
  1472 					sta:rpl bit,x-
  1473
  1474 				; For
  1475
  1476 				; optimize OK (test_3.pas), line = 39
  1477
  1478 				;	sta B
  1479 					tax
  1480
  1481 				; optimize OK (test_3.pas), line = 39
  1482
  1483 1F7F			l_01D4
  1484 				;	lda B
  1485 				;	cmp #$17
  1486 					cpx #$17
  1487 					bcc *+7
  1488 					beq *+5
  1489
  1490 				; ForToDoProlog
  1491 					jmp l_01EE
  1492
  1493 				; optimize OK (test_3.pas), line = 40
  1494
  1495 				;	lda #$20
  1496 				;	add B
  1497 				;	tax
  1498
  1499 					lda FRA+2
  1500 					sta BIT+$20,x
  1501
  1502 				; optimize OK (test_3.pas), line = 41
  1503
  1504 					asl FRA
  1505 					rol FRA+1
  1506 					rol FRA+2
  1507 					rol FRA+3
  1508
  1509 				; ForToDoEpilog
  1510 1F7F			c_01D4
  1511 				;	inc B
  1512 					inx
  1513
  1514 					seq
  1515
  1516 				; WhileDoEpilog
  1517 					jmp l_01D4
  1518 1F7F			l_01EE
  1519 1F7F			b_01D4
  1520
  1521 				; optimize OK (test_3.pas), line = 44
  1522
  1523 					mva #$80 BIT+$1f
  1524
  1525 				; optimize OK (test_3.pas), line = 46
  1526
  1527 					mva #$00 I
  1528 					sta I+1
  1529 					sta I+2
  1530 					sta I+3
  1531
  1532 				; optimize OK (test_3.pas), line = 47
  1533
  1534 					sta FRA+1
  1535 					sta FRA+2
  1536 					sta FRA+3
  1537
  1538 					mva #$01 FRA
  1539
  1540 				; For
  1541
  1542 				; optimize OK (test_3.pas), line = 49
  1543
  1544 					lda SHT
  1545 					add #$1F
  1546 					sta B
  1547
  1548 				; optimize OK (test_3.pas), line = 49
  1549
  1550 					tay
  1551
  1552 1F7F			l_035B
  1553 				;	lda B
  1554 				;	cmp #$00
  1555 				;	bcs *+5
  1556
  1557 				; ForToDoProlog
  1558 				;	jmp l_0375
  1559
  1560 				; optimize OK (test_3.pas), line = 50
  1561
  1562 				;	ldy B
  1563 					lda BIT,y
  1564 					bpl l_03D7
  1565
  1566 				; optimize OK (test_3.pas), line = 50
  1567
  1568 					lda I				; Mantissa
  1569 					add FRA
  1570 					sta I
  1571 					lda I+1
  1572 					adc FRA+1
  1573 					sta I+1
  1574 					lda I+2
  1575 					adc FRA+2
  1576 					sta I+2
  1577 					lda I+3
  1578 					adc FRA+3
  1579 					sta I+3
  1580
  1581 				; IfThenEpilog
  1582 1F7F			l_03D7
  1583
  1584 				; optimize OK (test_3.pas), line = 52
  1585
  1586 					asl FRA
  1587 					rol FRA+1
  1588 					rol FRA+2
  1589 					rol FRA+3
  1590
  1591 				; ForToDoEpilog
  1592 1F7F			c_035B
  1593 				;	dec B
  1594 					dey
  1595
  1596 				;	lda B
  1597 				;	cmp #$ff
  1598 					cpy #$ff
  1599 					seq
  1600
  1601 				; WhileDoEpilog
  1602 					jmp l_035B
  1603 1F7F			l_0375
  1604 1F7F			b_035B
  1605
  1606 				; optimize OK (test_3.pas), line = 55
  1607
  1608 					mva #$00 FRA
  1609 					sta FRA+1
  1610 					sta FRA+2
  1611 					sta FRA+3
  1612
  1613 				; optimize OK (test_3.pas), line = 56
  1614
  1615 					sta EXP
  1616
  1617 					sta hlp
  1618 					sta hlp+1
  1619
  1620 					lda #$80
  1621 					sta hlp+2
  1622 				; For
  1623
  1624 				; optimize OK (test_3.pas), line = 58
  1625
  1626 					lda SHT
  1627 					add #$20
  1628 				;	sta B
  1629
  1630 					tay
  1631
  1632 				; optimize OK (test_3.pas), line = 58
  1633
  1634 					add #23
  1635 					sta FORTMP_1273
  1636 				; To
  1637 1F7F			l_0508
  1638
  1639 				; ForToDoCondition
  1640
  1641 				; optimize OK (test_3.pas), line = 58
  1642
  1643 				;	lda B
  1644 				;	cmp #0
  1645 					cpy #0
  1646 1F7F			FORTMP_1273	equ *-1
  1647 					bcc *+7
  1648 					beq *+5
  1649
  1650 				; ForToDoProlog
  1651 					jmp l_0534
  1652
  1653 				; optimize OK (test_3.pas), line = 59
  1654
  1655 				;	ldy B
  1656 					lda BIT,y
  1657 					bpl l_0596
  1658
  1659 				; optimize OK (test_3.pas), line = 59
  1660
  1661 					lda FRA
  1662 					add hlp
  1663 					sta FRA
  1664 					lda FRA+1
  1665 					adc hlp+1
  1666 					sta FRA+1
  1667 					lda FRA+2
  1668 					adc hlp+2
  1669 					sta FRA+2
  1670
  1671 				; IfThenEpilog
  1672 1F7F			l_0596
  1673
  1674 					lsr hlp+2
  1675 					ror hlp+1
  1676 					ror hlp
  1677
  1678 				; ForToDoEpilog
  1679 1F7F			c_0508
  1680 				;	inc B						; inc ptr byte [CounterAddress]
  1681 					iny
  1682
  1683 					seq
  1684
  1685 				; WhileDoEpilog
  1686 					jmp l_0508
  1687 1F7F			l_0534
  1688 1F7F			b_0508
  1689 1F7F				:3 mva fra+# fracpart+#
  1690
  1691 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1692 					@float #500000
  1693
  1694 					ldx #0
  1695 1F7F			@sp	equ *-1
  1696
  1697 					rts
  1698 				.endp
  1699
  1700
  1701 1F7F			.proc	@printREAL
  1702
  1703 					stx @sp
  1704
  1705 					lda :STACKORIGIN+STACKWIDTH*3,x
  1706 					spl
  1707 					jsr @printMINUS
  1708
  1709 					jsr mov_CARD_DX
  1710
  1711 					mva dx+1 intpart		; intpart := uvalue shr 8
  1712 					mva dx+2 intpart+1
  1713 					mva dx+3 intpart+2
  1714 					mva #$00 intpart+3
  1715
  1716 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1717 					sta dx+2
  1718 					sta dx+1
  1719
  1720 					sta fracpart
  1721 					sta fracpart+1
  1722
  1723 					lda dx
  1724 					sta fracpart+2
  1725
  1726 1F7F				:4 mva intpart+# dx+#		; integer part
  1727
  1728 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1729 					@float #5000
  1730
  1731 					ldx #0
  1732 1F7F			@sp	equ *-1
  1733 					rts
  1734
  1735 1F7F 00 00 00 00		intpart		.dword
  1736
  1737 				.endp
  1738
  1739
  1740 1F83			.proc	@float (.long axy) .reg
  1741
  1742 					sty cx
  1743 					stx cx+1
  1744 					sta cx+2
  1745
  1746 					lda @printVALUE.pout		; print integer part
  1747 					pha
  1748 					jsr @printVALUE
  1749 					pla
  1750 					sta @printVALUE.pout
  1751
  1752 					lda #0
  1753 					sta dx
  1754 					sta dx+1
  1755 					sta dx+2
  1756 					sta dx+3
  1757
  1758 1F83			loop	lda fracpart+2
  1759 					bpl skp
  1760
  1761 					clc
  1762 				;	lda cx
  1763 				;	spl
  1764 				;	sec
  1765
  1766 					lda dx
  1767 					adc cx
  1768 					sta dx
  1769 					lda dx+1
  1770 					adc cx+1
  1771 					sta dx+1
  1772 					lda dx+2
  1773 					adc cx+2
  1774 					sta dx+2
  1775 				;	lda dx+3
  1776 				;	adc #0
  1777 				;	sta dx+3
  1778
  1779 1F83			skp	lsr cx+2
  1780 					ror cx+1
  1781 					ror cx
  1782
  1783 					asl fracpart
  1784 					rol fracpart+1
  1785 					rol fracpart+2
  1786
  1787 					lda cx
  1788 					ora cx+1
  1789 					ora cx+2
  1790
  1791 					bne loop
  1792
  1793 					ldy #'.'
  1794 					jsr @printVALUE.pout
  1795
  1796 1F83				:4 mva dx+# fracpart+#
  1797
  1798 					lda @printVALUE.pout
  1799 					pha
  1800
  1801 					lda #{rts}
  1802 					sta @printVALUE.pout
  1803 					jsr @printVALUE			; floating part length
  1804
  1805 					sta cnt
  1806
  1807 					pla
  1808 					sta @printVALUE.pout
  1809
  1810 1F83			lp	lda #0
  1811 1F83			cnt	equ *-1
  1812 					cmp #4				; N miejsc po przecinku
  1813 1F83			afterpoint equ *-1
  1814 					bcs ok
  1815
  1816 					ldy #'0'
  1817 					jsr @printVALUE.pout
  1818
  1819 					inc cnt
  1820 					bne lp
  1821
  1822 1F83			ok	:4 mva fracpart+# dx+#
  1823 					jmp @printVALUE			; print floating part
  1824
  1825 				.endp
  1826
  1827
  1828 1F83			.proc	@printSHORTINT
  1829
  1830 					lda :STACKORIGIN,x
  1831 					spl
  1832 					jsr @printMINUS
  1833
  1834 					jmp @printBYTE
  1835 				.endp
  1836
  1837
  1838 1F83			.proc	@printSMALLINT
  1839
  1840 					lda :STACKORIGIN+STACKWIDTH,x
  1841 					spl
  1842 					jsr @printMINUS
  1843
  1844 					jmp @printWORD
  1845 				.endp
  1846
  1847
  1848 1F83			.proc	@printINT
  1849
  1850 					lda :STACKORIGIN+STACKWIDTH*3,x
  1851 					spl
  1852 					jsr @printMINUS
  1853
  1854 					jmp @printCARD
  1855 				.endp
  1856
  1857
  1858 1F83			.proc	@printCARD
  1859 					jsr mov_CARD_DX
  1860 					jmp @printVALUE
  1861 				.endp
  1862
  1863
  1864 1F83			.proc	@printWORD
  1865 					jsr mov_WORD_DX
  1866 					jmp @printVALUE
  1867 				.endp
  1868
  1869
  1870 1F83			.proc	@printBYTE
  1871 					jsr mov_BYTE_DX
  1872 					jmp @printVALUE
  1873 				.endp
  1874
  1875
  1876 1F83			.proc	@printVALUE
  1877
  1878 					lda dx+3
  1879 					bne _32bit
  1880
  1881 					lda dx+2
  1882 					bne _24bit
  1883
  1884 					lda dx+1
  1885 					bne _16bit
  1886
  1887 1F83			_8bit	lda #3
  1888 					bne l3
  1889
  1890 1F83			_16bit	lda #5
  1891 					bne l3
  1892
  1893 1F83			_24bit	lda #8
  1894 					bne l3
  1895
  1896 					; prints a 32 bit value to the screen (Graham)
  1897
  1898 1F83			_32bit	lda #10
  1899
  1900 1F83			l3	sta limit
  1901
  1902 					stx @sp
  1903
  1904 					ldx #0
  1905 					stx cnt
  1906
  1907 1F83			lp	jsr div10
  1908
  1909 					sta tmp,x
  1910 					inx
  1911 					cpx #10
  1912 1F83			limit	equ *-1
  1913 					bne lp
  1914
  1915 					;ldx #9
  1916 					dex
  1917
  1918 1F83			l1	lda tmp,x
  1919 					bne l2
  1920 					dex		; skip leading zeros
  1921 					bne l1
  1922
  1923 1F83			l2	lda tmp,x
  1924 					ora #$30
  1925 					tay
  1926
  1927 					jsr pout
  1928 					inc cnt
  1929
  1930 					dex
  1931 					bpl l2
  1932
  1933 					mva #{jmp*} pout
  1934
  1935 					lda #0
  1936 1F83			cnt	equ *-1
  1937
  1938 					ldx #0
  1939 1F83			@sp	equ *-1
  1940 					rts
  1941
  1942 1F83			pout	jmp @print
  1943
  1944 					sty @buf+1
  1945 1F83			pbuf	equ *-2
  1946 					inc pbuf
  1947
  1948 					rts
  1949
  1950 1F83			tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1951
  1952 				.endp
  1953
  1954
  1955 				; divides a 32 bit value by 10
  1956 				; remainder is returned in akku
  1957
  1958 1F83			.proc	div10
  1959 				        ldy #32		; 32 bits
  1960 				        lda #0
  1961 				        clc
  1962 1F83			l4      rol @
  1963 				        cmp #10
  1964 				        bcc skip
  1965 				        sbc #10
  1966 1F83			skip    rol dx
  1967 				        rol dx+1
  1968 				        rol dx+2
  1969 				        rol dx+3
  1970 				        dey
  1971 				        bpl l4
  1972
  1973 					rts
  1974 				.endp
  1975
  1976
  1977 1F83			.proc	@hexStr
  1978
  1979 = 0086			Value	= edx
  1980 = 008A			Digits	= ecx
  1981
  1982 					ldx Digits
  1983 					cpx #32
  1984 					scc
  1985 					ldx #32
  1986
  1987 					stx Digits
  1988
  1989 					lda Value
  1990 					jsr hex
  1991 					lda Value+1
  1992 					jsr hex
  1993 					lda Value+2
  1994 					jsr hex
  1995 					lda Value+3
  1996 					jsr hex
  1997
  1998 					lda Digits
  1999 					sta @buf
  2000 					rts
  2001
  2002 1F83			hex	pha
  2003 					and #$f
  2004 					jsr put
  2005 					pla
  2006 1F83				:4 lsr @
  2007 1F83			put	tay
  2008 					lda thex,y
  2009 					sta @buf,x
  2010 					dex
  2011 					rts
  2012
  2013 1F83			thex	dta c'0123456789ABCDEF'
  2014 				.endp
  2015
  2016
  2017 1F83			.proc	@ValueToStr (.word ya) .reg
  2018
  2019 					sta adr
  2020 					sty adr+1
  2021
  2022 					mva #{bit*} @printVALUE.pout
  2023 					mva <@buf+1 @printVALUE.pbuf
  2024
  2025 					jsr $ffff
  2026 1F83			adr	equ *-2
  2027
  2028 					ldy @printVALUE.pbuf
  2029 					dey
  2030 					sty @buf
  2031
  2032 					rts
  2033 				.endp
  2034
  2035
  2036 				;	ecx	isSign
  2037 				;	edx	Result
  2038
  2039 1F83			.proc	@StrToInt (.word ya) .reg
  2040
  2041 					sta bp2
  2042 					sty bp2+1
  2043
  2044 					ldy #0
  2045 					sty MAIN.SYSTEM.IOResult
  2046 					sty edx
  2047 					sty edx+1
  2048 					sty edx+2
  2049 					sty edx+3
  2050
  2051 					lda (bp2),y
  2052 					beq stop
  2053 					sta len
  2054
  2055 					inw bp2
  2056
  2057 					lda (bp2),y
  2058 					cmp #'-'
  2059 					sne
  2060 					iny
  2061
  2062 					sty ecx
  2063
  2064 1F83			l1	lda (bp2),y
  2065
  2066 					CLC
  2067 					ADC #$FF-'9'	; make m = $FF
  2068 					ADC #'9'-'0'+1	; carry set if in range n to m
  2069 					bcs ok
  2070
  2071 					lda #106	; Invalid numeric format
  2072 					sta MAIN.SYSTEM.IOResult
  2073
  2074 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2075
  2076 1F83			ok	jsr fmul10
  2077
  2078 					lda (bp2),y
  2079 					sub #$30
  2080 					sta ztmp
  2081
  2082 					lda #$00
  2083 					sta ztmp+1
  2084 					sta ztmp+2
  2085 					sta ztmp+3
  2086
  2087 					jsr fmul10.add32bit
  2088
  2089 					iny
  2090 					cpy #0
  2091 1F83			len	equ *-1
  2092 					bne l1
  2093
  2094 					lda ecx
  2095 					beq stop
  2096
  2097 					jsr negEDX
  2098
  2099 1F83			stop	ldy #0		; reg Y = 0 conversion successful
  2100 					rts
  2101 				.endp
  2102
  2103
  2104 1F83			.proc	negEDX
  2105 					lda #$00	; minus
  2106 					sub edx
  2107 					sta edx
  2108
  2109 					lda #$00
  2110 					sbc edx+1
  2111 					sta edx+1
  2112
  2113 					lda #$00
  2114 					sbc edx+2
  2115 					sta edx+2
  2116
  2117 					lda #$00
  2118 					sbc edx+3
  2119 					sta edx+3
  2120
  2121 					rts
  2122 				.endp
  2123
  2124
  2125 1F83			.proc	fmul10
  2126 					asl edx		;multiply by 2
  2127 					rol edx+1	;temp store in ZTMP
  2128 					rol edx+2
  2129 					rol edx+3
  2130
  2131 					lda edx
  2132 					sta ztmp
  2133 					lda edx+1
  2134 					sta ztmp+1
  2135 					lda edx+2
  2136 					sta ztmp+2
  2137 					lda edx+3
  2138 					sta ztmp+3
  2139
  2140 					asl edx
  2141 					rol edx+1
  2142 					rol edx+2
  2143 					rol edx+3
  2144
  2145 					asl edx
  2146 					rol edx+1
  2147 					rol edx+2
  2148 					rol edx+3
  2149
  2150 1F83			add32bit
  2151 					lda edx
  2152 					add ztmp
  2153 					sta edx
  2154 					lda edx+1
  2155 					adc ztmp+1
  2156 					sta edx+1
  2157 					lda edx+2
  2158 					adc ztmp+2
  2159 					sta edx+2
  2160 					lda edx+3
  2161 					adc ztmp+3
  2162 					sta edx+3
  2163
  2164 					rts
  2165 				.endp
  2166
  2167
  2168 1F83			.proc	@trunc
  2169
  2170 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2171 					spl
  2172 					jsr negCARD
  2173
  2174 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2175 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2176 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2177 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2178
  2179 					tya
  2180 					spl
  2181 					jsr negCARD
  2182
  2183 					rts
  2184 				.endp
  2185
  2186
  2187 1F83			.proc	@round
  2188
  2189 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2190 					spl
  2191 					jsr negCARD
  2192
  2193 					lda :STACKORIGIN,x
  2194 				//	add #$80
  2195 					cmp #$80
  2196 					lda :STACKORIGIN+STACKWIDTH,x
  2197 					adc #0
  2198 					sta :STACKORIGIN,x
  2199 					lda :STACKORIGIN+STACKWIDTH*2,x
  2200 					adc #0
  2201 					sta :STACKORIGIN+STACKWIDTH,x
  2202 					lda :STACKORIGIN+STACKWIDTH*3,x
  2203 					adc #0
  2204 					sta :STACKORIGIN+STACKWIDTH*2,x
  2205
  2206 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2207
  2208 					tya
  2209 					spl
  2210 					jsr negCARD
  2211
  2212 					rts
  2213 				.endp
  2214
  2215
  2216 1F83			.proc	@frac
  2217
  2218 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2219 					spl
  2220 					jsr negCARD
  2221
  2222 					lda #$00
  2223 					sta :STACKORIGIN+STACKWIDTH,x
  2224 					sta :STACKORIGIN+STACKWIDTH*2,x
  2225 					sta :STACKORIGIN+STACKWIDTH*3,x
  2226
  2227 					tya
  2228 					spl
  2229 					jsr negCARD
  2230
  2231 					rts
  2232 				.endp
  2233
  2234
  2235 1F83			.proc	@int
  2236
  2237 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2238 					spl
  2239 					jsr negCARD
  2240
  2241 					lda #$00
  2242 					sta :STACKORIGIN,x
  2243
  2244 					tya
  2245 					spl
  2246 					jsr negCARD
  2247
  2248 					rts
  2249 				.endp
  2250
  2251
  2252 				;----------------------------;
  2253 				; Biblioteka procedur        ;
  2254 				; graficznych                ;
  2255 				;----------------------------;
  2256 				; Autorzy:                   ;
  2257 				;  Slawomir 'SERO' Ritter,   ;
  2258 				;  Jakub Cebula,             ;
  2259 				;  Winfried Hofacker         ;
  2260 				;----------------------------;
  2261 				; Wersja:1.1 DATA:09.01.2008 ;
  2262 				;----------------------------;
  2263
  2264 = 0003			@open	= $03		; Otworz kanal
  2265 = 000C			@close	= $0c		; Zamknij kanal
  2266
  2267 = 0007			@IDget	= $07		; Narysuj punkt
  2268 = 0009			@IDput	= $09		; Narysuj punkt
  2269 = 0011			@IDdraw	= $11		; Narysuj linie
  2270 = 0012			@IDfill	= $12		; Wypelnij obszar
  2271
  2272
  2273 				;------------------------;
  2274 				;Wy:.Y-numer bledu (1-OK);
  2275 				;   f(N)=1-wystapil blad ;
  2276 				;------------------------;
  2277 1F83			.proc	@COMMAND
  2278
  2279 					ldx	#$00
  2280 1F83			scrchn	equ *-1
  2281
  2282 					sta	iocom,x
  2283
  2284 					lda	#$00
  2285 1F83			colscr	equ *-1
  2286 					sta	atachr
  2287
  2288 					jmp	ciov
  2289 				.endp
  2290
  2291 				;------------------------;
  2292 				; Ustaw tryb ekranu      ;
  2293 				;------------------------;
  2294 				;We:.X-numer kanalu      ;
  2295 				;      (normalnie 0)     ;
  2296 				;   .Y-numer trybu (O.S.);
  2297 				;   .A-Ustawiony bit nr :;
  2298 				;     5-Nie kasowanie    ;
  2299 				;       pamieci ekranu   ;
  2300 				;     4-Obecnosc okna    ;
  2301 				;       tekstowego       ;
  2302 				;     2-Odczyt z ekranu  ;
  2303 				;------------------------;
  2304 				;Wy:SCRCHN-numer kanalu  ;
  2305 				;  .Y-numer bledu (1-OK) ;
  2306 				;   f(N)=1 wystapil blad ;
  2307 				;------------------------;
  2308 1F83			@GRAPHICS .proc (.byte x,y,a) .reg
  2309
  2310 					sta	byte1
  2311 					sty	byte2
  2312
  2313 					stx	@COMMAND.scrchn
  2314
  2315 					lda	#@close
  2316 					jsr	xcio
  2317
  2318 					lda	#0		; =opcje
  2319 1F83			byte1	equ	*-1
  2320 					ora	#8		; +zapis na ekranie
  2321 					sta	ioaux1,x
  2322
  2323 					lda	#0
  2324 1F83			byte2	equ	*-1
  2325 					sta	ioaux2,x	;=nr.trybu
  2326
  2327 					mwa	#sname	ioadr,x
  2328
  2329 					lda	#@open
  2330
  2331 1F83			xcio	sta iocom,x
  2332 					jmp ciov
  2333
  2334 1F83			sname	dta c'S:',$9b
  2335
  2336 					.endp
  2337
  2338
  2339 1F83			.proc	@ata2int
  2340 				        asl
  2341 				        php
  2342 				        cmp #2*$60
  2343 				        bcs @+
  2344 				        sbc #2*$20-1
  2345 				        bcs @+
  2346 				        adc #2*$60
  2347 1F83			@       plp
  2348 				        ror
  2349 					rts
  2350 				.endp
  2351
  2352
  2353 				/*
  2354 				  PUT CHAR
  2355
  2356 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2357 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2358 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2359
  2360 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2361 				  JSR PUTCHR.
  2362 				*/
  2362
  2363
  2364 1F83			.proc	@putchar (.byte a) .reg
  2365
  2366 1F83			vbxe	bit *
  2367
  2368 					ldx #$00
  2369 					.ifdef MAIN.CRT.TextAttr
  2370 					ora MAIN.CRT.TextAttr
  2371 					.endif
  2372 					tay
  2373 					lda icputb+1,x
  2374 					pha
  2375 					lda icputb,x
  2376 					pha
  2377 					tya
  2378
  2379 					rts
  2380
  2381 				.endp
  2382
  2383
  2384 				/*
  2385 				  GETLINE
  2386
  2387 				  Program czeka, az uzytkownik wpisze ciag znakw z klawiatury i nacisnie klawisz RETURN.
  2388 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2389 				  (odczyt jest robiony z edytora ekranowego).
  2390
  2391 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2392 				  do rejestrw A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2393
  2394 				*/
  2394
  2395
  2396 1F83			.proc	@GetLine
  2397
  2398 					stx @sp
  2399
  2400 					ldx #0
  2401
  2402 					stx MAIN.SYSTEM.EoLn
  2403
  2404 					mwa	#@buf+1	icbufa,x
  2405
  2406 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2407
  2408 					mva	#$05	iccmd,x
  2409
  2410 					jsr	ciov
  2411
  2412 					dew icbufl
  2413 					mva icbufl @buf			; length
  2414
  2415 					ldx @buf+1
  2416 					cpx #EOL
  2417 					bne skp
  2418
  2419 					ldx #TRUE
  2420 					stx MAIN.SYSTEM.EoLn
  2421 1F83			skp
  2422 					ldx #0
  2423 1F83			@sp	equ *-1
  2424
  2425 					rts
  2426 				.endp
  2427
  2428
  2429 1F83			.proc	@GetKey
  2430
  2431 1F83			getk	lda kbcodes	; odczytaj kbcodes
  2432 					cmp #255		; czy jest znak?
  2433 					beq getk	; nie: czekaj
  2434 					ldy #255		; daj zna, e klawisz
  2435 					sty kbcodes	; zosta odebrany
  2436 					tay		; kod klawisza jako indeks
  2437 					lda (keydef),y	; do tablicy w ROM-ie
  2438
  2439 					rts
  2440 				.endp
  2441
  2442
  2443 1F83			.proc	@moveSTRING (.word ya) .reg
  2444
  2445 					sta @move.dst
  2446 					sty @move.dst+1
  2447
  2448 					mva :STACKORIGIN,x @move.src
  2449 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2450
  2451 					ldy #$00
  2452 					lda (@move.src),y
  2453 					add #1
  2454 					sta @move.cnt
  2455 					scc
  2456 					iny
  2457 					sty @move.cnt+1
  2458
  2459 					jmp @move
  2460 				.endp
  2461
  2462
  2463 1F83			.proc	@moveSTRING_1 (.word ya) .reg
  2464
  2465 					sta @move.dst
  2466 					sty @move.dst+1
  2467
  2468 					mva :STACKORIGIN,x @move.src
  2469 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2470
  2471 					ldy #$00
  2472 					lda (@move.src),y
  2473 				;	add #1
  2474 					sta @move.cnt
  2475 					sty @move.cnt+1
  2476
  2477 					inw @move.src
  2478
  2479 					jmp @move
  2480 				.endp
  2481
  2482
  2483 				; Ullrich von Bassewitz, 2003-08-20
  2484 				; Performance increase (about 20%) by
  2485 				; Christian Krueger, 2009-09-13
  2486
  2487 1F83			.proc	@moveu		; assert Y = 0
  2488
  2489 = 0086			ptr1	= edx
  2490 = 008A			ptr2	= ecx
  2491 = 0082			ptr3	= eax
  2492
  2493 1F83 8E AC 1F			stx @sp
  2494
  2495 1F86 A0 00			ldy	#0
  2496
  2497 1F88 A6 83			ldx     ptr3+1		; Get high byte of n
  2498 1F8A F0 13			beq     L2		; Jump if zero
  2499
  2500 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2501 					LDA     (PTR1),Y	
  2502 					STA     (PTR2),Y
  2503 					INY
  2504 					.ENDR
  2504 					.endr
Source: REPT
  2501 1F8C B1 86			LDA     (PTR1),Y	
  2501 1F8E 91 8A			STA     (PTR2),Y
  2501 1F90 C8				INY
  2501 1F91 B1 86			LDA     (PTR1),Y	
  2501 1F93 91 8A			STA     (PTR2),Y
  2501 1F95 C8				INY
Source: cpu6502.asm
  2505
  2506 1F96 D0 F4			bne     L1
  2507 1F98 E6 87			inc     ptr1+1
  2508 1F9A E6 8B			inc     ptr2+1
  2509 1F9C CA				dex			; Next 256 byte block
  2510 1F9D D0 ED			bne	L1		; Repeat if any
  2511
  2512 					; the following section could be 10% faster if we were able to copy
  2513 					; back to front - unfortunately we are forced to copy strict from
  2514 					; low to high since this function is also used for
  2515 					; memmove and blocks could be overlapping!
  2516 					; {
  2517 1F9F			L2:				; assert Y = 0
  2518 1F9F A6 82			ldx     ptr3		; Get the low byte of n
  2519 1FA1 F0 08			beq     done		; something to copy
  2520
  2521 1FA3 B1 86		L3:     lda     (ptr1),Y	; copy a byte
  2522 1FA5 91 8A			sta     (ptr2),Y
  2523 1FA7 C8				iny
  2524 1FA8 CA				dex
  2525 1FA9 D0 F8			bne     L3
  2526
  2527 					; }
  2528
  2529 1FAB A2 00		done	ldx #0
  2530 = 1FAC			@sp	equ *-1
  2531 1FAD 60				rts
  2532 				.endp
  2533
  2534
  2535 1FAE			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2536
  2537 = 0086			ptr1	= edx
  2538 = 008A			ptr2	= ecx
  2539 = 0082			ptr3	= eax
  2540
  2541 = 0086			src	= ptr1
  2542 = 008A			dst	= ptr2
  2543 = 0082			cnt	= ptr3
  2544
  2545 1FAE A5 8B C5 87 D0 04 + 	cpw ptr2 ptr1
  2546 1FB8 B0 03			scs
  2547 1FBA 4C 83 1F			jmp @moveu
  2548
  2549 1FBD 8E 01 20			stx @sp
  2550
  2551 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2552
  2553 1FC0 A5 87			lda     ptr1+1
  2554 1FC2 18 65 83			add     ptr3+1
  2555 1FC5 85 87			sta     ptr1+1
  2556
  2557 1FC7 A5 8B			lda     ptr2+1
  2558 1FC9 18 65 83			add     ptr3+1
  2559 1FCC 85 8B			sta     ptr2+1
  2560
  2561 				; handle fractions of a page size first
  2562
  2563 1FCE A4 82			ldy     ptr3		; count, low byte
  2564 1FD0 D0 06			bne     @entry		; something to copy?
  2565 1FD2 F0 0B			beq     PageSizeCopy	; here like bra...
  2566
  2567 1FD4			@copyByte:
  2568 1FD4 B1 86			lda     (ptr1),y
  2569 1FD6 91 8A			sta     (ptr2),y
  2570 1FD8			@entry:
  2571 1FD8 88				dey
  2572 1FD9 D0 F9			bne     @copyByte
  2573 1FDB B1 86			lda     (ptr1),y	; copy remaining byte
  2574 1FDD 91 8A			sta     (ptr2),y
  2575
  2576 1FDF			PageSizeCopy:			; assert Y = 0
  2577 1FDF A6 83			ldx     ptr3+1		; number of pages
  2578 1FE1 F0 1D			beq     done		; none? -> done
  2579
  2580 1FE3			@initBase:
  2581 1FE3 C6 87			dec     ptr1+1		; adjust base...
  2582 1FE5 C6 8B			dec     ptr2+1
  2583 1FE7 88				dey			; in entry case: 0 -> FF
  2584 1FE8 B1 86			lda     (ptr1),y	; need to copy this 'intro byte'
  2585 1FEA 91 8A			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2586 1FEC 88				dey			; FF ->FE
  2587 1FED			@copyBytes:
  2588 					.rept 2		; Unroll this a bit to make it faster...
  2589 					LDA     (PTR1),Y
  2590 					STA     (PTR2),Y
  2591 					DEY
  2592 					.ENDR
  2592 					.endr
Source: REPT
  2589 1FED B1 86			LDA     (PTR1),Y
  2589 1FEF 91 8A			STA     (PTR2),Y
  2589 1FF1 88				DEY
  2589 1FF2 B1 86			LDA     (PTR1),Y
  2589 1FF4 91 8A			STA     (PTR2),Y
  2589 1FF6 88				DEY
Source: cpu6502.asm
  2593 1FF7			@copyEntry:			; in entry case: 0 -> FF
  2594 1FF7 D0 F4			bne     @copyBytes
  2595 1FF9 B1 86			lda     (ptr1),y	; Y = 0, copy last byte
  2596 1FFB 91 8A			sta     (ptr2),y
  2597 1FFD CA				dex			; one page to copy less
  2598 1FFE D0 E3			bne     @initBase	; still a page to copy?
  2599
  2600 2000 A2 00		done	ldx #0
  2601 = 2001			@sp	equ *-1
  2602 2002 60				rts
  2603 				.endp
  2604
  2605
  2606 				; Ullrich von Bassewitz, 29.05.1998
  2607 				; Performance increase (about 20%) by
  2608 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2609
  2610 2003			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2611
  2612 = 0086			ptr1 = edx
  2613 = 008A			ptr3 = ecx
  2614 = 0082			ptr2 = eax
  2615
  2616 2003 8A 48			txa:pha
  2617
  2618 2005 A6 82			ldx ptr2
  2619
  2620 2007 A0 00			ldy #0
  2621
  2622 2009 46 8B		        lsr	ptr3+1          ; divide number of
  2623 200B 66 8A		        ror	ptr3            ; bytes by two to increase
  2624 200D 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2625 200F			oddCount:
  2626 								; y is still 0 here
  2627 200F 8A			        txa			; restore fill value
  2628 2010 91 86		        sta	(ptr1),y	; save value and increase
  2629 2012 E6 86		        inc	ptr1		; dest. pointer
  2630 2014 D0 02		        bne	evenCount
  2631 2016 E6 87		        inc	ptr1+1
  2632 2018			evenCount:
  2633 2018 A5 86			lda	ptr1		; build second pointer section
  2634 201A 18				clc
  2635 201B 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2636 201D 85 82			sta     ptr2
  2637 201F A5 87			lda     ptr1+1
  2638 2021 65 8B			adc     ptr3+1
  2639 2023 85 83			sta     ptr2+1
  2640
  2641 2025 8A			        txa			; restore fill value
  2642 2026 A6 8B		        ldx	ptr3+1		; Get high byte of n
  2643 2028 F0 13		        beq	L2		; Jump if zero
  2644
  2645 				; Set 256/512 byte blocks
  2646 								; y is still 0 here
  2647 				L1:	.rept 2		; Unroll this a bit to make it faster
  2648 					STA	(PTR1),Y	
  2649 					STA	(PTR2),Y	
  2650 					INY
  2651 					.ENDR
  2651 					.endr
Source: REPT
  2648 202A 91 86			STA	(PTR1),Y	
  2648 202C 91 82			STA	(PTR2),Y	
  2648 202E C8				INY
  2648 202F 91 86			STA	(PTR1),Y	
  2648 2031 91 82			STA	(PTR2),Y	
  2648 2033 C8				INY
Source: cpu6502.asm
  2652 2034 D0 F4		        bne	L1
  2653 2036 E6 87		        inc	ptr1+1
  2654 2038 E6 83		        inc	ptr2+1
  2655 203A CA			        dex                     ; Next 256 byte block
  2656 203B D0 ED		        bne	L1              ; Repeat if any
  2657
  2658 				; Set the remaining bytes if any
  2659
  2660 203D A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2661 203F F0 07			beq	leave           ; something to set? No -> leave
  2662
  2663 2041 88			L3:	dey
  2664 2042 91 86			sta	(ptr1),y	; set bytes in low
  2665 2044 91 82			sta	(ptr2),y	; and high section
  2666 2046 D0 F9			bne     L3		; flags still up to date from dey!
  2667
  2668 2048 68 AA		leave	pla:tax
  2669 204A 60				rts			; return
  2670 				.endp
  2671
  2672
  2673 				/*
  2674 				 add strings
  2675 				 result -> @buf
  2676 				*/
  2676
  2677 204B			.proc	@addString(.word ya) .reg
  2678
  2679 					sta ztmp
  2680 					sty ztmp+1
  2681
  2682 					stx @sp
  2683
  2684 					ldx @buf
  2685 					inx
  2686 					beq stop
  2687
  2688 					ldy #0
  2689 					lda (ztmp),y
  2690 					sta ile
  2691 					beq stop
  2692
  2693 					iny
  2694
  2695 204B			load	lda (ztmp),y
  2696 					sta @buf,x
  2697
  2698 					iny
  2699 					inx
  2700 					beq stop
  2701 					dec ile
  2702 					bne load
  2703
  2704 204B			stop	dex
  2705 					stx @buf
  2706
  2707 					ldx #0
  2708 204B			@sp	equ *-1
  2709 					rts
  2710
  2711 204B			ile	brk
  2712 				.endp
  2713
  2714
  2715 				/* ----------------------------------------------------------------------- */
  2716
  2717
  2718 204B			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2719
  2720 					jsr swap
  2721
  2722 					adw spoint ztmp+2
  2723
  2724 					rts
  2725
  2726 204B			swap	txa:pha
  2727
  2728 					mwa spoint bp2
  2729
  2730 					ldx #0
  2731 					ldy #0
  2732
  2733 204B			loop	cpy ztmp+2
  2734 					bne @+
  2735 					cpx ztmp+3
  2736 					beq stop
  2737
  2738 204B			@	lda (bp2),y
  2739 					pha
  2740
  2741 					lda (ztmp),y
  2742 					sta (bp2),y
  2743
  2744 					pla
  2745 					sta (ztmp),y
  2746
  2747 					iny
  2748 					bne loop
  2749
  2750 					inc ztmp+1
  2751 					inc bp2+1
  2752 					inx
  2753
  2754 					jmp loop
  2755
  2756 204B			stop	pla:tax
  2757
  2758 					rts
  2759
  2760 204B			spoint	dta a(PROGRAMSTACK)
  2761 				.endp
  2762
  2763
  2764 204B			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2765
  2766 					sbw @AllocMem.spoint ztmp+2
  2767
  2768 					jmp @AllocMem.swap
  2769 				.endp
  2770
  2771
  2772 				/* ----------------------------------------------------------------------- */
  2773
  2774
  2775 204B			.proc	@vbxe_detect
  2776
  2777 					ldy #.sizeof(detect)-1
  2778 					mva:rpl copy,y detect,y-
  2779
  2780 					jmp detect
  2781
  2782 204B			copy
  2783 0400				.local	detect,@buf
  2784 				;
  2785 				; 2009 by KMK/DLT
  2786 				;
  2787 					lda #0
  2788 					sta fxptr
  2789
  2790 				        lda #$d6
  2791 				        sta fxptr+1
  2792 				        ldy #FX_MEMB
  2793 				        jsr ?clr
  2794
  2795 				        jsr ?try
  2796 				        bcc ok
  2797
  2798 				        inc fxptr+1
  2799
  2800 					jsr ?try
  2801 					bcc ok
  2802
  2803 					lda #0
  2804 					sta fxptr+1
  2805 					rts
  2806
  2807 0400			?try    ldx $4000
  2808 				        jsr ?chk
  2809 				        bcc ?ret
  2810 				        inx
  2811 				        stx $4000
  2812 				        jsr ?chk
  2813 				        dec $4000
  2814 0400			?ret    rts
  2815
  2816 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2817 					lda	(fxptr),y
  2818 					rts
  2819
  2820 0400			?chk    lda #$80
  2821 				        jsr _vbxe_write
  2822 				        cpx $4000
  2823 				        bne ?fnd
  2824 				        sec
  2825 0400			        .byte $24
  2826 0400			?fnd    clc
  2827 0400			?clr    lda #$00
  2828 0400			_vbxe_write
  2829 				        sta (fxptr),y
  2830 				        rts
  2831
  2832 				/*
  2833 					lda	#0
  2834 					ldx	#0xd6
  2835 					sta	0xd640			; make sure it isn't coincidence
  2836 					lda	0xd640
  2837 					cmp	#0x10			; do we have major version here?
  2838 					beq	VBXE_Detected		; if so, then VBXE is detected
  2839 					lda	#0
  2840 					inx
  2841 					sta	0xd740			; no such luck, try other location
  2842 					lda	0xd740
  2843 					cmp	#0x10
  2844 					beq	VBXE_Detected
  2845 					ldx 	#0  			; not here, so not present or FX core version too low
  2846 					stx	fxptr+1
  2847 					stx	fxptr
  2848
  2849 					sec
  2850 					rts
  2851
  2852 				VBXE_Detected
  2853 					stx	fxptr+1
  2854 					lda	#0
  2855 					sta	fxptr
  2856
  2857 					ldy	#VBXE_MINOR		; get core minor version
  2858 					lda	(fxptr),y
  2859
  2860 					clc
  2861 					rts	 			; x - page of vbxe
  2862 				*/
  2862
  2863
  2864 					.endl
  2865
  2866 				.endp
  2867
  2868
  2869 204B			.proc	@setxdl(.byte a) .reg
  2870
  2871 					asl @
  2872 					sta idx
  2873
  2874 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2875
  2876 					ldy #0
  2877 204B			idx	equ *-1
  2878
  2879 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2880 					and msk,y
  2881 					ora val,y
  2882 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2883
  2884 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2885 					and msk+1,y
  2886 					ora val+1,y
  2887 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2888
  2889 					fxs FX_MEMS #0
  2890 					rts
  2891
  2892 204B			msk	.array [6] .word
  2893 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2894 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2895 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2896 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2897 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2898 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2899 					.enda
  2900
  2901 204B			val	.array [6] .word
  2902 					[e@xdl.mapon]  = XDLC_MAPON
  2903 					[e@xdl.mapoff] = XDLC_MAPOFF
  2904 					[e@xdl.ovron]  = XDLC_GMON
  2905 					[e@xdl.ovroff] = XDLC_OVOFF
  2906 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2907 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2908 					.enda
  2909
  2910 				.endp
  2911
  2912
  2913 204B			.proc	@vbxe_init
  2914
  2915 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2916 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2917
  2918 					ldx #.sizeof(s@xdl)-1
  2919 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2920
  2921 					jsr cmapini		; init color map
  2922
  2923 					fxsa FX_P1		; A = 0
  2924 					fxsa FX_P2
  2925 					fxsa FX_P3
  2926
  2927 					fxsa FX_IRQ_CONTROL
  2928 					fxsa FX_BLITTER_START
  2929
  2930 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2931 					fxsa FX_XDL_ADR1
  2932 					fxsa FX_XDL_ADR2
  2933
  2934 					sta colpf0s
  2935
  2936 					fxs FX_P0 #$ff
  2937
  2938 					mwa #@vbxe_cmap @putchar.vbxe+1
  2939 					mva #{jsr*} @putchar.vbxe
  2940
  2941 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2942
  2943 					rts
  2944
  2945 204B			cmapini	lda colpf1s
  2946 					and #$0f
  2947 					sta colpf1s
  2948
  2949 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2950 					sta ztmp
  2951
  2952 					mva #4 ztmp+1
  2953
  2954 204B			loop	fxs FX_MEMS ztmp
  2955
  2956 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2957 					sta bp+1
  2958
  2959 					ldx #16
  2960 					ldy #0
  2961
  2962 204B			lop	mva #$00	(bp),y+
  2963 					mva colpf1s	(bp),y+
  2964 					mva colpf2s	(bp),y+
  2965 					mva #%00010000	(bp),y+		; overlay palette #1
  2966 					bne lop
  2967
  2968 					inc bp+1
  2969 					dex
  2970 					bne lop
  2971
  2972 					inc ztmp
  2973
  2974 					dec ztmp+1
  2975 					bne loop
  2976
  2977 					fxs FX_MEMS #$00		; disable VBXE BANK
  2978 					rts
  2979
  2980 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2981 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2982 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2983 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2984 					0, 0, 7, 7, %00010001, $ff)
  2984 204B			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2985 				.endp
  2986
  2987
  2988 204B			.proc	@vbxe_cmap
  2989
  2990 					pha
  2991
  2992 					cmp #eol
  2993 					beq stop
  2994
  2995 					cmp #$7d		; clrscr
  2996 					bne skp
  2997
  2998 					jsr @vbxe_init.cmapini
  2999 					jmp stop
  3000
  3001 204B			skp	lda rowcrs
  3002 					pha
  3003 204B				:4 lsr @
  3004 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  3005 					fxsa FX_MEMS
  3006
  3007 					pla
  3008 					and #$0f
  3009 					add >MAIN.SYSTEM.VBXE_WINDOW
  3010 					sta bp+1
  3011
  3012 					lda colcrs
  3013 					asl @
  3014 					asl @
  3015 					tay
  3016 					mva colpf0s (bp),y
  3017 					iny
  3018 					mva colpf1s (bp),y
  3019 					iny
  3020 					mva colpf2s (bp),y
  3021
  3022 					fxs FX_MEMS #$00
  3023
  3024 204B			stop	pla
  3025
  3026 					rts
  3027 				.endp
  3028
  3029
  3030 				/* ----------------------------------------------------------------------- */
  3031
  3032
  3033 				/*
  3034 				.proc	@cmdline (.byte a) .reg
  3035
  3036 					stx @sp
  3037
  3038 					sta idpar
  3039
  3040 					lda #0
  3041 					sta parno
  3042
  3043 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3044 					lsr
  3045 					bcc _no_command_line
  3046
  3047 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3048 					cmp #$c0
  3049 					bcs _no_command_line
  3050
  3051 					ldy #$03
  3052 					lda (dosvec),y
  3053 					cmp #{jmp}
  3054 					bne _no_command_line
  3055
  3056 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3057 					lda (dosvec),y
  3058 					sta lbuf
  3059 					iny
  3060 					lda (dosvec),y
  3061 					sta hbuf
  3062
  3063 					adw dosvec #3 zcr
  3064
  3065 				loop	lda #0
  3066 					sta @buf
  3067
  3068 					jsr $ffff
  3069 				zcr	equ *-2
  3070 					beq stop
  3071
  3072 					lda idpar
  3073 					bne skp
  3074
  3075 					ldy #33			; ParamStr(0)
  3076 				_par0	lda (dosvec),y
  3077 					sta @buf-33+1,y
  3078 					iny
  3079 					cpy #36
  3080 					bne _par0
  3081
  3082 					lda #3
  3083 					sta @buf
  3084 					bne stop
  3085
  3086 				skp	ldy #36
  3087 				_cp	lda (dosvec),y
  3088 					sta @buf-36+1,y
  3089 					iny
  3090 					cmp #$9b
  3091 					bne _cp
  3092
  3093 					tya
  3094 					sub #37
  3095 					sta @buf
  3096
  3097 					inc parno
  3098 					lda #0
  3099 				parno	equ *-1
  3100 					cmp #0
  3101 				idpar	equ *-1
  3102
  3103 					bne loop
  3104
  3105 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3106 					lda #0
  3107 				lbuf	equ *-1
  3108 					sta (dosvec),y
  3109 					iny
  3110 					lda #0
  3111 				hbuf	equ *-1
  3112 					sta (dosvec),y
  3113
  3114 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3115
  3116 					lda parno
  3117
  3118 					ldx #0
  3119 				@sp	equ *-1
  3120 					rts
  3121 				.endp
  3122 				*/
  3122
  3123
  3124
  3125 204B			.proc	@CmdLine (.byte a) .reg
  3126
  3127 					stx @sp
  3128
  3129 					sta idpar
  3130
  3131 					lda #0
  3132 					sta parno
  3133 					sta loop+1
  3134
  3135 					lda	#{jsr*}
  3136 					sta	res
  3137
  3138 				; Get filename from SpartaDOS...
  3139 204B			get_param
  3140 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3141 					lsr
  3142 					bcc no_sparta
  3143
  3144 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3145 					cmp #$c0
  3146 					bcs no_sparta
  3147
  3148 					ldy #$03
  3149 					lda (dosvec),y
  3150 					cmp #{jmp}
  3151 					bne no_sparta
  3152
  3153 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3154 					lda (dosvec),y
  3155 					sta lbuf
  3156 					iny
  3157 					lda (dosvec),y
  3158 					sta hbuf
  3159
  3160 					adw dosvec #33 tmp
  3161
  3162 					ldy #0
  3163 204B			fnm	lda (tmp),y
  3164 					iny
  3165 					cmp #$9b
  3166 					bne fnm
  3167
  3168 					tya			; remove .COM
  3169 					sub #5
  3170 					tay
  3171 					lda #0
  3172 					sta (tmp),y
  3173 					tay
  3174
  3175 					lda	#3
  3176 					sta	loop+1
  3177 					add	dosvec
  3178 					sta	get_adr
  3179 					lda	#0
  3180 					adc	dosvec+1
  3181 					sta	get_adr+1
  3182
  3183 					jmp	_ok
  3184
  3185 204B			no_sparta
  3186 					mwa #next get_adr
  3187
  3188 					lda	#{bit*}
  3189 					sta	res
  3190
  3191 				; ... or channel #0
  3192 					lda	MAIN.IOCB@COPY+2	; command
  3193 					cmp	#5			; read line
  3194 					bne	_no_command_line
  3195 					lda	MAIN.IOCB@COPY+3	; status
  3196 					bmi	_no_command_line
  3197 				; don't assume the line is EOL-terminated
  3198 				; DOS II+/D overwrites the EOL with ".COM"
  3199 				; that's why we rely on the length
  3200 					lda	MAIN.IOCB@COPY+9	; length hi
  3201 					bne	_no_command_line
  3202 					ldx	MAIN.IOCB@COPY+8	; length lo
  3203 					beq	_no_command_line
  3204 					inx:inx
  3205 					stx	arg_len
  3206 				; give access to three bytes before the input buffer
  3207 				; in DOS II+/D the device prompt ("D1:") is there
  3208 					lda	MAIN.IOCB@COPY+4
  3209 					sub	#3
  3210 					sta	tmp
  3211 					lda	MAIN.IOCB@COPY+5
  3212 					sbc	#0
  3213 					sta	tmp+1
  3214
  3215 					lda	#0
  3216 					ldy	#0
  3217 204B			arg_len	equ *-1
  3218 					sta	(tmp),y
  3219
  3220
  3221 204B			loop	ldy	#0
  3222
  3223 204B			_ok	ldx	#0
  3224
  3225 204B			lprea	lda	(tmp),y
  3226 					sta	@buf+1,x
  3227
  3228 					beq	stop
  3229
  3230 					cmp	#$9b
  3231 					beq	stop
  3232 					cmp	#' '
  3233 					beq	stop
  3234
  3235 					iny
  3236 					inx
  3237 					cpx #32
  3238 					bne lprea
  3239
  3240 204B			stop	lda #0
  3241 204B			parno	equ *-1
  3242 					cmp #0
  3243 204B			idpar	equ *-1
  3244 					beq found
  3245
  3246 					jsr $ffff		; sty loop+1
  3247 204B			get_adr	equ *-2
  3248 					beq found
  3249
  3250 					inc parno
  3251 					bne loop
  3252
  3253 204B			found	lda #0	;+$9b
  3254 					sta @buf+1,x
  3255 					stx @buf
  3256
  3257 204B			res	jsr sdxres
  3258
  3259 204B			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3260
  3261 					lda parno
  3262
  3263 					ldx #0
  3264 204B			@sp	equ *-1
  3265 					rts
  3266
  3267
  3268 204B			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3269 					lda #0
  3270 204B			lbuf	equ *-1
  3271 					sta (dosvec),y
  3272 					iny
  3273 					lda #0
  3274 204B			hbuf	equ *-1
  3275 					sta (dosvec),y
  3276 					rts
  3277
  3278
  3279 204B			_next	iny
  3280 204B			next	lda (tmp),y
  3281 					beq _eol
  3282 					cmp #' '
  3283 					beq _next
  3284
  3285 					cmp #$9b
  3286 					beq _eol
  3287
  3288 					sty loop+1
  3289 					rts
  3290
  3291 204B			_eol	lda #0
  3292 					rts
  3293
  3294 				.endp
  3295
  3296
  3297 				/* ----------------------------------------------------------------------- */
  3298
  3299 				/*
  3300 				.proc	@rstsnd
  3301 					lda #0
  3302 					sta $d208
  3303 					sta $d218
  3304
  3305 					ldy #3
  3306 					sty $d20f
  3307 					sty $d21f
  3308 					rts
  3309 				.endp
  3310 				*/
  3310
  3311
  3312 				;	ert (*>$3fff) .and (*<$8000)
  3313
  3314
  3315 				/* ----------------------------------------------------------------------- */
  3316
  3317
  3318 204B			.proc	@xmsBank
  3319
  3320 = 0082			ptr3 = eax			; position	(4)
  3321
  3322 					mva ptr3+3 ztmp+1	; position shr 14
  3323 					mva ptr3+2 ztmp
  3324 					lda ptr3+1
  3325
  3326 					.rept 6
  3327 					LSR ZTMP+1
  3328 					ROR ZTMP
  3329 					ROR @
  3330 					.ENDR
  3330 					.endr
Source: REPT
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
Source: cpu6502.asm
  3331
  3332 					tax			; index to bank
  3333
  3334 					lda portb
  3335 					and #1
  3336 					ora main.misc.adr.banks,x
  3337 					sta portb
  3338
  3339 					lda ptr3 		; offset
  3340 					sta ztmp
  3341 					lda ptr3+1
  3342 					and #$3f
  3343 					ora #$40
  3344 					sta ztmp+1
  3345
  3346 					rts
  3347 				.endp
  3348
  3349
  3350 204B			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3351
  3352 = 0086			ptr1 = dx	; buffer	(2)
  3353
  3354 = 008A			ptr2 = cx	; count		(2)
  3355 = 008C			pos = cx+2	; position	(2) pointer
  3356
  3357 = 0082			ptr3 = eax	; position	(4)
  3358
  3359 					txa:pha
  3360
  3361 					ldy #0
  3362 					lda (pos),y
  3363 					sta ptr3
  3364 					iny
  3365 					lda (pos),y
  3366 					sta ptr3+1
  3367 					iny
  3368 					lda (pos),y
  3369 					sta ptr3+2
  3370 					iny
  3371 					lda (pos),y
  3372 					sta ptr3+3
  3373
  3374 					lda ptr2+1
  3375 					beq lp2
  3376
  3377 204B			lp1	jsr @xmsBank
  3378
  3379 					lda ztmp+1
  3380 					cmp #$7f
  3381 					bne skp
  3382 					lda ztmp
  3383 					beq skp
  3384
  3385 					lda #0
  3386 					jsr nextBank
  3387 					jmp skp2
  3388
  3389 204B			skp	ldy #0
  3390 					mva:rne (ztmp),y @buf,y+
  3391
  3392 204B			skp2	lda portb
  3393 					and #1
  3394 					ora #$fe
  3395 					sta portb
  3396
  3397 					ldy #0
  3398 					mva:rne @buf,y (dx),y+
  3399
  3400 					inc dx+1	// inc(dx, $100)
  3401
  3402 					inl ptr3+1	// inc(position, $100)
  3403
  3404 					dec ptr2+1
  3405 					bne lp1
  3406
  3407 204B			lp2	jsr @xmsBank
  3408
  3409 					lda ztmp+1		; zakonczenie kopiowania
  3410 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3411 					bne skp_
  3412
  3413 					lda ztmp
  3414 					add ptr2
  3415 					bcc skp_
  3416
  3417 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3418 					jsr nextBank
  3419 					jmp skp3
  3420
  3421 204B			skp_	ldy #0
  3422 204B			mv	lda (ztmp),y
  3423 					sta @buf,y
  3424 					iny
  3425 					cpy ptr2
  3426 					bne mv
  3427
  3428 204B			skp3	lda portb
  3429 					and #1
  3430 					ora #$fe
  3431 					sta portb
  3432
  3433 					ldy #0
  3434 204B			lp3	lda @buf,y
  3435 					sta (dx),y
  3436 					iny
  3437 					cpy ptr2
  3438 					bne lp3
  3439
  3440 					jmp @xmsUpdatePosition
  3441
  3442 204B			.local	nextBank
  3443
  3444 					sta max
  3445
  3446 					mwa ztmp src
  3447
  3448 					ldy #0
  3449 204B			mv0	lda $ffff,y
  3450 204B			src	equ *-2
  3451 					sta @buf,y
  3452 					iny
  3453 					inc ztmp
  3454 					bne mv0
  3455
  3456 					lda portb
  3457 					and #1
  3458 					ora main.misc.adr.banks+1,x
  3459 					sta portb
  3460
  3461 					ldx #0
  3462 204B			mv1	cpy #0
  3463 204B			max	equ *-1
  3464 					beq stp
  3465 					lda $4000,x
  3466 					sta @buf,y
  3467 					inx
  3468 					iny
  3469 					bne mv1
  3470 204B			stp	rts
  3471 				.endl
  3472
  3473 				.endp
  3474
  3475
  3476 204B			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3477
  3478 = 0086			ptr1 = dx	; buffer	(2)
  3479
  3480 = 008A			ptr2 = cx	; count		(2)
  3481 = 008C			pos = cx+2	; position	(2) pointer
  3482
  3483 = 0082			ptr3 = eax	; position	(4)
  3484
  3485 					txa:pha
  3486
  3487 					ldy #0			; przepisz POSITION spod wskaznika
  3488 					lda (pos),y
  3489 					sta ptr3
  3490 					iny
  3491 					lda (pos),y
  3492 					sta ptr3+1
  3493 					iny
  3494 					lda (pos),y
  3495 					sta ptr3+2
  3496 					iny
  3497 					lda (pos),y
  3498 					sta ptr3+3
  3499
  3500 204B			lp1	lda portb		; wylacz dodatkowe banki
  3501 					and #1
  3502 					ora #$fe
  3503 					sta portb
  3504
  3505 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3506 					mva:rne (dx),y @buf,y+
  3507
  3508 					jsr @xmsBank		; wlacz dodatkowy bank
  3509
  3510 					lda ptr2+1
  3511 					beq lp2
  3512
  3513 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3514 					cmp #$7f
  3515 					bne skp
  3516 					lda ztmp
  3517 					beq skp
  3518
  3519 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3520 					jsr nextBank
  3521 					jmp skp2
  3522
  3523 204B			skp	mva:rne @buf,y (ztmp),y+
  3524
  3525 204B			skp2	inc dx+1		// inc(dx, $100)
  3526
  3527 					inl ptr3+1		// inc(position, $100)
  3528
  3529 					dec ptr2+1
  3530 					bne lp1
  3531
  3532 204B			lp2	lda ztmp+1		; zakonczenie kopiowania
  3533 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3534 					bne skp_
  3535
  3536 					lda ztmp
  3537 					add ptr2
  3538 					bcc skp_
  3539
  3540 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3541 					jsr nextBank
  3542 					jmp quit
  3543
  3544 204B			skp_	ldy #0
  3545 204B			lp3	lda @buf,y
  3546 					sta (ztmp),y
  3547
  3548 					iny
  3549 					cpy ptr2
  3550 					bne lp3
  3551
  3552 204B			quit	lda portb
  3553 					and #1
  3554 					ora #$fe
  3555 					sta portb
  3556
  3557 					jmp @xmsUpdatePosition
  3558
  3559 204B			.local	nextBank
  3560
  3561 					sta max
  3562
  3563 					mwa ztmp dst
  3564
  3565 					ldy #0
  3566 204B			mv0	lda @buf,y
  3567 					sta $ffff,y
  3568 204B			dst	equ *-2
  3569 					iny
  3570 					inc ztmp
  3571 					bne mv0
  3572
  3573 					lda portb
  3574 					and #1
  3575 					ora main.misc.adr.banks+1,x
  3576 					sta portb
  3577
  3578 					ldx #0
  3579 204B			mv1	cpy #0
  3580 204B			max	equ *-1
  3581 					beq stp
  3582 					lda @buf,y
  3583 					sta $4000,x
  3584 					inx
  3585 					iny
  3586 					bne mv1
  3587 204B			stp	rts
  3588 				.endl
  3589
  3590 				.endp
  3591
  3592
  3593 204B			.proc	@xmsAddPosition
  3594
  3595 204B				.use @xmsReadBuf
  3596
  3597 					add ptr3
  3598 					sta ptr3
  3599 					lda #$00
  3600 					adc ptr3+1
  3601 					sta ptr3+1
  3602 					lda #$00
  3603 					adc ptr3+2
  3604 					sta ptr3+2
  3605 					lda #$00
  3606 					adc ptr3+3
  3607 					sta ptr3+3
  3608
  3609 					rts
  3610 				.endp
  3611
  3612
  3613 204B			.proc	@xmsUpdatePosition
  3614
  3615 204B				.use @xmsReadBuf
  3616
  3617 					tya
  3618 					jsr @xmsAddPosition
  3619
  3620 					ldy #0
  3621 					lda ptr3
  3622 					sta (pos),y
  3623 					iny
  3624 					lda ptr3+1
  3625 					sta (pos),y
  3626 					iny
  3627 					lda ptr3+2
  3628 					sta (pos),y
  3629 					iny
  3630 					lda ptr3+3
  3631 					sta (pos),y
  3632
  3633 					pla:tax
  3634 					rts
  3635 				.endp
  3636
  3637
  3638 				/* ----------------------------------------------------------------------- */
  3639
  3640
  3641 204B			.proc	@ClrScr
  3642
  3643 					ldx #$00
  3644 					lda #$0c
  3645 					jsr xcio
  3646
  3647 					mwa #ename ioadr,x
  3648
  3649 					mva #$0c ioaux1,x
  3650 					mva #$00 ioaux2,x
  3651
  3652 					lda #$03
  3653
  3654 204B			xcio	sta iocom,x
  3655 					jmp ciov
  3656
  3657 204B			ename	.byte 'E:',$9b
  3658
  3659 				.endp
  3660
  3661
  3662 				/* ----------------------------------------------------------------------- */
  3663
  3664
  3665 					opt l+
  3832
  3833 				; -----------------------------------------------------------
  3834
  3835 				.macro UNITINITIALIZATION
  3836 				
  3837 					.ifdef MAIN.SYSTEM.@UnitInit
  3838 					jsr MAIN.SYSTEM.@UnitInit
  3839 					eif
  3840 				
  3841 					.ifdef MAIN.ATARI.@UnitInit
  3842 					jsr MAIN.ATARI.@UnitInit
  3843 					eif
  3844 				
  3845 					.ifdef MAIN.B_UTILS.@UnitInit
  3846 					jsr MAIN.B_UTILS.@UnitInit
  3847 					eif
  3848 				
  3849 					.ifdef MAIN.B_SYSTEM.@UnitInit
  3850 					jsr MAIN.B_SYSTEM.@UnitInit
  3851 					eif
  3852 				
  3853 					.ifdef MAIN.DOS.@UnitInit
  3854 					jsr MAIN.DOS.@UnitInit
  3855 					eif
  3856 				
  3857 					.ifdef MAIN.STRUTILS.@UnitInit
  3858 					jsr MAIN.STRUTILS.@UnitInit
  3859 					eif
  3860 				
  3861 					.ifdef MAIN.SYSUTILS.@UnitInit
  3862 					jsr MAIN.SYSUTILS.@UnitInit
  3863 					eif
  3864 				
  3865 					.ifdef MAIN.B_CRT.@UnitInit
  3866 					jsr MAIN.B_CRT.@UnitInit
  3867 					eif
  3868 				
  3869 					.ifdef MAIN.RMT.@UnitInit
  3870 					jsr MAIN.RMT.@UnitInit
  3871 					eif
  3872 				.endm
  3873
  3874 					ift .SIZEOF(MAIN.SYSTEM) > 0
  3875 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  3875 				SYSTEM: $0EF4..$0F78
  3876 					eif
  3877
  3878 					ift .SIZEOF(MAIN.ATARI) > 0
  3879 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  3880 					eif
  3881
  3882 					ift .SIZEOF(MAIN.B_UTILS) > 0
  3883 					.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
  3884 					eif
  3885
  3886 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  3887 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  3887 				B_SYSTEM: $0F79..$108E
  3888 					eif
  3889
  3890 					ift .SIZEOF(MAIN.DOS) > 0
  3891 					.print 'DOS: ',MAIN.DOS,'..',MAIN.DOS+.SIZEOF(MAIN.DOS)-1
  3892 					eif
  3893
  3894 					ift .SIZEOF(MAIN.STRUTILS) > 0
  3895 					.print 'STRUTILS: ',MAIN.STRUTILS,'..',MAIN.STRUTILS+.SIZEOF(MAIN.STRUTILS)-1
  3896 					eif
  3897
  3898 					ift .SIZEOF(MAIN.SYSUTILS) > 0
  3899 					.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
  3900 					eif
  3901
  3902 					ift .SIZEOF(MAIN.B_CRT) > 0
  3903 					.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
  3903 				B_CRT: $108F..$1369
  3904 					eif
  3905
  3906 					ift .SIZEOF(MAIN.RMT) > 0
  3907 					.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
  3907 				RMT: $136A..$1429
  3908 					eif
  3909
  3910 					.print 'CODE: ',CODEORIGIN,'..',*-1
  3910 				CODE: $0C00..$204A
  3911
  3912 204B			DATAORIGIN
  3913 204B 28 00 18 00 2D 0C + .by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3914 2063 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3915 207B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3916 2093 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3917 20AB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3918 20C3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3919 20DB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3920 20F3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3921 210B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3922 2123 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3923 213B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3924 2153 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3925 216B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3926 2183 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3927 219B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3928 21B3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3929 21CB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3930 21E3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3931 21FB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3932 2213 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3933 222B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3934 2243 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3935 225B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3936 2273 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3937 228B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3938 22A3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3939 22BB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3940 22D3 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3941 22EB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3942 2303 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3943 231B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3944 2333 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3945 234B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3946 2363 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3947 237B 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $04
  3948 2393 0A 0E 00 74 36 FC + .by  $0A $0E $00 $74 $36 $FC $00 $84  $88 $0E $00 $24 $1A $0E $00 $10  $14 $1A $00 $00 $00 $00 $00 $00
  3949 23AB 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $0F $0C $1B $0C $43 $0C $68  $0C $8A $0C $B2 $0C $D5 $0C $E9
  3950 23C3 0C 02 0D 26 0D 48 + .by  $0C $02 $0D $26 $0D $48 $0D $6D  $0D $8C $0D $99 $0D $0C $0C $A2  $0D $AC $0D $B4 $0D $99 $0D $0C
  3951 23DB 0C B9 0D C0 0D	.by  $0C $B9 $0D $C0 $0D
  3952
  3953 = 0395			VARINITSIZE	= *-DATAORIGIN
  3954 = 03A3			VARDATASIZE	= 931
  3955
  3956 = 23EE			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  3957
  3958 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  3958 				DATA: $204B..$23EE
  3959
  3960 02E0-02E1> C8 0E			run START
  3961
  3962 				; -----------------------------------------------------------
  3963
  3964 				.macro	STATICDATA
  3965 				.by  $04 $54 $52 $55 $45 $00 $05 $46  $41 $4C $53 $45 $00 $00 $00 $0A  $39 $65 $61 $72 $00 $12 $14 $11
  3966 				.by  $19 $0C $00 $26 $35 $6E $69 $74  $65 $64 $00 $25 $61 $72 $74 $68  $00 $25 $6D $70 $69 $72 $65 $00
  3967 				.by  $69 $73 $00 $73 $74 $69 $6C $6C  $00 $66 $69 $67 $68 $74 $69 $6E  $67 $0E $00 $23 $21 $66 $74 $65
  3968 				.by  $72 $00 $18 $00 $79 $65 $61 $72  $73 $00 $69 $6E $00 $6D $69 $6C  $69 $74 $61 $72 $79 $0C $00 $79
  3969 				.by  $6F $75 $00 $68 $61 $76 $65 $00  $20 $66 $69 $6E $61 $6C $6C $79  $00 $66 $75 $6C $66 $69 $6C $6C
  3970 				.by  $65 $64 $00 $79 $6F $75 $72 $00  $63 $6F $6E $74 $72 $61 $63 $74  $0E $00 $26 $26 $6F $72 $00 $61
  3971 				.by  $00 $6C $6F $6E $67 $00 $74 $69  $6D $65 $00 $79 $6F $75 $00 $64  $72 $65 $61 $6D $65 $64 $00 $61
  3972 				.by  $62 $6F $75 $74 $00 $79 $6F $75  $72 $00 $21 $6F $77 $6E $00 $76  $65 $6E $74 $75 $72 $65 $73 $00
  3973 				.by  $61 $6E $64 $00 $74 $6F $00 $62  $65 $00 $61 $62 $6C $65 $00 $74  $6F $00 $64 $6F $00 $12 $77 $68
  3974 				.by  $61 $74 $65 $76 $65 $72 $00 $79  $6F $75 $00 $77 $61 $6E $74 $0E  $00 $17 $37 $69 $74 $68 $00 $72
  3975 				.by  $65 $63 $65 $69 $76 $65 $64 $00  $70 $61 $79 $00 $63 $68 $65 $63  $6B $00 $22 $79 $6F $75 $00 $77
  3976 				.by  $65 $72 $65 $00 $61 $62 $6C $65  $00 $74 $6F $00 $62 $75 $79 $00  $63 $68 $65 $61 $70 $65 $73 $74
  3977 				.by  $00 $73 $68 $69 $70 $00 $20 $61  $6E $64 $00 $73 $74 $69 $6C $6C  $00 $68 $61 $76 $65 $00 $73 $6F
  3978 				.by  $6D $65 $00 $63 $68 $61 $6E $67  $65 $00 $6C $65 $66 $74 $0E $00  $23 $29 $74 $00 $69 $73 $00 $75
  3979 				.by  $70 $00 $74 $6F $00 $79 $6F $75  $0C $00 $77 $68 $65 $72 $65 $00  $74 $6F $00 $67 $6F $00 $6E $6F
  3980 				.by  $77 $0E $0E $0E $00 $1D $80 $B0  $F2 $E5 $F3 $F3 $80 $F3 $F0 $E1  $E3 $E5 $80 $E2 $E1 $F2 $80 $F4
  3981 				.by  $EF $80 $E3 $EF $EE $F4 $E9 $EE  $F5 $E5 $80 $00 $0B $30 $72 $6F  $67 $72 $61 $6D $6D $69 $6E $67
  3982 				.by  $00 $07 $2D $21 $24 $32 $21 $26  $69 $00 $08 $27 $72 $61 $70 $68  $69 $63 $73 $00 $06 $22 $72 $6F
  3983 				.by  $6E $69 $75 $00 $03 $2B $61 $7A  $00 $05 $2D $75 $73 $69 $63 $00  $06 $23 $61 $72 $75 $73 $6F $00
  3984 				.by  $6C $6A $3B $FF $FF $6B $2B $2A  $6F $FF $70 $75 $9B $69 $2D $3D  $76 $FF $63 $FF $FF $62 $78 $7A
  3985 				.by  $34 $FF $33 $36 $1B $35 $32 $31  $2C $20 $2E $6E $FF $6D $2F $81  $72 $FF $65 $79 $7F $74 $77 $71
  3986 				.by  $39 $FF $30 $37 $7E $38 $3E $FF  $66 $68 $64 $FF $82 $67 $73 $61  $4C $4A $3A $FF $FF $4B $5C $5E
  3987 				.by  $4F $FF $50 $55 $FF $49 $5F $7C  $56 $FF $43 $FF $FF $42 $58 $5A  $24 $FF $23 $26 $FF $25 $22 $21
  3988 				.by  $5B $3B $5D $4E $FF $4D $3F $FF  $52 $FF $45 $59 $FF $54 $57 $51  $28 $FF $29 $27 $FF $40 $FF $FF
  3989 				.by  $46 $48 $44 $FF $FF $47 $53 $41  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3990 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3991 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3992 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3993 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3994 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3995 				.endm
  3996
  3997 					end
