mads 2.0.9
  1116 					opt l+
    81
    82 0C75				RCDATA '../assets/Nvdi8.fnt' CHARSET_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('../assets/Nvdi8.fnt')
     5 0C75				org RESORIGIN
     7 0C75 20 41 0C		mcpy	jsr sys.off
     9 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
     9 0C80 A9 00 85 8A A9 E4 +  MWA #MAIN.CHARSET_ADDRESS ECX
     9 0C88 A9 00 85 82 A9 04 +  MWA #LEN EAX
     9 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    11 0C93 4C 65 0C			jmp sys.on
    13 0C96 00 00 00 00 00 00 + data	ins '../assets/Nvdi8.fnt'
    15 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    83 1096				RCASM 'dlist_title.asm' DISPLAY_LIST_ADDRESS_TITLE 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 1096				org RESORIGIN
     4 = 00C7			len = .sizeof(_DISPLAY_LIST_ADDRESS_TITLE)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS_TITLE+len >= $bc20
    11 0C75-0D5C> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 20 +  MWA #MAIN.DISPLAY_LIST_ADDRESS_TITLE ECX
    13 0C88 A9 C7 85 82 A9 00 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
Source: dlist_title.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     2 = 2000			FREE_TOP = $2000;
     4 = 2000			DISPLAY_LIST_ADDRESS_TITLE = FREE_TOP;
     5 = 2400			PLAYER_ADDRESS = DISPLAY_LIST_ADDRESS_TITLE + $400;
     6 = 2C00			MODULE_ADDRESS = PLAYER_ADDRESS + $800;
     9 = 36AC			PIC1_ADDRESS = MODULE_ADDRESS + $AAC;
    10 = 54B0			PIC2_ADDRESS = PIC1_ADDRESS + 7684;
    11 = 72B4			PIC3_ADDRESS = PIC2_ADDRESS + 7684;
    15 = B010			GFX_ADDRESS = $B010;
    16 = E400			CHARSET_ADDRESS = $E400;
    37 2000			dl_start
    39 2000 CE 10 B0		    dta DL_DLI + DL_MODE_160x192G4 + DL_LMS, a(GFX_ADDRESS)       ; // gfx line + graphics memory start
    40 2003 0E 0E 0E 0E 0E 0E +     :101 dta DL_MODE_160x192G4                                    ; // x graphics line
    41 2068 4E 00 C0		    dta DL_MODE_160x192G4 + DL_LMS, a(GFX_ADDRESS + 4080)         ; // gfx line + graphics memory
    42 206B 0E 0E 0E 0E 0E 0E +     :89 dta DL_MODE_160x192G4                                     ; // x graphics line
    46 20C4 41 00 20		    dta DL_JVB, a(dl_start)                                       ; // jump to beginning
    24 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    84 0D5D				CMCPLAY '' PLAYER_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.CMCPLAY [Source: res6502.asm]
     2 0D5D				org RESORIGIN
     4 = 0756			len = .sizeof(_PLAYER_ADDRESS)
     6 				mcpy	ift main.PLAYER_ADDRESS+len >= $bc20
    11 0C75-13EB> 20 41 0C		jsr sys.off
    13 0C78 A9 96 85 86 A9 0C +  MWA #DATA EDX
    13 0C80 A9 00 85 8A A9 24 +  MWA #MAIN.PLAYER_ADDRESS ECX
    13 0C88 A9 56 85 82 A9 07 +  MWA #LEN EAX
    13 0C90 20 00 0C		 JSR RESOURCE.MEMCPY
    15 0C93 4C 65 0C			jmp sys.on
    16 0C96			data
    24 02E2-02E3> 75 0C			ini mcpy
Source: intro.a65
    85 13EC				CMC 'assets/echo.cmc' MODULE_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.CMC [Source: res6502.asm]
     2 = 0AAC			len = .filesize('assets/echo.cmc')
    17 13EC				org main.MODULE_ADDRESS
     2 2C00				.get 'assets/echo.cmc'					// wczytujemy plik do bufora MADS'a
     8 = 2C00			new_add	= MAIN.MODULE_ADDRESS					// nowy adres dla modulu CMC
    10 = 8400			old_add	= .get[2] + .get[3]<<8			// stary adres modulu CMC
    12 = 0AA6			length	= .get[4] + .get[5]<<8 - old_add + 1	// dlugosc pliku MPT bez naglowka DOS'u
    14  [0002] 00			.put[2] = .lo(new_add)			// poprawiamy naglowek DOS'a
    15  [0003] 2C			.put[3] = .hi(new_add)			// tak aby zawieral informacje o nowym
    17  [0004] A5			.put[4] = .lo(new_add + length - 1)	// adresie modulu CMC
    18  [0005] 36			.put[5] = .hi(new_add + length - 1)
    20 = 0006			ofs	equ 6
    25 = 8700				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2F00				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001A] 00			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005A] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8722				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2F22				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001B] 22			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005B] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8732				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2F32				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001C] 32			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005C] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 887C				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 307C				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001D] 7C			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005D] 30			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8AAB				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 32AB				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001E] AB			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005E] 32			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 874F				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2F4F				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [001F] 4F			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [005F] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8791				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2F91				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0020] 91			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0060] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 87DE				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 2FDE				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0021] DE			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0061] 2F			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8A94				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3294				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0022] 94			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0062] 32			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8BF6				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 33F6				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0023] F6			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0063] 33			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8C98				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3498				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0024] 98			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0064] 34			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 882F				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 302F				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0025] 2F			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0065] 30			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 88E2				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 30E2				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0026] E2			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0066] 30			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8948				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3148				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0027] 48			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0067] 31			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8990				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3190				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0028] 90			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0068] 31			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 89DC				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 31DC				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0029] DC			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0069] 31			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 89E0				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 31E0				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002A] E0			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006A] 31			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8A23				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3223				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002B] 23			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006B] 32			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8A43				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3243				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002C] 43			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006C] 32			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8AF8				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 32F8				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002D] F8			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006D] 32			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8B46				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3346				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002E] 46			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006E] 33			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8B64				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3364				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [002F] 64			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [006F] 33			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8BA9				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 33A9				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0030] A9			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0070] 33			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8C47				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3447				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0031] 47			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0071] 34			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8CEA				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 34EA				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0032] EA			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0072] 34			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8D8B				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 358B				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0033] 8B			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0073] 35			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8D3D				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 353D				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0034] 3D			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0074] 35			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8DD8				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 35D8				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0035] D8			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0075] 35			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8E1A				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 361A				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0036] 1A			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0076] 36			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8E94				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 3694				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0037] 94			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0077] 36			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8E7D				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 367D				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0038] 7D			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0078] 36			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8E6E				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 366E				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [0039] 6E			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [0079] 36			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = 8E8B				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = 368B				?HLP = ?TMP - OLD_ADD + NEW_ADD
    25  [003A] 8B			.PUT[OFS+$14+#] = .LO(?HLP)
    25  [007A] 36			.PUT[OFS+$54+#] = .HI(?HLP)
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
    25 = FFFF				?TMP = .GET[OFS+$14+#] + .GET[OFS+$54+#]<<8
Source: intro.a65
    86 36A6				RCDATA 'assets/pic1.dat' PIC1_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 1E04			len = .filesize('assets/pic1.dat')
    17 36A6				org main.PIC1_ADDRESS
    19 36AC-90B7> 12 44 41 50 + 	ins 'assets/pic1.dat'
Source: intro.a65
    87 54B0				RCDATA 'assets/pic2.dat' PIC2_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 1E04			len = .filesize('assets/pic2.dat')
    17 54B0				org main.PIC2_ADDRESS
    19 54B0 55 55 55 55 55 55 + 	ins 'assets/pic2.dat'
Source: intro.a65
    88 72B4				RCDATA 'assets/pic3.dat' PIC3_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 1E04			len = .filesize('assets/pic3.dat')
    17 72B4				org main.PIC3_ADDRESS
    19 72B4 00 00 00 00 00 00 + 	ins 'assets/pic3.dat'
Source: intro.a65
    89 				.endl
    90
    91 				; -----------------------------------------------------------
    92
    93 90B8				org CODEORIGIN
    94
    95 0C00				STATICDATA
Macro: STATICDATA [Source: intro.a65]
     1 0C00-1E75> 04 54 52 55 + .by  $04 $54 $52 $55 $45 $00 $05 $46  $41 $4C $53 $45 $00 $00 $00 $0A  $39 $65 $61 $72 $00 $12 $14 $11
     2 0C18 19 0C 00 14 35 6E + .by  $19 $0C $00 $14 $35 $6E $69 $74  $65 $64 $00 $25 $61 $72 $74 $68  $00 $25 $6D $70 $69 $72 $65 $00
     3 0C30 00 14 69 73 00 73 + .by  $00 $14 $69 $73 $00 $73 $74 $69  $6C $6C $00 $66 $69 $67 $68 $74  $69 $6E $67 $0E $00 $00 $00 $14
     4 0C48 21 66 74 65 72 00 + .by  $21 $66 $74 $65 $72 $00 $18 $00  $79 $65 $61 $72 $73 $00 $69 $6E  $00 $00 $00 $00 $00 $14 $6D $69
     5 0C60 6C 69 74 61 72 79 + .by  $6C $69 $74 $61 $72 $79 $0C $00  $79 $6F $75 $00 $68 $61 $76 $65  $00 $00 $00 $14 $66 $69 $6E $61
     6 0C78 6C 6C 79 00 66 75 + .by  $6C $6C $79 $00 $66 $75 $6C $66  $69 $6C $6C $65 $64 $00 $00 $00  $00 $14 $79 $6F $75 $72 $00 $63
     7 0C90 6F 6E 74 72 61 63 + .by  $6F $6E $74 $72 $61 $63 $74 $0E  $00 $00 $00 $00 $00 $00 $00 $14  $26 $6F $72 $00 $61 $00 $6C $6F
     8 0CA8 6E 67 00 74 69 6D + .by  $6E $67 $00 $74 $69 $6D $65 $00  $79 $6F $75 $00 $00 $14 $68 $61  $76 $65 $00 $64 $72 $65 $61 $6D
     9 0CC0 65 64 00 61 62 6F + .by  $65 $64 $00 $61 $62 $6F $75 $74  $00 $00 $00 $14 $6F $77 $6E $00  $76 $65 $6E $74 $75 $72 $65 $00
    10 0CD8 61 6E 64 00 74 6F + .by  $61 $6E $64 $00 $74 $6F $00 $00  $00 $14 $62 $65 $00 $61 $62 $6C  $65 $00 $74 $6F $00 $64 $6F $00
    11 0CF0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $14  $77 $68 $61 $74 $65 $76 $65 $72  $00 $79 $6F $75 $00 $77 $61 $6E
    12 0D08 74 0E 00 00 00 14 + .by  $74 $0E $00 $00 $00 $14 $37 $69  $74 $68 $00 $72 $65 $63 $65 $69  $76 $65 $64 $00 $70 $61 $79 $00
    13 0D20 00 00 00 14 63 68 + .by  $00 $00 $00 $14 $63 $68 $65 $63  $6B $00 $79 $6F $75 $00 $77 $65  $72 $65 $00 $61 $62 $6C $65 $00
    14 0D38 00 14 74 6F 00 62 + .by  $00 $14 $74 $6F $00 $62 $75 $79  $00 $63 $68 $65 $61 $70 $65 $73  $74 $00 $73 $68 $69 $70 $00 $14
    15 0D50 61 6E 64 00 73 74 + .by  $61 $6E $64 $00 $73 $74 $69 $6C  $6C $00 $68 $61 $76 $65 $00 $73  $6F $6D $65 $00 $00 $14 $63 $68
    16 0D68 61 6E 67 65 00 6C + .by  $61 $6E $67 $65 $00 $6C $65 $66  $74 $0E $00 $00 $00 $00 $00 $00  $00 $00 $00 $14 $29 $74 $00 $69
    17 0D80 73 00 75 70 00 74 + .by  $73 $00 $75 $70 $00 $74 $6F $00  $79 $6F $75 $0C $00 $00 $00 $00  $00 $14 $77 $68 $65 $72 $65 $00
    18 0D98 74 6F 00 67 6F 00 + .by  $74 $6F $00 $67 $6F $00 $6E $6F  $77 $0E $0E $0E $00 $00 $00 $6C  $6A $3B $FF $FF $6B $2B $2A $6F
    19 0DB0 FF 70 75 9B 69 2D + .by  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34  $FF $33 $36 $1B $35 $32 $31 $2C
    20 0DC8 20 2E 6E FF 6D 2F + .by  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39  $FF $30 $37 $7E $38 $3E $FF $66
    21 0DE0 68 64 FF 82 67 73 + .by  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F  $FF $50 $55 $FF $49 $5F $7C $56
    22 0DF8 FF 43 FF FF 42 58 + .by  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B  $3B $5D $4E $FF $4D $3F $FF $52
    23 0E10 FF 45 59 FF 54 57 + .by  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46  $48 $44 $FF $FF $47 $53 $41 $FF
    24 0E28 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    25 0E40 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    26 0E58 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    27 0E70 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    28 0E88 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    29 0EA0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF
Source: intro.a65
    96
    97 0EA7			START
    98 0EA7 BA				tsx
    99 0EA8 8E E5 1C			stx MAIN.@halt+1
   100
   101 					.ifdef fmulinit
   102 					fmulinit
   103 					eif
   104
   105 					ift DATAORIGIN+VARINITSIZE > $BFFF
   106 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   107 					els
   108 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   108 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   108 0EAB A9 76 85 86 A9 1E +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   108 0EB3 A9 1E 85 8A A9 01 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   108 0EBB A9 00 85 82		 MVA #0 @FILL.PTR2
   108 0EBF 20 BE 1D		 JSR @FILL
   109 					eif
   110
   111 0EC2 A2 0F			ldx #$0f
   112 0EC4 BD 40 03 9D E8 1C + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   113
   114 0ECD E8				inx		; X = 0 !!!
   115 0ECE 86 8E			stx bp		; lo BP = 0
   116
   117 0ED0				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: intro.a65]
Source: intro.a65
   118
   119 0ED0			.local	MAIN						; PROCEDURE
   120
   121 					ift l_01AE-*>3
   122 0ED0 4C 23 15			jmp l_01AE
   123 					eif
   124
   125 				; -----------------------------------------------------------
   126
   127 0ED3			.local	SYSTEM						; UNIT
   128
   129 0ED3			.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER
   130
   131 				; -----------------------------------------------------------
   132
   133 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   134 				; as Pointer
   135 0ED3 B5 98 85 86			mva :STACKORIGIN,x A
   136 0ED7 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   137 0EDB CA				dex						; sub bx, 1
   138
   139
   140 				; ---------------------  ASM Block 004  ---------------------
   141
   142 0EDC A0 00			ldy #0
   143 0EDE B1 86 8D 11 1E		mva (edx),y Result
   144
   145
   146 0EE3			@exit
   147
   148 				; -----------------------------------------------------------
   149
   150 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   151 				; as Pointer
   152
   153 0EE3 E8				inx						; add bx, 1
   154 0EE4 AD 11 1E 95 98		mva RESULT :STACKORIGIN,x
   155
   156 					.ifdef @new
   157 					@FreeMem #@VarData #@VarDataSize
   158 					eif
   159
   160 				; -----------------------------------------------------------
   161
   162 = 0086			A	= edx
   163 = 1E11			RESULT	= DATAORIGIN+$000B
   164
   165 = 1E11			@VarData	= RESULT
   166 = 0001			@VarDataSize	= 1
   167
   168 0EE9 60				rts						; ret
   169 				.endl
   170
   171 0EEA			.local	DPOKE						; PROCEDURE | ASSEMBLER | REGISTER
   172
   173 				; -----------------------------------------------------------
   174
   175 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   176 				; as Pointer
   177 0EEA B5 98 85 8A			mva :STACKORIGIN,x VALUE
   178 0EEE B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x VALUE+1
   179 0EF2 CA				dex						; sub bx, 1
   180
   181 				; -----------------------------------------------------------
   182
   183 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   184 				; as Pointer
   185 0EF3 B5 98 85 86			mva :STACKORIGIN,x A
   186 0EF7 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   187 0EFB CA				dex						; sub bx, 1
   188
   189
   190 				; ---------------------  ASM Block 022  ---------------------
   191
   192 0EFC A0 00			ldy #0
   193 0EFE A5 8A 91 86			mva value (edx),y
   194 0F02 C8				iny
   195 0F03 A5 8B 91 86			mva value+1 (edx),y
   196
   197
   198 				; -----------------------------------------------------------
   199
   200 = 0086			A	= edx
   201 = 008A			VALUE	= ecx
   202
   203 0F07			@exit
   204 					.ifdef @new
   205 					@FreeMem #@VarData #@VarDataSize
   206 					eif
   207 0F07 60				rts						; ret
   208 				.endl
   209
   210 0F08			.local	FILLBYTE_01D6					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   211
   212 				; -----------------------------------------------------------
   213
   214 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   215 				; as Pointer
   216 0F08 B5 98 85 82			mva :STACKORIGIN,x VALUE
   217 0F0C CA				dex						; sub bx, 1
   218
   219 				; -----------------------------------------------------------
   220
   221 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   222 				; as Pointer
   223 0F0D B5 98 85 8A			mva :STACKORIGIN,x COUNT
   224 0F11 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   225 0F15 CA				dex						; sub bx, 1
   226
   227 				; -----------------------------------------------------------
   228
   229 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   230 				; as Pointer
   231 0F16 B5 98 85 86			mva :STACKORIGIN,x A
   232 0F1A B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   233 0F1E CA				dex						; sub bx, 1
   234
   235
   236 				; ---------------------  ASM Block 029  ---------------------
   237
   238 0F1F 20 BE 1D			jsr @fill
   239
   240
   241 				; -----------------------------------------------------------
   242
   243 = 0086			A	= edx
   244 = 008A			COUNT	= ecx
   245 = 0082			VALUE	= eax
   246
   247 0F22			@exit
   248 					.ifdef @new
   249 					@FreeMem #@VarData #@VarDataSize
   250 					eif
   251 0F22 60				rts						; ret
   252 				.endl
   253
   254 0F23			.local	MOVE_01E0					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   255
   256 				; -----------------------------------------------------------
   257
   258 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   259 				; as Pointer
   260 0F23 B5 98 85 82			mva :STACKORIGIN,x COUNT
   261 0F27 B5 A8 85 83			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   262 0F2B CA				dex						; sub bx, 1
   263
   264 				; -----------------------------------------------------------
   265
   266 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   267 				; as Pointer
   268 0F2C B5 98 85 8A			mva :STACKORIGIN,x DEST
   269 0F30 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   270 0F34 CA				dex						; sub bx, 1
   271
   272 				; -----------------------------------------------------------
   273
   274 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   275 				; as Pointer
   276 0F35 B5 98 85 86			mva :STACKORIGIN,x SOURCE
   277 0F39 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   278 0F3D CA				dex						; sub bx, 1
   279
   280
   281 				; ---------------------  ASM Block 031  ---------------------
   282
   283 0F3E 20 69 1D			jsr @move
   284
   285
   286 				; -----------------------------------------------------------
   287
   288 = 0086			SOURCE	= edx
   289 = 008A			DEST	= ecx
   290 = 0082			COUNT	= eax
   291
   292 0F41			@exit
   293 					.ifdef @new
   294 					@FreeMem #@VarData #@VarDataSize
   295 					eif
   296 0F41 60				rts						; ret
   297 				.endl
   298
   299 				; -----------------------------------------------------------
   300
   301 = 0648			M_PI_2	= $0648
   302 = 0192			D_PI_2	= $0192
   303 = 0004			D_PI_180	= $0004
   304 = 0000			MGTIA	= $0000
   305 = 0080			MVBXE	= $0080
   306 = 0010			WINDOW	= $0010
   307 = 0020			NARROW	= $0020
   308 = 0000			VBXE_XDLADR	= $0000
   309 = 0100			VBXE_BCBADR	= $0100
   310 = 1000			VBXE_MAPADR	= $1000
   311 = 5000			VBXE_OVRADR	= $5000
   312 = B000			VBXE_WINDOW	= $B000
   313 = 0000			IDLI	= $0000
   314 = 0001			IVBL	= $0001
   315 = 00FE			CH_DELCHR	= $00FE
   316 = 009B			CH_ENTER	= $009B
   317 = 001B			CH_ESC	= $001B
   318 = 001C			CH_CURS_UP	= $001C
   319 = 001D			CH_CURS_DOWN	= $001D
   320 = 001E			CH_CURS_LEFT	= $001E
   321 = 001F			CH_CURS_RIGHT	= $001F
   322 = 007F			CH_TAB	= $007F
   323 = 009B			CH_EOL	= $009B
   324 = 007D			CH_CLR	= $007D
   325 = 00FD			CH_BELL	= $00FD
   326 = 007E			CH_DEL	= $007E
   327 = 009C			CH_DELLINE	= $009C
   328 = 009D			CH_INSLINE	= $009D
   329 = 0000			COLOR_BLACK	= $0000
   330 = 000E			COLOR_WHITE	= $000E
   331 = 0032			COLOR_RED	= $0032
   332 = 0096			COLOR_CYAN	= $0096
   333 = 0068			COLOR_VIOLET	= $0068
   334 = 00C4			COLOR_GREEN	= $00C4
   335 = 0074			COLOR_BLUE	= $0074
   336 = 00EE			COLOR_YELLOW	= $00EE
   337 = 004A			COLOR_ORANGE	= $004A
   338 = 00E4			COLOR_BROWN	= $00E4
   339 = 003C			COLOR_LIGHTRED	= $003C
   340 = 0004			COLOR_GRAY1	= $0004
   341 = 0006			COLOR_GRAY2	= $0006
   342 = 000A			COLOR_GRAY3	= $000A
   343 = 00CC			COLOR_LIGHTGREEN	= $00CC
   344 = 007C			COLOR_LIGHTBLUE	= $007C
   345 = 0004			FMOPENREAD	= $0004
   346 = 0008			FMOPENWRITE	= $0008
   347 = 0009			FMOPENAPPEND	= $0009
   348 = 000C			FMOPENREADWRITE	= $000C
   349 = 1E06			SCREENWIDTH	= DATAORIGIN+$0000
   350 = 1E08			SCREENHEIGHT	= DATAORIGIN+$0002
   351 = 1E0A			DATESEPARATOR	= DATAORIGIN+$0004
   352 = 1E0B			FILEMODE	= DATAORIGIN+$0005
   353 = 1E0C			SCREENMODE	= DATAORIGIN+$0006
   354 = 1E0D			IORESULT	= DATAORIGIN+$0007
   355 = 1E0E			EOLN	= DATAORIGIN+$0008
   356 = 1E0F			RNDSEED	= DATAORIGIN+$0009
   357
   358 				.endl							; UNIT SYSTEM
   359
   360 				; -----------------------------------------------------------
   361
   362 0F42			.local	ATARI						; UNIT
   363
   364 				; -----------------------------------------------------------
   365
   366 = 0012			RTCLOK	= $0012
   367 = 004D			ATRACT	= $004D
   368 = 0052			LMARGIN	= $0052
   369 = 0053			RMARGIN	= $0053
   370 = 0054			ROWCRS	= $0054
   371 = 0055			COLCRS	= $0055
   372 = 0057			DINDEX	= $0057
   373 = 0058			SAVMSC	= $0058
   374 = 0200			VDSLST	= $0200
   375 = 0230			SDLSTL	= $0230
   376 = 0290			TXTROW	= $0290
   377 = 0291			TXTCOL	= $0291
   378 = 0293			TINDEX	= $0293
   379 = 0294			TXTMSC	= $0294
   380 = 022F			SDMCTL	= $022F
   381 = 026F			GPRIOR	= $026F
   382 = 02F0			CRSINH	= $02F0
   383 = 02F3			CHACT	= $02F3
   384 = 02F4			CHBAS	= $02F4
   385 = 02FC			CH	= $02FC
   386 = 02C0			PCOLR0	= $02C0
   387 = 02C1			PCOLR1	= $02C1
   388 = 02C2			PCOLR2	= $02C2
   389 = 02C3			PCOLR3	= $02C3
   390 = 02C4			COLOR0	= $02C4
   391 = 02C5			COLOR1	= $02C5
   392 = 02C6			COLOR2	= $02C6
   393 = 02C7			COLOR3	= $02C7
   394 = 02C8			COLOR4	= $02C8
   395 = 02C8			COLBAKS	= $02C8
   396 = D000			HPOSP0	= $D000
   397 = D001			HPOSP1	= $D001
   398 = D002			HPOSP2	= $D002
   399 = D003			HPOSP3	= $D003
   400 = D004			HPOSM0	= $D004
   401 = D005			HPOSM1	= $D005
   402 = D006			HPOSM2	= $D006
   403 = D007			HPOSM3	= $D007
   404 = D008			SIZEP0	= $D008
   405 = D009			SIZEP1	= $D009
   406 = D00A			SIZEP2	= $D00A
   407 = D00B			SIZEP3	= $D00B
   408 = D00C			SIZEM	= $D00C
   409 = D00D			GRAFP0	= $D00D
   410 = D00E			GRAFP1	= $D00E
   411 = D00F			GRAFP2	= $D00F
   412 = D010			GRAFP3	= $D010
   413 = D011			GRAFM	= $D011
   414 = D004			P0PF	= $D004
   415 = D014			PAL	= $D014
   416 = D012			COLPM0	= $D012
   417 = D013			COLPM1	= $D013
   418 = D014			COLPM2	= $D014
   419 = D015			COLPM3	= $D015
   420 = D016			COLPF0	= $D016
   421 = D017			COLPF1	= $D017
   422 = D018			COLPF2	= $D018
   423 = D019			COLPF3	= $D019
   424 = D01A			COLBK	= $D01A
   425 = D01B			PRIOR	= $D01B
   426 = D01D			GRACTL	= $D01D
   427 = D01E			HITCLR	= $D01E
   428 = D200			AUDF1	= $D200
   429 = D201			AUDC1	= $D201
   430 = D202			AUDF2	= $D202
   431 = D203			AUDC2	= $D203
   432 = D204			AUDF3	= $D204
   433 = D205			AUDC3	= $D205
   434 = D206			AUDF4	= $D206
   435 = D207			AUDC4	= $D207
   436 = D208			AUDCTL	= $D208
   437 = D20F			SKSTAT	= $D20F
   438 = D301			PORTB	= $D301
   439 = D400			DMACTL	= $D400
   440 = D401			CHACTL	= $D401
   441 = D402			DLISTL	= $D402
   442 = D404			HSCROL	= $D404
   443 = D405			VSCROL	= $D405
   444 = D407			PMBASE	= $D407
   445 = D409			CHBASE	= $D409
   446 = D40A			WSYNC	= $D40A
   447 = D40B			VCOUNT	= $D40B
   448 = D40C			PENH	= $D40C
   449 = D40D			PENV	= $D40D
   450 = D40E			NMIEN	= $D40E
   451
   452 				.endl							; UNIT ATARI
   453
   454 				; -----------------------------------------------------------
   455
   456 0F42			.local	B_UTILS						; UNIT
   457
   458 				; -----------------------------------------------------------
   459
   460
   461 				.endl							; UNIT B_UTILS
   462
   463 				; -----------------------------------------------------------
   464
   465 0F42			.local	B_SYSTEM					; UNIT
   466
   467 0F42			.local	SYSTEMOFF_01FA					; PROCEDURE | ASSEMBLER | OVERLOAD
   468
   469 				; -----------------------------------------------------------
   470
   471 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   472 				; as Pointer
   473 0F42 B5 98 8D 13 1E		mva :STACKORIGIN,x PORT_B
   474 0F47 CA				dex						; sub bx, 1
   475
   476
   477 				; ---------------------  ASM Block 047  ---------------------
   478
   479
   480 						;lda:cmp:req 20 ;; removed due to problem with nmien = 0 already set
   481 0F48 78					sei
   482 0F49 A9 00 8D 0E D4			mva #0 NMIEN
   483
   484 0F4E AD 13 1E 8D 01 D3			mva port_b PORTB
   485 0F54 A9 7E 8D FA FF A9 + 		mwa #__nmi NMIVEC
   486
   487 0F5E A9 94				lda <__iret
   488 0F60 8D FE FF				sta IRQVEC
   489 0F63 8D 92 0F				sta __vblvec
   490 0F66 8D 84 0F				sta __dlivec
   491
   492 0F69 A9 0F				lda >__iret
   493 0F6B 8D FF FF				sta IRQVEC+1
   494 0F6E 8D 93 0F				sta __vblvec+1
   495 0F71 8D 85 0F				sta __dlivec+1
   496
   497 0F74 A9 40 8D 0E D4			mva #$40 NMIEN
   498 0F79 8D 12 1E				sta __nmien
   499 0F7C D0 17				bne __stop
   500 0F7E			__nmi
   501 0F7E 2C 0F D4				bit NMIST
   502 0F81 10 04				bpl __vbl
   503 0F83 4C 84 0F				jmp __dlivec
   504 = 0F84			.def :__dlivec = *-2
   505 0F86 40					rti
   506 0F87			__vbl
   507 0F87 E6 14				inc rtclok+2
   508 0F89 D0 06				bne __vblvec-1
   509 0F8B E6 13				inc rtclok+1
   510 0F8D D0 02				bne __vblvec-1
   511 0F8F E6 12				inc rtclok
   512 0F91 4C 92 0F				jmp __vblvec
   513 = 0F92			.def :__vblvec = *-2
   514 = 0F94			.def :__iret
   515 0F94 40			    	rti
   516 0F95			__stop
   517
   518
   519 				; -----------------------------------------------------------
   520
   521 = 1E13			PORT_B	= DATAORIGIN+$000D
   522
   523 = 1E13			@VarData	= PORT_B
   524 = 0001			@VarDataSize	= 1
   525
   526
   527 0F95			@exit
   528 					.ifdef @new
   529 					@FreeMem #@VarData #@VarDataSize
   530 					eif
   531 0F95 60				rts						; ret
   532 				.endl
   533
   534 0F96			.local	SYSTEMOFF_01FE					; PROCEDURE | OVERLOAD
   535
   536 					ift l_0201-*>3
   537 					jmp l_0201
   538 					eif
   539
   540 				; IfThenEpilog
   541 0F96			l_0201
   542
   543 				; optimize FAIL ('SYSTEMOFF_01FA', B_SYSTEM), line = 137
   544 0F96 E8				inx
   545 0F97 A9 FE 95 98			mva #$FE :STACKORIGIN,x
   546 0F9B 20 42 0F			jsr SYSTEMOFF_01FA
   547
   548 0F9E			@exit
   549 					.ifdef @new
   550 					@FreeMem #@VarData #@VarDataSize
   551 					eif
   552 0F9E 60				rts						; ret
   553 				.endl
   554
   555 0F9F			.local	ENABLEVBLI					; PROCEDURE | ASSEMBLER
   556
   557 				; -----------------------------------------------------------
   558
   559 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   560 				; as Pointer
   561 0F9F B5 98 8D 14 1E		mva :STACKORIGIN,x VBLPTR
   562 0FA4 B5 A8 8D 15 1E		mva :STACKORIGIN+STACKWIDTH,x VBLPTR+1
   563 0FA9 CA				dex						; sub bx, 1
   564
   565
   566 				; ---------------------  ASM Block 049  ---------------------
   567
   568
   569 0FAA A5 14 C5 14 F0 FC			lda:cmp:req 20
   570 0FB0 A9 00 8D 0E D4			mva #0 NMIEN
   571 0FB5 AD 14 1E 8D 92 0F + 		mwa vblptr __vblvec
   572 0FC1 AD 12 1E				lda __nmien
   573 0FC4 09 40				ora #$40
   574 0FC6 8D 0E D4				sta NMIEN
   575 0FC9 8D 12 1E				sta __nmien
   576
   577
   578 				; -----------------------------------------------------------
   579
   580 = 1E14			VBLPTR	= DATAORIGIN+$000E
   581
   582 = 1E14			@VarData	= VBLPTR
   583 = 0002			@VarDataSize	= 2
   584
   585
   586 0FCC			@exit
   587 					.ifdef @new
   588 					@FreeMem #@VarData #@VarDataSize
   589 					eif
   590 0FCC 60				rts						; ret
   591 				.endl
   592
   593 0FCD			.local	DISABLEVBLI					; PROCEDURE | ASSEMBLER
   594
   595
   596 				; ---------------------  ASM Block 050  ---------------------
   597
   598
   599 0FCD A5 14 C5 14 F0 FC			lda:cmp:req 20
   600 0FD3 A9 00 8D 0E D4			mva #0 NMIEN
   601 0FD8 A9 94 8D 92 0F A9 + 		mwa #__iret __vblvec
   602 0FE2 AD 12 1E				lda __nmien
   603 0FE5 09 40				ora #$40
   604 0FE7 8D 0E D4				sta NMIEN
   605 0FEA 8D 12 1E				sta __nmien
   606
   607
   608 0FED			@exit
   609 					.ifdef @new
   610 					@FreeMem #@VarData #@VarDataSize
   611 					eif
   612 0FED 60				rts						; ret
   613 				.endl
   614
   615 0FEE			.local	ENABLEDLI					; PROCEDURE | ASSEMBLER
   616
   617 				; -----------------------------------------------------------
   618
   619 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   620 				; as Pointer
   621 0FEE B5 98 8D 16 1E		mva :STACKORIGIN,x DLIPTR
   622 0FF3 B5 A8 8D 17 1E		mva :STACKORIGIN+STACKWIDTH,x DLIPTR+1
   623 0FF8 CA				dex						; sub bx, 1
   624
   625
   626 				; ---------------------  ASM Block 051  ---------------------
   627
   628
   629 0FF9 A5 14 C5 14 F0 FC			lda:cmp:req 20
   630 0FFF A9 00 8D 0E D4			mva #0 NMIEN
   631 1004 AD 16 1E 8D 84 0F + 		mwa dliptr __dlivec
   632 1010 A9 C0 8D 0E D4			mva #$c0 NMIEN
   633 1015 8D 12 1E				sta __nmien
   634
   635
   636 				; -----------------------------------------------------------
   637
   638 = 1E16			DLIPTR	= DATAORIGIN+$0010
   639
   640 = 1E16			@VarData	= DLIPTR
   641 = 0002			@VarDataSize	= 2
   642
   643
   644 1018			@exit
   645 					.ifdef @new
   646 					@FreeMem #@VarData #@VarDataSize
   647 					eif
   648 1018 60				rts						; ret
   649 				.endl
   650
   651 1019			.local	DISABLEDLI					; PROCEDURE | ASSEMBLER
   652
   653
   654 				; ---------------------  ASM Block 052  ---------------------
   655
   656
   657 1019 A5 14 C5 14 F0 FC			lda:cmp:req 20
   658 101F A9 40 8D 0E D4			mva #$40 NMIEN
   659 1024 8D 12 1E				sta __nmien
   660
   661
   662 1027			@exit
   663 					.ifdef @new
   664 					@FreeMem #@VarData #@VarDataSize
   665 					eif
   666 1027 60				rts						; ret
   667 				.endl
   668
   669 1028			.local	WAITFRAME					; PROCEDURE | ASSEMBLER
   670
   671
   672 				; ---------------------  ASM Block 053  ---------------------
   673
   674
   675 1028 A5 14 C5 14 F0 FC	    lda:cmp:req rtclok+2
   676
   677
   678 102E			@exit
   679 					.ifdef @new
   680 					@FreeMem #@VarData #@VarDataSize
   681 					eif
   682 102E 60				rts						; ret
   683 				.endl
   684
   685 102F			.local	WAITFRAMES					; PROCEDURE
   686
   687 				; -----------------------------------------------------------
   688
   689 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   690 				; as Pointer
   691 102F B5 98 8D 18 1E		mva :STACKORIGIN,x FRAMES
   692 1034 CA				dex						; sub bx, 1
   693
   694 					ift l_0215-*>3
   695 					jmp l_0215
   696 					eif
   697
   698 				; IfThenEpilog
   699 1035			l_0215
   700
   701 				; --- WhileProlog
   702 1035			l_0216
   703
   704 				; optimize OK (B_SYSTEM), line = 210
   705
   706 1035 AD 18 1E			lda FRAMES
   707 1038 C9 00			cmp #$00
   708 103A F0 02			seq
   709 103C B0 03			bcs @+
   710 103E 4C 4A 10			jmp l_0225
   711 1041			@
   712
   713 				; optimize FAIL ('WAITFRAME', B_SYSTEM), line = 211
   714 1041 20 28 10			jsr WAITFRAME
   715
   716 				; optimize FAIL (0, B_SYSTEM), line = 212
   717 1044 CE 18 1E			dec FRAMES
   718
   719 				; --- WhileDoEpilog
   720 1047			c_0216
   721
   722 				; WhileDoEpilog
   723 1047 4C 35 10			jmp l_0216
   724 104A			l_0225
   725 104A			b_0216
   726
   727 				; -----------------------------------------------------------
   728
   729 = 1E18			FRAMES	= DATAORIGIN+$0012
   730
   731 = 1E18			@VarData	= FRAMES
   732 = 0001			@VarDataSize	= 1
   733
   734
   735 104A			@exit
   736 					.ifdef @new
   737 					@FreeMem #@VarData #@VarDataSize
   738 					eif
   739 104A 60				rts						; ret
   740 				.endl
   741
   742 104B			.local	SETCHARSET					; PROCEDURE
   743
   744 				; -----------------------------------------------------------
   745
   746 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   747 				; as Pointer
   748 104B B5 98 8D 19 1E		mva :STACKORIGIN,x MSB
   749 1050 CA				dex						; sub bx, 1
   750
   751 					ift l_0232-*>3
   752 					jmp l_0232
   753 					eif
   754
   755 				; IfThenEpilog
   756 1051			l_0232
   757
   758 				; optimize OK (B_SYSTEM), line = 218
   759
   760 1051 AD 19 1E 8D 09 D4		mva MSB ATARI.CHBASE
   761
   762 				; -----------------------------------------------------------
   763
   764 = 1E19			MSB	= DATAORIGIN+$0013
   765
   766 = 1E19			@VarData	= MSB
   767 = 0001			@VarDataSize	= 1
   768
   769
   770 1057			@exit
   771 					.ifdef @new
   772 					@FreeMem #@VarData #@VarDataSize
   773 					eif
   774 1057 60				rts						; ret
   775 				.endl
   776
   777 				; -----------------------------------------------------------
   778
   779 = 1E12			__NMIEN	= DATAORIGIN+$000C
   780 = 0080			PORTB_SELFTEST_OFF	= $0080
   781 = 0002			PORTB_BASIC_OFF	= $0002
   782 = 0001			PORTB_SYSTEM_ON	= $0001
   783
   784 				.endl							; UNIT B_SYSTEM
   785
   786 				; -----------------------------------------------------------
   787
   788 1058			.local	DOS						; UNIT
   789
   790 				; -----------------------------------------------------------
   791
   792 = D014			PALNTSC	= $D014
   793
   794 				.endl							; UNIT DOS
   795
   796 				; -----------------------------------------------------------
   797
   798 1058			.local	STRUTILS					; UNIT
   799
   800 				; -----------------------------------------------------------
   801
   802
   803 				.endl							; UNIT STRUTILS
   804
   805 				; -----------------------------------------------------------
   806
   807 1058			.local	SYSUTILS					; UNIT
   808
   809 				; -----------------------------------------------------------
   810
   811 = 0001			FAREADONLY	= $0001
   812 = 0002			FAHIDDEN	= $0002
   813 = 0004			FASYSFILE	= $0004
   814 = 0008			FAVOLUMEID	= $0008
   815 = 0010			FADIRECTORY	= $0010
   816 = 0020			FAARCHIVE	= $0020
   817 = 003F			FAANYFILE	= $003F
   818
   819 				.endl							; UNIT SYSUTILS
   820
   821 				; -----------------------------------------------------------
   822
   823 1058			.local	B_CRT						; UNIT
   824
   825 1058			.local	CRT_KEYPRESSED					; FUNCTION
   826
   827 					ift l_0255-*>3
   828 					jmp l_0255
   829 					eif
   830
   831 				; IfThenEpilog
   832 1058			l_0255
   833
   834 				; optimize OK (B_CRT), line = 592
   835
   836 1058 A9 00 8D 23 1E		mva #$00 RESULT
   837
   838 				; optimize OK (B_CRT), line = 593
   839
   840 105D AD 0F D2			lda ATARI.SKSTAT
   841 1060 A0 01			ldy #1
   842 1062 29 04			and #$04
   843 1064 F0 01			beq @+
   844 1066 88				dey
   845 1067			@
   846 					.ifdef IFTMP_38
   847 					sty IFTMP_38
   848 					eif
   849 1067 98				tya
   850 1068 D0 03			bne *+5
   851 106A 4C 72 10			jmp l_026F
   852
   853 				; optimize OK (B_CRT), line = 593
   854
   855 106D A9 01 8D 23 1E		mva #$01 RESULT
   856
   857 				; IfThenEpilog
   858 1072			l_026F
   859
   860 1072			@exit
   861
   862 				; -----------------------------------------------------------
   863
   864 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   865 				; as Pointer
   866
   867 1072 E8				inx						; add bx, 1
   868 1073 AD 23 1E 95 98		mva RESULT :STACKORIGIN,x
   869
   870 					.ifdef @new
   871 					@FreeMem #@VarData #@VarDataSize
   872 					eif
   873
   874 				; -----------------------------------------------------------
   875
   876 = 1E23			RESULT	= DATAORIGIN+$001D
   877
   878 = 1E23			@VarData	= RESULT
   879 = 0001			@VarDataSize	= 1
   880
   881 1078 60				rts						; ret
   882 				.endl
   883
   884 				; -----------------------------------------------------------
   885
   886 = 0028			DEFAULT_SCREENWIDTH	= $0028
   887 = 0018			DEFAULT_SCREENHEIGHT	= $0018
   888 = 009B			CHAR_RETURN	= $009B
   889 = 001B			CHAR_ESCAPE	= $001B
   890 = 007E			CHAR_BACKSPACE	= $007E
   891 = 007F			CHAR_TAB	= $007F
   892 = 0081			CHAR_INVERSE	= $0081
   893 = 0082			CHAR_CAPS	= $0082
   894 = 00DB			ICHAR_RETURN	= $00DB
   895 = 005B			ICHAR_ESCAPE	= $005B
   896 = 007E			ICHAR_BACKSPACE	= $007E
   897 = 007F			ICHAR_TAB	= $007F
   898 = 00C1			ICHAR_INVERSE	= $00C1
   899 = 00C2			ICHAR_CAPS	= $00C2
   900 = 0DA7			adr.CRT_KEYCODE	= CODEORIGIN+$01A7
   901 1079			.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
   902 = 1E1A			CRT_VRAM	= DATAORIGIN+$0014
   903 = 1E1C			CRT_SIZE	= DATAORIGIN+$0016
   904 = 1E1E			CRT_SCREENWIDTH	= DATAORIGIN+$0018
   905 = 1E1F			CRT_SCREENHEIGHT	= DATAORIGIN+$0019
   906 = 1E20			CRT_CURSOR	= DATAORIGIN+$001A
   907 = 1E22			CRT_LEFTMARGIN	= DATAORIGIN+$001C
   908 = D209			KBCODE	= $D209
   909 = D01F			CONSOL	= $D01F
   910
   911 = 1079 A7 0D		CRT_KEYCODE
   911 				.endl							; UNIT B_CRT
   912
   913 				; -----------------------------------------------------------
   914
   915 107B			.local	CMC						; UNIT
   916
   917 107B			.local	TCMC.INIT					; PROCEDURE | ASSEMBLER
   918 107B 8D 24 1E			sta TCMC
   919 107E 8C 25 1E			sty TCMC+1
   920 1081 8D 26 1E			sta PLAYER
   921 1084 8C 27 1E			sty PLAYER+1
   922 1087 18 69 02			add #2
   923 108A 90 01			scc
   924 108C C8				iny
   925 108D 8D 28 1E			sta MODUL
   926 1090 8C 29 1E			sty MODUL+1
   927
   928
   929 				; ---------------------  ASM Block 072  ---------------------
   930
   931 1093 8A 48			txa:pha
   932
   933 1095 AD 24 1E 85 90 AD + 	mwa TCMC :bp2
   934
   935 109F A0 00			ldy #0
   936 10A1 B1 90			lda (:bp2),y
   937 10A3 18 69 03			add #3		; jsr player+3
   938 10A6 8D C8 10			sta adr
   939 10A9 C8				iny
   940 10AA B1 90			lda (:bp2),y
   941 10AC 69 00			adc #0
   942 10AE 8D C9 10			sta adr+1
   943
   944 10B1 C8				iny
   945 10B2 B1 90			lda (:bp2),y
   946 10B4 AA				tax		; low byte of RMT module to X reg
   947 10B5 C8				iny
   948 10B6 B1 90			lda (:bp2),y
   949 10B8 A8				tay		; hi byte of RMT module to Y reg
   950
   951 10B9 A9 70			lda #$70
   952 10BB 20 C7 10			jsr init
   953
   954 10BE A2 00			ldx #0
   955 10C0 8A				txa
   956 10C1 20 C7 10			jsr init
   957
   958 10C4 4C CA 10			jmp stop
   959
   960 10C7 4C FF FF		init	jmp $ffff
   961 = 10C8			adr	equ *-2
   962
   963 10CA 68 AA		stop	pla:tax
   964
   965
   966 				; -----------------------------------------------------------
   967
   968 = 1E24			TCMC	= DATAORIGIN+$001E
   969 = 1E26			PLAYER	= DATAORIGIN+$0020
   970 = 1E28			MODUL	= DATAORIGIN+$0022
   971
   972 = 1E24			@VarData	= TCMC
   973 = 0006			@VarDataSize	= 6
   974
   975
   976 10CC			@exit
   977 					.ifdef @new
   978 					@FreeMem #@VarData #@VarDataSize
   979 					eif
   980 10CC 60				rts						; ret
   981 				.endl
   982
   983 10CD			.local	TCMC.PLAY					; PROCEDURE | ASSEMBLER
   984 10CD 8D 2A 1E			sta TCMC
   985 10D0 8C 2B 1E			sty TCMC+1
   986 10D3 8D 2C 1E			sta PLAYER
   987 10D6 8C 2D 1E			sty PLAYER+1
   988 10D9 18 69 02			add #2
   989 10DC 90 01			scc
   990 10DE C8				iny
   991 10DF 8D 2E 1E			sta MODUL
   992 10E2 8C 2F 1E			sty MODUL+1
   993
   994
   995 				; ---------------------  ASM Block 073  ---------------------
   996
   997 10E5 8A 48			txa:pha
   998
   999 10E7 AD 2A 1E 8D F6 10 + 	mwa TCMC ptr
  1000
  1001 10F3 A0 01			ldy #1
  1002 10F5 B9 00 FF		cptr	lda $ff00,y
  1003 = 10F6			ptr	equ *-2
  1004 10F8 99 FF 10			sta adr,y
  1005 10FB 88				dey
  1006 10FC 10 F7			bpl cptr
  1007
  1008 10FE 20 FF FF			jsr $ffff
  1009 = 10FF			adr	equ *-2
  1010
  1011 1101 68 AA			pla:tax
  1012
  1013
  1014 				; -----------------------------------------------------------
  1015
  1016 = 1E2A			TCMC	= DATAORIGIN+$0024
  1017 = 1E2C			PLAYER	= DATAORIGIN+$0026
  1018 = 1E2E			MODUL	= DATAORIGIN+$0028
  1019
  1020 = 1E2A			@VarData	= TCMC
  1021 = 0006			@VarDataSize	= 6
  1022
  1023
  1024 1103			@exit
  1025 					.ifdef @new
  1026 					@FreeMem #@VarData #@VarDataSize
  1027 					eif
  1028 1103 60				rts						; ret
  1029 				.endl
  1030
  1031 1104			.local	TCMC.STOP					; PROCEDURE | ASSEMBLER
  1032 1104 8D 30 1E			sta TCMC
  1033 1107 8C 31 1E			sty TCMC+1
  1034 110A 8D 32 1E			sta PLAYER
  1035 110D 8C 33 1E			sty PLAYER+1
  1036 1110 18 69 02			add #2
  1037 1113 90 01			scc
  1038 1115 C8				iny
  1039 1116 8D 34 1E			sta MODUL
  1040 1119 8C 35 1E			sty MODUL+1
  1041
  1042
  1043 				; ---------------------  ASM Block 074  ---------------------
  1044
  1045 111C 8A 48			txa:pha
  1046
  1047 111E AD 30 1E 85 90 AD + 	mwa TCMC :bp2
  1048
  1049 1128 A0 00			ldy #0
  1050 112A B1 90			lda (:bp2),y
  1051 112C 18 69 03			add #3		; jsr player+3
  1052 112F 8D 3D 11			sta adr
  1053 1132 C8				iny
  1054 1133 B1 90			lda (:bp2),y
  1055 1135 69 00			adc #0
  1056 1137 8D 3E 11			sta adr+1
  1057
  1058 113A A9 40			lda #$40
  1059
  1060 113C 20 FF FF			jsr $ffff
  1061 = 113D			adr	equ *-2
  1062
  1063 113F 68 AA			pla:tax
  1064
  1065
  1066 				; -----------------------------------------------------------
  1067
  1068 = 1E30			TCMC	= DATAORIGIN+$002A
  1069 = 1E32			PLAYER	= DATAORIGIN+$002C
  1070 = 1E34			MODUL	= DATAORIGIN+$002E
  1071
  1072 = 1E30			@VarData	= TCMC
  1073 = 0006			@VarDataSize	= 6
  1074
  1075
  1076 1141			@exit
  1077 					.ifdef @new
  1078 					@FreeMem #@VarData #@VarDataSize
  1079 					eif
  1080 1141 60				rts						; ret
  1081 				.endl
  1082
  1083 				; -----------------------------------------------------------
  1084
  1085
  1086 				.endl							; UNIT CMC
  1087
  1088 1142			.local	DLI_TITLE1					; PROCEDURE | ASSEMBLER | INTERRUPT
  1089
  1090
  1091 				; ---------------------  ASM Block 078  ---------------------
  1092
  1093
  1094 1142 48 8A 48 98 48	        phr
  1095 1147 8D 0A D4		        sta ATARI.WSYNC
  1096
  1097 114A AD 3E 1E 8D 16 D0	        mva adr.gfxcolors ATARI.colpf0
  1098 1150 AD 3F 1E 8D 17 D0	        mva adr.gfxcolors+1 ATARI.colpf1
  1099 1156 AD 40 1E 8D 18 D0	        mva adr.gfxcolors+2 ATARI.colpf2
  1100 115C AD 41 1E 8D 1A D0	        mva adr.gfxcolors+3 ATARI.colbk
  1101
  1102 1162 68 A8 68 AA 68	        plr
  1103 				  
  1104 1167 40				rti						; ret
  1105 				.endl
  1106
  1107 1168			.local	VBL_TITLE					; PROCEDURE | INTERRUPT
  1108
  1109 					ift l_028A-*>3
  1110 					jmp l_028A
  1111 					eif
  1112
  1113 				; IfThenEpilog
  1114 1168			l_028A
  1115
  1116 				; ---------------------  ASM Block 079  ---------------------
  1117
  1118
  1119 1168 48 8A 48 98 48	        phr ; store registers
  1120 				        ;inc 20
  1121 				  
  1122
  1123 				; optimize OK (), line = 26
  1124
  1125 					.ifdef IFTMP_42
  1126 					lda MUSIC
  1127 					sta IFTMP_42
  1128 					eif
  1129 116D AD 4D 1E			lda MUSIC
  1130 1170 D0 03			bne *+5
  1131 1172 4C 7E 11			jmp l_0296
  1132
  1133 				; optimize FAIL ('CMC.TCMC.PLAY', ), line = 26
  1134 1175 AD FC 1C			lda MSX
  1135 1178 AC FD 1C			ldy MSX+1
  1136 117B 20 CD 10			jsr CMC.TCMC.PLAY
  1137
  1138 				; IfThenEpilog
  1139 117E			l_0296
  1140
  1141 				; ---------------------  ASM Block 080  ---------------------
  1142
  1143
  1144 				      ; mwa #DLI_TITLE1 ATARI.VDSLST
  1145 117E 68 A8 68 AA 68	      plr ; restore registers
  1146 				  
  1147 1183 40				rti						; ret
  1148 				.endl
  1149
  1150 1184			.local	GFX_FADEIN					; PROCEDURE
  1151
  1152 					ift l_029E-*>3
  1153 					jmp l_029E
  1154 					eif
  1155
  1156 				; IfThenEpilog
  1157 1184			l_029E
  1158
  1159 				; optimize OK (intro.pas), line = 48
  1160
  1161 1184 A9 00 8D 4E 1E		mva #$00 COUNT
  1162 1189 8D 4F 1E			sta COUNT+1
  1163
  1164 				; --- RepeatUntilProlog
  1165 118C			l_02A3
  1166
  1167 				; optimize FAIL ('B_SYSTEM.WAITFRAMES', intro.pas), line = 50
  1168 118C E8				inx
  1169 118D A9 02 95 98			mva #$02 :STACKORIGIN,x
  1170 1191 20 2F 10			jsr B_SYSTEM.WAITFRAMES
  1171
  1172 				; optimize OK (intro.pas), line = 51
  1173
  1174 1194 AD 3E 1E			lda adr.GFXCOLORS+$00
  1175 1197 29 0F			and #$0F
  1176 1199 85 A1			sta :STACKORIGIN+9
  1177 119B AD 42 1E			lda adr.PICCOLORS+$00
  1178 119E 29 0F			and #$0F
  1179 11A0 85 A2			sta :STACKORIGIN+10
  1180 11A2 A0 01			ldy #1
  1181 11A4 A5 A1			lda :STACKORIGIN+9
  1182 11A6 C5 A2			cmp :STACKORIGIN+10
  1183 11A8 D0 01			bne @+
  1184 11AA 88				dey
  1185 11AB			@
  1186 					.ifdef IFTMP_43
  1187 11AB 8C 76 1E			sty IFTMP_43
  1188 					eif
  1189 11AE 98				tya
  1190 11AF D0 03			bne *+5
  1191 11B1 4C B7 11			jmp l_02C3
  1192
  1193 				; optimize OK (intro.pas), line = 51
  1194
  1195 11B4 EE 3E 1E			inc adr.GFXCOLORS+$00
  1196
  1197 				; IfThenEpilog
  1198 11B7			l_02C3
  1199
  1200 				; Restore conditional expression
  1201 11B7 AD 76 1E			lda IFTMP_43
  1202
  1203 				; else condition
  1204 11BA F0 03			beq *+5						; je
  1205 11BC 4C C5 11			jmp l_02CF
  1206
  1207 				; optimize OK (intro.pas), line = 51
  1208
  1209 11BF AD 42 1E			lda adr.PICCOLORS+$00
  1210 11C2 8D 3E 1E			sta adr.GFXCOLORS+$00
  1211
  1212 				; IfThenEpilog
  1213 11C5			l_02CF
  1214
  1215 				; optimize OK (intro.pas), line = 52
  1216
  1217 11C5 A0 01			ldy #1
  1218 11C7 B9 3E 1E			lda adr.GFXCOLORS,y
  1219 11CA 29 0F			and #$0F
  1220 11CC 85 A1			sta :STACKORIGIN+9
  1221 11CE B9 42 1E			lda adr.PICCOLORS,y
  1222 11D1 29 0F			and #$0F
  1223 11D3 85 A2			sta :STACKORIGIN+10
  1224 11D5 A5 A1			lda :STACKORIGIN+9
  1225 11D7 C5 A2			cmp :STACKORIGIN+10
  1226 11D9 D0 01			bne @+
  1227 11DB 88				dey
  1228 11DC			@
  1229 					.ifdef IFTMP_44
  1230 11DC 8C 77 1E			sty IFTMP_44
  1231 					eif
  1232 11DF 98				tya
  1233 11E0 D0 03			bne *+5
  1234 11E2 4C E8 11			jmp l_02F5
  1235
  1236 				; optimize OK (intro.pas), line = 52
  1237
  1238 11E5 EE 3F 1E			inc adr.GFXCOLORS+$01
  1239
  1240 				; IfThenEpilog
  1241 11E8			l_02F5
  1242
  1243 				; Restore conditional expression
  1244 11E8 AD 77 1E			lda IFTMP_44
  1245
  1246 				; else condition
  1247 11EB F0 03			beq *+5						; je
  1248 11ED 4C F6 11			jmp l_0301
  1249
  1250 				; optimize OK (intro.pas), line = 52
  1251
  1252 11F0 AD 43 1E			lda adr.PICCOLORS+$01
  1253 11F3 8D 3F 1E			sta adr.GFXCOLORS+$01
  1254
  1255 				; IfThenEpilog
  1256 11F6			l_0301
  1257
  1258 				; optimize OK (intro.pas), line = 53
  1259
  1260 11F6 AD 40 1E			lda adr.GFXCOLORS+$02
  1261 11F9 29 0F			and #$0F
  1262 11FB 85 A1			sta :STACKORIGIN+9
  1263 11FD AD 44 1E			lda adr.PICCOLORS+$02
  1264 1200 29 0F			and #$0F
  1265 1202 85 A2			sta :STACKORIGIN+10
  1266 1204 A0 01			ldy #1
  1267 1206 A5 A1			lda :STACKORIGIN+9
  1268 1208 C5 A2			cmp :STACKORIGIN+10
  1269 120A D0 01			bne @+
  1270 120C 88				dey
  1271 120D			@
  1272 					.ifdef IFTMP_45
  1273 120D 8C 78 1E			sty IFTMP_45
  1274 					eif
  1275 1210 98				tya
  1276 1211 D0 03			bne *+5
  1277 1213 4C 19 12			jmp l_0327
  1278
  1279 				; optimize OK (intro.pas), line = 53
  1280
  1281 1216 EE 40 1E			inc adr.GFXCOLORS+$02
  1282
  1283 				; IfThenEpilog
  1284 1219			l_0327
  1285
  1286 				; Restore conditional expression
  1287 1219 AD 78 1E			lda IFTMP_45
  1288
  1289 				; else condition
  1290 121C F0 03			beq *+5						; je
  1291 121E 4C 27 12			jmp l_0333
  1292
  1293 				; optimize OK (intro.pas), line = 53
  1294
  1295 1221 AD 44 1E			lda adr.PICCOLORS+$02
  1296 1224 8D 40 1E			sta adr.GFXCOLORS+$02
  1297
  1298 				; IfThenEpilog
  1299 1227			l_0333
  1300
  1301 				; optimize OK (intro.pas), line = 54
  1302
  1303 1227 AD 41 1E			lda adr.GFXCOLORS+$03
  1304 122A 29 0F			and #$0F
  1305 122C 85 A1			sta :STACKORIGIN+9
  1306 122E AD 45 1E			lda adr.PICCOLORS+$03
  1307 1231 29 0F			and #$0F
  1308 1233 85 A2			sta :STACKORIGIN+10
  1309 1235 A0 01			ldy #1
  1310 1237 A5 A1			lda :STACKORIGIN+9
  1311 1239 C5 A2			cmp :STACKORIGIN+10
  1312 123B D0 01			bne @+
  1313 123D 88				dey
  1314 123E			@
  1315 					.ifdef IFTMP_46
  1316 123E 8C 79 1E			sty IFTMP_46
  1317 					eif
  1318 1241 98				tya
  1319 1242 D0 03			bne *+5
  1320 1244 4C 4A 12			jmp l_0359
  1321
  1322 				; optimize OK (intro.pas), line = 54
  1323
  1324 1247 EE 41 1E			inc adr.GFXCOLORS+$03
  1325
  1326 				; IfThenEpilog
  1327 124A			l_0359
  1328
  1329 				; Restore conditional expression
  1330 124A AD 79 1E			lda IFTMP_46
  1331
  1332 				; else condition
  1333 124D F0 03			beq *+5						; je
  1334 124F 4C 58 12			jmp l_0365
  1335
  1336 				; optimize OK (intro.pas), line = 54
  1337
  1338 1252 AD 45 1E			lda adr.PICCOLORS+$03
  1339 1255 8D 41 1E			sta adr.GFXCOLORS+$03
  1340
  1341 				; IfThenEpilog
  1342 1258			l_0365
  1343
  1344 				; optimize OK (intro.pas), line = 55
  1345
  1346 1258 A0 01			ldy #1
  1347 125A AD 42 1E			lda adr.PICCOLORS+$00
  1348 125D CD 3E 1E			cmp adr.GFXCOLORS+$00
  1349 1260 F0 01			beq @+
  1350 1262 88				dey
  1351 1263			@
  1352 1263 84 A1			sty :STACKORIGIN+9
  1353 1265 A0 01			ldy #1
  1354 1267 B9 3E 1E			lda adr.GFXCOLORS,y
  1355 126A D9 42 1E			cmp adr.PICCOLORS,y
  1356 126D F0 01			beq @+
  1357 126F 88				dey
  1358 1270			@
  1359 1270 98				tya
  1360 1271 25 A1			and :STACKORIGIN+9
  1361 1273 85 A1			sta :STACKORIGIN+9
  1362 1275 A0 01			ldy #1
  1363 1277 AD 44 1E			lda adr.PICCOLORS+$02
  1364 127A CD 40 1E			cmp adr.GFXCOLORS+$02
  1365 127D F0 01			beq @+
  1366 127F 88				dey
  1367 1280			@
  1368 1280 98				tya
  1369 1281 25 A1			and :STACKORIGIN+9
  1370 1283 85 A1			sta :STACKORIGIN+9
  1371 1285 A0 01			ldy #1
  1372 1287 AD 45 1E			lda adr.PICCOLORS+$03
  1373 128A CD 41 1E			cmp adr.GFXCOLORS+$03
  1374 128D F0 01			beq @+
  1375 128F 88				dey
  1376 1290			@
  1377 1290 98				tya
  1378 1291 25 A1			and :STACKORIGIN+9
  1379 1293 D0 03			bne *+5
  1380 1295			c_02A3
  1381 1295 4C 8C 11			jmp l_02A3
  1382 1298			b_02A3
  1383
  1384 				; -----------------------------------------------------------
  1385
  1386 = 1E76			IFTMP_43	= DATAORIGIN+$0070
  1387 = 1E77			IFTMP_44	= DATAORIGIN+$0071
  1388 = 1E78			IFTMP_45	= DATAORIGIN+$0072
  1389 = 1E79			IFTMP_46	= DATAORIGIN+$0073
  1390
  1391 = 1E76			@VarData	= IFTMP_43
  1392 = 0004			@VarDataSize	= 4
  1393
  1394
  1395 1298			@exit
  1396 					.ifdef @new
  1397 					@FreeMem #@VarData #@VarDataSize
  1398 					eif
  1399 1298 60				rts						; ret
  1400 				.endl
  1401
  1402 1299			.local	GFX_FADEOUT					; PROCEDURE
  1403
  1404 					ift l_03B2-*>3
  1405 					jmp l_03B2
  1406 					eif
  1407
  1408 				; IfThenEpilog
  1409 1299			l_03B2
  1410
  1411 				; --- RepeatUntilProlog
  1412 1299			l_03B3
  1413
  1414 				; optimize FAIL ('B_SYSTEM.WAITFRAMES', intro.pas), line = 62
  1415 1299 E8				inx
  1416 129A A9 02 95 98			mva #$02 :STACKORIGIN,x
  1417 129E 20 2F 10			jsr B_SYSTEM.WAITFRAMES
  1418
  1419 				; optimize OK (intro.pas), line = 63
  1420
  1421 12A1 AD 3E 1E			lda adr.GFXCOLORS+$00
  1422 12A4 A0 01			ldy #1
  1423 12A6 29 0F			and #$0F
  1424 12A8 D0 01			bne @+
  1425 12AA 88				dey
  1426 12AB			@
  1427 					.ifdef IFTMP_47
  1428 12AB 8C 7A 1E			sty IFTMP_47
  1429 					eif
  1430 12AE 98				tya
  1431 12AF D0 03			bne *+5
  1432 12B1 4C B7 12			jmp l_03CC
  1433
  1434 				; optimize OK (intro.pas), line = 63
  1435
  1436 12B4 CE 3E 1E			dec adr.GFXCOLORS+$00
  1437
  1438 				; IfThenEpilog
  1439 12B7			l_03CC
  1440
  1441 				; Restore conditional expression
  1442 12B7 AD 7A 1E			lda IFTMP_47
  1443
  1444 				; else condition
  1445 12BA F0 03			beq *+5						; je
  1446 12BC 4C C4 12			jmp l_03D8
  1447
  1448 				; optimize OK (intro.pas), line = 63
  1449
  1450 12BF A9 00 8D 3E 1E		mva #$00 adr.GFXCOLORS+$00
  1451
  1452 				; IfThenEpilog
  1453 12C4			l_03D8
  1454
  1455 				; optimize OK (intro.pas), line = 64
  1456
  1457 12C4 A0 01			ldy #1
  1458 12C6 B9 3E 1E			lda adr.GFXCOLORS,y
  1459 12C9 29 0F			and #$0F
  1460 12CB C9 00			cmp #$00
  1461 12CD D0 01			bne @+
  1462 12CF 88				dey
  1463 12D0			@
  1464 					.ifdef IFTMP_48
  1465 12D0 8C 7B 1E			sty IFTMP_48
  1466 					eif
  1467 12D3 98				tya
  1468 12D4 D0 03			bne *+5
  1469 12D6 4C DC 12			jmp l_03F4
  1470
  1471 				; optimize OK (intro.pas), line = 64
  1472
  1473 12D9 CE 3F 1E			dec adr.GFXCOLORS+$01
  1474
  1475 				; IfThenEpilog
  1476 12DC			l_03F4
  1477
  1478 				; Restore conditional expression
  1479 12DC AD 7B 1E			lda IFTMP_48
  1480
  1481 				; else condition
  1482 12DF F0 03			beq *+5						; je
  1483 12E1 4C E9 12			jmp l_0400
  1484
  1485 				; optimize OK (intro.pas), line = 64
  1486
  1487 12E4 A9 00 8D 3F 1E		mva #$00 adr.GFXCOLORS+$01
  1488
  1489 				; IfThenEpilog
  1490 12E9			l_0400
  1491
  1492 				; optimize OK (intro.pas), line = 65
  1493
  1494 12E9 AD 40 1E			lda adr.GFXCOLORS+$02
  1495 12EC A0 01			ldy #1
  1496 12EE 29 0F			and #$0F
  1497 12F0 D0 01			bne @+
  1498 12F2 88				dey
  1499 12F3			@
  1500 					.ifdef IFTMP_49
  1501 12F3 8C 7C 1E			sty IFTMP_49
  1502 					eif
  1503 12F6 98				tya
  1504 12F7 D0 03			bne *+5
  1505 12F9 4C FF 12			jmp l_041C
  1506
  1507 				; optimize OK (intro.pas), line = 65
  1508
  1509 12FC CE 40 1E			dec adr.GFXCOLORS+$02
  1510
  1511 				; IfThenEpilog
  1512 12FF			l_041C
  1513
  1514 				; Restore conditional expression
  1515 12FF AD 7C 1E			lda IFTMP_49
  1516
  1517 				; else condition
  1518 1302 F0 03			beq *+5						; je
  1519 1304 4C 0C 13			jmp l_0428
  1520
  1521 				; optimize OK (intro.pas), line = 65
  1522
  1523 1307 A9 00 8D 40 1E		mva #$00 adr.GFXCOLORS+$02
  1524
  1525 				; IfThenEpilog
  1526 130C			l_0428
  1527
  1528 				; optimize OK (intro.pas), line = 66
  1529
  1530 130C AD 41 1E			lda adr.GFXCOLORS+$03
  1531 130F A0 01			ldy #1
  1532 1311 29 0F			and #$0F
  1533 1313 D0 01			bne @+
  1534 1315 88				dey
  1535 1316			@
  1536 					.ifdef IFTMP_50
  1537 1316 8C 7D 1E			sty IFTMP_50
  1538 					eif
  1539 1319 98				tya
  1540 131A D0 03			bne *+5
  1541 131C 4C 22 13			jmp l_0444
  1542
  1543 				; optimize OK (intro.pas), line = 66
  1544
  1545 131F CE 41 1E			dec adr.GFXCOLORS+$03
  1546
  1547 				; IfThenEpilog
  1548 1322			l_0444
  1549
  1550 				; Restore conditional expression
  1551 1322 AD 7D 1E			lda IFTMP_50
  1552
  1553 				; else condition
  1554 1325 F0 03			beq *+5						; je
  1555 1327 4C 2F 13			jmp l_0450
  1556
  1557 				; optimize OK (intro.pas), line = 66
  1558
  1559 132A A9 00 8D 41 1E		mva #$00 adr.GFXCOLORS+$03
  1560
  1561 				; IfThenEpilog
  1562 132F			l_0450
  1563
  1564 				; optimize OK (intro.pas), line = 73
  1565
  1566 132F AD 3E 1E			lda adr.GFXCOLORS+$00
  1567 1332 0D 3F 1E			ora adr.GFXCOLORS+$01
  1568 1335 0D 40 1E			ora adr.GFXCOLORS+$02
  1569 1338 85 A1			sta :STACKORIGIN+9
  1570 133A AD 41 1E			lda adr.GFXCOLORS+$03
  1571 133D A0 01			ldy #1
  1572 133F 05 A1			ora :STACKORIGIN+9
  1573 1341 F0 01			beq @+
  1574 1343 88				dey
  1575 1344			@
  1576 1344 98				tya
  1577 1345 D0 03			bne *+5
  1578 1347			c_03B3
  1579 1347 4C 99 12			jmp l_03B3
  1580 134A			b_03B3
  1581
  1582 				; -----------------------------------------------------------
  1583
  1584 = 1E7A			IFTMP_47	= DATAORIGIN+$0074
  1585 = 1E7B			IFTMP_48	= DATAORIGIN+$0075
  1586 = 1E7C			IFTMP_49	= DATAORIGIN+$0076
  1587 = 1E7D			IFTMP_50	= DATAORIGIN+$0077
  1588
  1589 = 1E7A			@VarData	= IFTMP_47
  1590 = 0004			@VarDataSize	= 4
  1591
  1592
  1593 134A			@exit
  1594 					.ifdef @new
  1595 					@FreeMem #@VarData #@VarDataSize
  1596 					eif
  1597 134A 60				rts						; ret
  1598 				.endl
  1599
  1600 134B			.local	EXTENDNIBBLE					; FUNCTION
  1601
  1602 				; -----------------------------------------------------------
  1603
  1604 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1605 				; as Pointer
  1606 134B B5 98 8D 7E 1E		mva :STACKORIGIN,x N
  1607 1350 CA				dex						; sub bx, 1
  1608
  1609 					ift l_047F-*>3
  1610 					jmp l_047F
  1611 					eif
  1612
  1613 				; IfThenEpilog
  1614 1351			l_047F
  1615
  1616 				; optimize OK (intro.pas), line = 80
  1617
  1618 1351 A9 03 8D 81 1E		mva #$03 COLORMASK
  1619
  1620 				; optimize OK (intro.pas), line = 81
  1621
  1622 1356 A9 01 8D 82 1E		mva #$01 TESTMASK
  1623
  1624 				; optimize OK (intro.pas), line = 82
  1625
  1626 135B A9 00 8D 7F 1E		mva #$00 RESULT
  1627 				; For
  1628
  1629 				; optimize OK (intro.pas), line = 83
  1630
  1631 1360 A9 00 8D 80 1E		mva #$00 BIT
  1632
  1633 				; optimize OK (intro.pas), line = 83
  1634
  1635 				; To
  1636 1365			l_0494
  1637
  1638 				; ForToDoCondition
  1639
  1640 				; optimize OK (intro.pas), line = 83
  1641
  1642 1365 AD 80 1E			lda BIT
  1643 1368 C9 03			cmp #$03
  1644 136A 90 05			bcc *+7
  1645 136C F0 03			beq *+5
  1646
  1647 				; ForToDoProlog
  1648 136E 4C A2 13			jmp l_04A2
  1649
  1650 				; optimize OK (intro.pas), line = 84
  1651
  1652 1371 AD 7E 1E			lda N
  1653 1374 A0 01			ldy #1
  1654 1376 2D 82 1E			and TESTMASK
  1655 1379 D0 01			bne @+
  1656 137B 88				dey
  1657 137C			@
  1658 					.ifdef IFTMP_51
  1659 					sty IFTMP_51
  1660 					eif
  1661 137C 98				tya
  1662 137D D0 03			bne *+5
  1663 137F 4C 8B 13			jmp l_04BA
  1664
  1665 				; optimize OK (intro.pas), line = 84
  1666
  1667 1382 AD 7F 1E			lda RESULT
  1668 1385 0D 81 1E			ora COLORMASK
  1669 1388 8D 7F 1E			sta RESULT
  1670
  1671 				; IfThenEpilog
  1672 138B			l_04BA
  1673
  1674 				; optimize OK (intro.pas), line = 85
  1675
  1676 138B AD 82 1E			lda TESTMASK
  1677 138E 0A				asl @
  1678 138F 8D 82 1E			sta TESTMASK
  1679
  1680 				; optimize OK (intro.pas), line = 86
  1681
  1682 1392 AD 81 1E			lda COLORMASK
  1683 1395 0A 0A			:2 asl @
  1684 1397 8D 81 1E			sta COLORMASK
  1685
  1686 				; ForToDoEpilog
  1687 139A			c_0494
  1688 139A EE 80 1E			inc BIT						; inc ptr byte [CounterAddress]
  1689
  1690 139D F0 03			seq
  1691
  1692 				; WhileDoEpilog
  1693 139F 4C 65 13			jmp l_0494
  1694 13A2			l_04A2
  1695 13A2			b_0494
  1696
  1697 13A2			@exit
  1698
  1699 				; -----------------------------------------------------------
  1700
  1701 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1702 				; as Pointer
  1703
  1704 13A2 E8				inx						; add bx, 1
  1705 13A3 AD 7F 1E 95 98		mva RESULT :STACKORIGIN,x
  1706
  1707 					.ifdef @new
  1708 					@FreeMem #@VarData #@VarDataSize
  1709 					eif
  1710
  1711 				; -----------------------------------------------------------
  1712
  1713 = 1E7E			N	= DATAORIGIN+$0078
  1714 = 1E7F			RESULT	= DATAORIGIN+$0079
  1715 = 1E80			BIT	= DATAORIGIN+$007A
  1716 = 1E81			COLORMASK	= DATAORIGIN+$007B
  1717 = 1E82			TESTMASK	= DATAORIGIN+$007C
  1718 = 0003			@FORTMP_1169	= $0003
  1719
  1720 = 1E7E			@VarData	= N
  1721 = 0005			@VarDataSize	= 5
  1722
  1723 13A8 60				rts						; ret
  1724 				.endl
  1725
  1726 13A9			.local	PUTCHAR						; PROCEDURE
  1727
  1728 				; -----------------------------------------------------------
  1729
  1730 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1731 				; as Pointer
  1732 13A9 B5 98 8D 85 1E		mva :STACKORIGIN,x ONECHAR
  1733 13AE CA				dex						; sub bx, 1
  1734
  1735 				; -----------------------------------------------------------
  1736
  1737 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1738 				; as Pointer
  1739 13AF B5 98 8D 83 1E		mva :STACKORIGIN,x DEST
  1740 13B4 B5 A8 8D 84 1E		mva :STACKORIGIN+STACKWIDTH,x DEST+1
  1741 13B9 CA				dex						; sub bx, 1
  1742
  1743 					ift l_04EF-*>3
  1744 					jmp l_04EF
  1745 					eif
  1746
  1747 				; IfThenEpilog
  1748 13BA			l_04EF
  1749
  1750 				; optimize OK (intro.pas), line = 98
  1751
  1752 13BA AD 85 1E			lda ONECHAR
  1753 13BD 85 A3			sta :STACKORIGIN+11
  1754 13BF A9 00			lda #$00
  1755 13C1 06 A3			asl :STACKORIGIN+11
  1756 13C3 2A				rol @
  1757 13C4 06 A3			asl :STACKORIGIN+11
  1758 13C6 2A				rol @
  1759 13C7 06 A3			asl :STACKORIGIN+11
  1760 13C9 2A				rol @
  1761 13CA 18 69 E4			add #$E4
  1762 13CD 8D 87 1E			sta SRC+1
  1763 13D0 A5 A3			lda :STACKORIGIN+11
  1764 13D2 8D 86 1E			sta SRC
  1765 				; For
  1766
  1767 				; optimize OK (intro.pas), line = 99
  1768
  1769 13D5 A9 00 8D 8A 1E		mva #$00 X
  1770
  1771 				; optimize OK (intro.pas), line = 99
  1772
  1773 				; To
  1774 13DA			l_0506
  1775
  1776 				; ForToDoCondition
  1777
  1778 				; optimize OK (intro.pas), line = 99
  1779
  1780 13DA AD 8A 1E			lda X
  1781 13DD C9 07			cmp #$07
  1782 13DF 90 05			bcc *+7
  1783 13E1 F0 03			beq *+5
  1784
  1785 				; ForToDoProlog
  1786 13E3 4C 64 14			jmp l_0514
  1787
  1788 				; optimize OK (intro.pas), line = 100
  1789
  1790 13E6 AD 87 1E			lda SRC+1
  1791 13E9 85 8F			sta :bp+1
  1792 13EB AC 86 1E			ldy SRC
  1793 13EE B1 8E			lda (:bp),y
  1794 13F0 8D 8B 1E			sta BSRC
  1795
  1796 				; optimize FAIL ('EXTENDNIBBLE', intro.pas), line = 101
  1797 13F3 E8				inx
  1798 13F4 AD 8B 1E 95 98		mva BSRC :STACKORIGIN,x
  1799 13F9 E8				inx
  1800 13FA A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1801 13FE 20 12 1D			jsr andAL_CL
  1802 1401 CA				dex
  1803 1402 20 4B 13			jsr EXTENDNIBBLE
  1804 1405 B5 98 8D 88 1E		mva :STACKORIGIN,x NIB1
  1805 140A CA				dex
  1806
  1807 				; optimize FAIL ('EXTENDNIBBLE', intro.pas), line = 102
  1808 140B E8				inx
  1809 140C AD 8B 1E 95 98		mva BSRC :STACKORIGIN,x
  1810 1411 E8				inx
  1811 1412 A9 04 95 98			mva #$04 :STACKORIGIN,x
  1812 1416 20 00 1D			jsr shrAL_CL.BYTE
  1813 1419 CA				dex
  1814 141A 20 4B 13			jsr EXTENDNIBBLE
  1815 141D B5 98 8D 89 1E		mva :STACKORIGIN,x NIB2
  1816 1422 CA				dex
  1817
  1818 				; optimize OK (intro.pas), line = 103
  1819
  1820 1423 AD 89 1E			lda NIB2
  1821 1426 8D 8C 1E			sta RES
  1822 1429 AD 88 1E			lda NIB1
  1823 142C 8D 8D 1E			sta RES+1
  1824
  1825 				; optimize OK (intro.pas), line = 104
  1826
  1827 142F AD 83 1E			lda DEST
  1828 1432 85 90			sta :bp2
  1829 1434 AD 84 1E			lda DEST+1
  1830 1437 85 91			sta :bp2+1
  1831 1439 A0 00			ldy #$00
  1832 143B AD 8C 1E			lda RES
  1833 143E 91 90			sta (:bp2),y
  1834 1440 C8				iny
  1835 1441 AD 8D 1E			lda RES+1
  1836 1444 91 90			sta (:bp2),y
  1837
  1838 				; optimize FAIL (0, intro.pas), line = 105
  1839 1446 EE 86 1E D0 03 EE + 	inw SRC
  1840
  1841 				; optimize OK (intro.pas), line = 106
  1842
  1843 144E AD 83 1E			lda DEST
  1844 1451 18 69 28			add #$28
  1845 1454 8D 83 1E			sta DEST
  1846 1457 90 03			scc
  1847 1459 EE 84 1E			inc DEST+1
  1848
  1849 				; ForToDoEpilog
  1850 145C			c_0506
  1851 145C EE 8A 1E			inc X						; inc ptr byte [CounterAddress]
  1852
  1853 145F F0 03			seq
  1854
  1855 				; WhileDoEpilog
  1856 1461 4C DA 13			jmp l_0506
  1857 1464			l_0514
  1858 1464			b_0506
  1859
  1860 				; -----------------------------------------------------------
  1861
  1862 = 1E83			DEST	= DATAORIGIN+$007D
  1863 = 1E85			ONECHAR	= DATAORIGIN+$007F
  1864 = 1E86			SRC	= DATAORIGIN+$0080
  1865 = 1E88			NIB1	= DATAORIGIN+$0082
  1866 = 1E89			NIB2	= DATAORIGIN+$0083
  1867 = 1E8A			X	= DATAORIGIN+$0084
  1868 = 1E8B			BSRC	= DATAORIGIN+$0085
  1869 = 1E8C			RES	= DATAORIGIN+$0086
  1870 = 0007			@FORTMP_1283	= $0007
  1871
  1872 = 1E83			@VarData	= DEST
  1873 = 000B			@VarDataSize	= 11
  1874
  1875
  1876 1464			@exit
  1877 					.ifdef @new
  1878 					@FreeMem #@VarData #@VarDataSize
  1879 					eif
  1880 1464 60				rts						; ret
  1881 				.endl
  1882
  1883 1465			.local	PUTSTRING					; PROCEDURE
  1884
  1885 				; -----------------------------------------------------------
  1886
  1887 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1888 				; as Pointer
  1889 1465 B5 98 8D 21 15		mva :STACKORIGIN,x TEXT
  1890 146A B5 A8 8D 22 15		mva :STACKORIGIN+STACKWIDTH,x TEXT+1
  1891 146F CA				dex						; sub bx, 1
  1892 					@move TEXT #adr.TEXT #256
  1892 				 MWA TEXT @MOVE.PTR1\ MWA #ADR.TEXT @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
  1892 1470 AD 21 15 85 86 AD +  MWA TEXT @MOVE.PTR1
  1892 147A A9 90 85 8A A9 1E +  MWA #ADR.TEXT @MOVE.PTR2
  1892 1482 A9 00 85 82 A9 01 +  MWA #256 @MOVE.PTR3
  1892 148A 20 69 1D		 JSR @MOVE
  1893 148D A9 90 8D 21 15 A9 + 	mwa #adr.TEXT TEXT
  1894
  1895 				; -----------------------------------------------------------
  1896
  1897 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1898 				; as Pointer
  1899 1497 B5 98 8D 8F 1E		mva :STACKORIGIN,x Y
  1900 149C CA				dex						; sub bx, 1
  1901
  1902 				; -----------------------------------------------------------
  1903
  1904 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1905 				; as Pointer
  1906 149D B5 98 8D 8E 1E		mva :STACKORIGIN,x X
  1907 14A2 CA				dex						; sub bx, 1
  1908
  1909 					ift l_055C-*>3
  1910 					jmp l_055C
  1911 					eif
  1912
  1913 				; IfThenEpilog
  1914 14A3			l_055C
  1915
  1916 				; optimize OK (intro.pas), line = 119
  1917
  1918 14A3 A9 40			lda #$40
  1919 14A5 85 8A			sta :ecx
  1920 14A7 A9 01			lda #$01
  1921 14A9 85 8B			sta :ecx+1
  1922 14AB AD 8F 1E			lda Y
  1923 14AE 85 82			sta :eax
  1924 14B0 A9 00			lda #$00
  1925 14B2 85 83			sta :eax+1
  1926 					.ifdef fmulinit
  1927 					fmulu_16
  1928 					els
  1929 14B4 20 19 1D			imulCX
  1930 					eif
  1931 14B7 A9 10			lda #$10
  1932 14B9 18 65 82			add :eax
  1933 14BC 85 A1			sta :STACKORIGIN+9
  1934 14BE A9 B0			lda #$B0
  1935 14C0 65 83			adc :eax+1
  1936 14C2 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  1937 14C4 A9 00			lda #$00
  1938 14C6 85 B3			sta :STACKORIGIN+STACKWIDTH+11
  1939 14C8 AD 8E 1E			lda X
  1940 14CB 0A				asl @
  1941 14CC 26 B3			rol :STACKORIGIN+STACKWIDTH+11
  1942 14CE 18 65 A1			add :STACKORIGIN+9
  1943 14D1 8D 90 1F			sta MEM
  1944 14D4 A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  1945 14D6 65 B3			adc :STACKORIGIN+STACKWIDTH+11
  1946 14D8 8D 91 1F			sta MEM+1
  1947 				; For
  1948
  1949 				; optimize OK (intro.pas), line = 121
  1950
  1951 14DB A9 01 8D 92 1F		mva #$01 I
  1952
  1953 				; optimize OK (intro.pas), line = 121
  1954
  1955 14E0 AD 90 1E			lda adr.TEXT+$00
  1956 14E3 8D 93 1F			sta @FORTMP_1405
  1957 				; To
  1958 14E6			l_0580
  1959
  1960 				; ForToDoCondition
  1961
  1962 				; optimize OK (intro.pas), line = 121
  1963
  1964 14E6 AD 92 1F			lda I
  1965 14E9 CD 93 1F			cmp @FORTMP_1405
  1966 14EC 90 05			bcc *+7
  1967 14EE F0 03			beq *+5
  1968
  1969 				; ForToDoProlog
  1970 14F0 4C 20 15			jmp l_058E
  1971
  1972 				; optimize FAIL ('PUTCHAR', intro.pas), line = 123
  1973 14F3 E8				inx
  1974 14F4 AD 90 1F 95 98		mva MEM :STACKORIGIN,x
  1975 14F9 AD 91 1F 95 A8		mva MEM+1 :STACKORIGIN+STACKWIDTH,x
  1976 14FE E8				inx
  1977 14FF AC 92 1F			ldy I 
  1978 1502 B9 90 1E 95 98		mva adr.TEXT,y :STACKORIGIN,x
  1979 1507 20 A9 13			jsr PUTCHAR
  1980
  1981 				; optimize OK (intro.pas), line = 124
  1982
  1983 150A AD 90 1F			lda MEM
  1984 150D 18 69 02			add #$02
  1985 1510 8D 90 1F			sta MEM
  1986 1513 90 03			scc
  1987 1515 EE 91 1F			inc MEM+1
  1988
  1989 				; ForToDoEpilog
  1990 1518			c_0580
  1991 1518 EE 92 1F			inc I						; inc ptr byte [CounterAddress]
  1992
  1993 151B F0 03			seq
  1994
  1995 				; WhileDoEpilog
  1996 151D 4C E6 14			jmp l_0580
  1997 1520			l_058E
  1998 1520			b_0580
  1999
  2000 				; -----------------------------------------------------------
  2001
  2002 = 1E8E			X	= DATAORIGIN+$0088
  2003 = 1E8F			Y	= DATAORIGIN+$0089
  2004 = 1E90			adr.TEXT	= DATAORIGIN+$008A
  2005 1520			.var TEXT	= adr.TEXT .word
  2006 = 1F90			MEM	= DATAORIGIN+$018A
  2007 = 1F92			I	= DATAORIGIN+$018C
  2008 = 1F93			@FORTMP_1405	= DATAORIGIN+$018D
  2009
  2010 = 1E8E			@VarData	= X
  2011 = 0106			@VarDataSize	= 262
  2012
  2013
  2014 1520			@exit
  2015 					.ifdef @new
  2016 					@FreeMem #@VarData #@VarDataSize
  2017 					eif
  2018 1520 60				rts						; ret
  2019 = 1521 90 1E		TEXT
  2019 				.endl
  2020
  2021 				; IfThenEpilog
  2022 1523			l_01AE
  2023
  2024 				; optimize FAIL ('B_SYSTEM.SYSTEMOFF_01FE', intro.pas), line = 130
  2025 1523 20 96 0F			jsr B_SYSTEM.SYSTEMOFF_01FE
  2026
  2027 				; optimize OK (intro.pas), line = 136
  2028
  2029 1526 A9 00 8D 46 1E		mva #$00 MSX.PLAYER
  2030 152B A9 24 8D 47 1E		mva #$24 MSX.PLAYER+1
  2031
  2032 				; optimize OK (intro.pas), line = 137
  2033
  2034 1530 A9 00 8D 48 1E		mva #$00 MSX.MODUL
  2035 1535 A9 2C 8D 49 1E		mva #$2C MSX.MODUL+1
  2036
  2037 				; optimize FAIL ('CMC.TCMC.INIT', intro.pas), line = 138
  2038 153A AD FC 1C			lda MSX
  2039 153D AC FD 1C			ldy MSX+1
  2040 1540 20 7B 10			jsr CMC.TCMC.INIT
  2041
  2042 				; optimize OK (intro.pas), line = 140
  2043
  2044 1543 A9 00 8D 4C 1E		mva #$00 SKIP
  2045
  2046 				; optimize OK (intro.pas), line = 141
  2047
  2048 1548 A9 01 8D 4D 1E		mva #$01 MUSIC
  2049
  2050 				; optimize OK (intro.pas), line = 144
  2051
  2052 154D A9 10			lda #$10
  2053 154F 85 86			sta :edx
  2054 1551 A9 B0			lda #$B0
  2055 1553 85 87			sta :edx+1
  2056 1555 A9 04			lda #$04
  2057 1557 85 8A			sta :ecx
  2058 1559 A9 1E			lda #$1E
  2059 155B 85 8B			sta :ecx+1
  2060 155D A9 00			lda #$00
  2061 155F 85 82			sta :eax
  2062 1561 20 BE 1D			jsr @fill
  2063
  2064 				; optimize FAIL ('B_SYSTEM.SETCHARSET', intro.pas), line = 145
  2065 1564 E8				inx
  2066 1565 A9 E4 95 98			mva #$E4 :STACKORIGIN,x
  2067 1569 20 4B 10			jsr B_SYSTEM.SETCHARSET
  2068
  2069 				; optimize OK (intro.pas), line = 148
  2070
  2071 156C A9 42 8D 00 02		mva <DLI_TITLE1 ATARI.VDSLST
  2072 1571 A9 11 8D 01 02		mva >DLI_TITLE1 ATARI.VDSLST+1
  2073
  2074 				; optimize FAIL ('B_SYSTEM.ENABLEVBLI', intro.pas), line = 149
  2075 1576 E8				inx
  2076 1577 A9 68 95 98			mva <VBL_TITLE :STACKORIGIN,x
  2077 157B A9 11 95 A8			mva >VBL_TITLE :STACKORIGIN+STACKWIDTH,x
  2078 157F 20 9F 0F			jsr B_SYSTEM.ENABLEVBLI
  2079
  2080 				; optimize FAIL ('B_SYSTEM.ENABLEDLI', intro.pas), line = 150
  2081 1582 E8				inx
  2082 1583 A9 42 95 98			mva <DLI_TITLE1 :STACKORIGIN,x
  2083 1587 A9 11 95 A8			mva >DLI_TITLE1 :STACKORIGIN+STACKWIDTH,x
  2084 158B 20 EE 0F			jsr B_SYSTEM.ENABLEDLI
  2085
  2086 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 151
  2087 158E 20 28 10			jsr B_SYSTEM.WAITFRAME
  2088
  2089 				; optimize OK (intro.pas), line = 152
  2090
  2091 1591 A9 00 8D 02 D4		mva #$00 ATARI.DLISTL
  2092 1596 A9 20 8D 03 D4		mva #$20 ATARI.DLISTL+1
  2093
  2094 				; optimize OK (intro.pas), line = 153
  2095
  2096 159B A9 22 8D 00 D4		mva #$22 ATARI.DMACTL
  2097
  2098 				; optimize OK (intro.pas), line = 156
  2099
  2100 15A0 A9 00 8D 4E 1E		mva #$00 COUNT
  2101 15A5 8D 4F 1E			sta COUNT+1
  2102
  2103 				; --- RepeatUntilProlog
  2104 15A8			l_05C9
  2105
  2106 				; optimize FAIL (0, intro.pas), line = 158
  2107 15A8 EE 4E 1E D0 03 EE + 	inw COUNT
  2108
  2109 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 159
  2110 15B0 20 28 10			jsr B_SYSTEM.WAITFRAME
  2111
  2112 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 160
  2113 15B3 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2114 					.ifdef IFTMP_52
  2115 					lda :STACKORIGIN,x
  2116 					sta IFTMP_52
  2117 					eif
  2118 15B6 CA				dex
  2119 15B7 B5 99			lda :STACKORIGIN+1,x
  2120 15B9 D0 03			bne *+5
  2121 15BB 4C C3 15			jmp l_05D8
  2122
  2123 				; optimize OK (intro.pas), line = 160
  2124
  2125 15BE A9 01 8D 4C 1E		mva #$01 SKIP
  2126
  2127 				; IfThenEpilog
  2128 15C3			l_05D8
  2129
  2130 				; optimize OK (intro.pas), line = 161
  2131
  2132 15C3 A0 01			ldy #1
  2133 15C5 AD 4F 1E			lda COUNT+1
  2134 15C8 C9 01			cmp #$01
  2135 15CA D0 05			bne @+
  2136 15CC AD 4E 1E			lda COUNT
  2137 15CF C9 2C			cmp #$2C
  2138 15D1			@
  2139 15D1 F0 02			seq
  2140 15D3 B0 01			bcs @+
  2141 15D5 88				dey
  2142 15D6			@
  2143 15D6 84 A2			sty :STACKORIGIN+10
  2144 15D8 AD 4C 1E			lda SKIP
  2145 15DB 05 A2			ora :STACKORIGIN+10
  2146 15DD D0 03			bne *+5
  2147 15DF			c_05C9
  2148 15DF 4C A8 15			jmp l_05C9
  2149 15E2			b_05C9
  2150
  2151 				; optimize OK (intro.pas), line = 163
  2152
  2153 15E2 A0 01			ldy #1
  2154 15E4 AD 4C 1E			lda SKIP
  2155 15E7 F0 01			beq @+
  2156 15E9 88				dey
  2157 15EA			@
  2158 					.ifdef IFTMP_53
  2159 					sty IFTMP_53
  2160 					eif
  2161 15EA 98				tya
  2162 15EB D0 03			bne *+5
  2163 15ED 4C 10 16			jmp l_0603
  2164
  2165 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 164
  2166 15F0 20 99 12			jsr GFX_FADEOUT
  2167
  2168 				; optimize FAIL ('PUTSTRING', intro.pas), line = 165
  2169 15F3 E8				inx
  2170 15F4 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2171 15F8 E8				inx
  2172 15F9 A9 14 95 98			mva #$14 :STACKORIGIN,x
  2173 15FD E8				inx
  2174 15FE A0 00			ldy #$00 
  2175 1600 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2176 1605 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2177 160A 20 65 14			jsr PUTSTRING
  2178
  2179 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 166
  2180 160D 20 84 11			jsr GFX_FADEIN
  2181
  2182 				; IfThenEpilog
  2183 1610			l_0603
  2184
  2185 				; optimize OK (intro.pas), line = 169
  2186
  2187 1610 A9 00 8D 4E 1E		mva #$00 COUNT
  2188 1615 8D 4F 1E			sta COUNT+1
  2189
  2190 				; --- RepeatUntilProlog
  2191 1618			l_0613
  2192
  2193 				; optimize FAIL (0, intro.pas), line = 171
  2194 1618 EE 4E 1E D0 03 EE + 	inw COUNT
  2195
  2196 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 172
  2197 1620 20 28 10			jsr B_SYSTEM.WAITFRAME
  2198
  2199 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 173
  2200 1623 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2201 					.ifdef IFTMP_54
  2202 					lda :STACKORIGIN,x
  2203 					sta IFTMP_54
  2204 					eif
  2205 1626 CA				dex
  2206 1627 B5 99			lda :STACKORIGIN+1,x
  2207 1629 D0 03			bne *+5
  2208 162B 4C 33 16			jmp l_0622
  2209
  2210 				; optimize OK (intro.pas), line = 173
  2211
  2212 162E A9 01 8D 4C 1E		mva #$01 SKIP
  2213
  2214 				; IfThenEpilog
  2215 1633			l_0622
  2216
  2217 				; optimize OK (intro.pas), line = 174
  2218
  2219 1633 A0 01			ldy #1
  2220 1635 AD 4F 1E			lda COUNT+1
  2221 1638 C9 01			cmp #$01
  2222 163A D0 05			bne @+
  2223 163C AD 4E 1E			lda COUNT
  2224 163F C9 C2			cmp #$C2
  2225 1641			@
  2226 1641 F0 02			seq
  2227 1643 B0 01			bcs @+
  2228 1645 88				dey
  2229 1646			@
  2230 1646 84 A2			sty :STACKORIGIN+10
  2231 1648 AD 4C 1E			lda SKIP
  2232 164B 05 A2			ora :STACKORIGIN+10
  2233 164D D0 03			bne *+5
  2234 164F			c_0613
  2235 164F 4C 18 16			jmp l_0613
  2236 1652			b_0613
  2237
  2238 				; optimize OK (intro.pas), line = 177
  2239
  2240 1652 A0 01			ldy #1
  2241 1654 AD 4C 1E			lda SKIP
  2242 1657 F0 01			beq @+
  2243 1659 88				dey
  2244 165A			@
  2245 					.ifdef IFTMP_55
  2246 					sty IFTMP_55
  2247 					eif
  2248 165A 98				tya
  2249 165B D0 03			bne *+5
  2250 165D 4C 9A 16			jmp l_064D
  2251
  2252 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 178
  2253 1660 20 99 12			jsr GFX_FADEOUT
  2254
  2255 				; optimize FAIL ('PUTSTRING', intro.pas), line = 181
  2256 1663 E8				inx
  2257 1664 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2258 1668 E8				inx
  2259 1669 A9 14 95 98			mva #$14 :STACKORIGIN,x
  2260 166D E8				inx
  2261 166E A0 02			ldy #$02 
  2262 1670 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2263 1675 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2264 167A 20 65 14			jsr PUTSTRING
  2265
  2266 				; optimize FAIL ('PUTSTRING', intro.pas), line = 182
  2267 167D E8				inx
  2268 167E A9 00 95 98			mva #$00 :STACKORIGIN,x
  2269 1682 E8				inx
  2270 1683 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2271 1687 E8				inx
  2272 1688 A0 04			ldy #$04 
  2273 168A B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2274 168F B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2275 1694 20 65 14			jsr PUTSTRING
  2276
  2277 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 183
  2278 1697 20 84 11			jsr GFX_FADEIN
  2279
  2280 				; IfThenEpilog
  2281 169A			l_064D
  2282
  2283 				; optimize OK (intro.pas), line = 186
  2284
  2285 169A A9 00 8D 4E 1E		mva #$00 COUNT
  2286 169F 8D 4F 1E			sta COUNT+1
  2287
  2288 				; --- RepeatUntilProlog
  2289 16A2			l_0663
  2290
  2291 				; optimize FAIL (0, intro.pas), line = 188
  2292 16A2 EE 4E 1E D0 03 EE + 	inw COUNT
  2293
  2294 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 189
  2295 16AA 20 28 10			jsr B_SYSTEM.WAITFRAME
  2296
  2297 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 190
  2298 16AD 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2299 					.ifdef IFTMP_56
  2300 					lda :STACKORIGIN,x
  2301 					sta IFTMP_56
  2302 					eif
  2303 16B0 CA				dex
  2304 16B1 B5 99			lda :STACKORIGIN+1,x
  2305 16B3 D0 03			bne *+5
  2306 16B5 4C BD 16			jmp l_0672
  2307
  2308 				; optimize OK (intro.pas), line = 190
  2309
  2310 16B8 A9 01 8D 4C 1E		mva #$01 SKIP
  2311
  2312 				; IfThenEpilog
  2313 16BD			l_0672
  2314
  2315 				; optimize OK (intro.pas), line = 191
  2316
  2317 16BD A0 01			ldy #1
  2318 16BF AD 4F 1E			lda COUNT+1
  2319 16C2 C9 01			cmp #$01
  2320 16C4 D0 05			bne @+
  2321 16C6 AD 4E 1E			lda COUNT
  2322 16C9 C9 C2			cmp #$C2
  2323 16CB			@
  2324 16CB F0 02			seq
  2325 16CD B0 01			bcs @+
  2326 16CF 88				dey
  2327 16D0			@
  2328 16D0 84 A2			sty :STACKORIGIN+10
  2329 16D2 AD 4C 1E			lda SKIP
  2330 16D5 05 A2			ora :STACKORIGIN+10
  2331 16D7 D0 03			bne *+5
  2332 16D9			c_0663
  2333 16D9 4C A2 16			jmp l_0663
  2334 16DC			b_0663
  2335
  2336 				; optimize OK (intro.pas), line = 193
  2337
  2338 16DC A0 01			ldy #1
  2339 16DE AD 4C 1E			lda SKIP
  2340 16E1 F0 01			beq @+
  2341 16E3 88				dey
  2342 16E4			@
  2343 					.ifdef IFTMP_57
  2344 					sty IFTMP_57
  2345 					eif
  2346 16E4 98				tya
  2347 16E5 D0 03			bne *+5
  2348 16E7 4C 81 17			jmp l_069D
  2349
  2350 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 194
  2351 16EA 20 99 12			jsr GFX_FADEOUT
  2352
  2353 				; optimize OK (intro.pas), line = 195
  2354
  2355 16ED A9 AC			lda #$AC
  2356 16EF 85 86			sta :edx
  2357 16F1 A9 36			lda #$36
  2358 16F3 85 87			sta :edx+1
  2359 16F5 A9 10			lda #$10
  2360 16F7 85 8A			sta :ecx
  2361 16F9 A9 B0			lda #$B0
  2362 16FB 85 8B			sta :ecx+1
  2363 16FD A9 04			lda #$04
  2364 16FF 85 82			sta :eax
  2365 1701 A9 1E			lda #$1E
  2366 1703 85 83			sta :eax+1
  2367 1705 20 69 1D			jsr @move
  2368
  2369 				; optimize OK (intro.pas), line = 200
  2370
  2371 1708 A9 C0 8D 4A 1E		mva #$C0 LINE
  2372 170D A9 C8 8D 4B 1E		mva #$C8 LINE+1
  2373
  2374 				; optimize OK (intro.pas), line = 201
  2375
  2376 1712 AD 4A 1E			lda LINE
  2377 1715 85 86			sta :edx
  2378 1717 AD 4B 1E			lda LINE+1
  2379 171A 85 87			sta :edx+1
  2380 171C A9 50			lda #$50
  2381 171E 85 8A			sta :ecx
  2382 1720 A9 00			lda #$00
  2383 1722 85 8B			sta :ecx+1
  2384 1724 85 82			sta :eax
  2385 1726 20 BE 1D			jsr @fill
  2386
  2387 				; optimize FAIL ('PUTSTRING', intro.pas), line = 202
  2388 1729 E8				inx
  2389 172A A9 00 95 98			mva #$00 :STACKORIGIN,x
  2390 172E E8				inx
  2391 172F A9 14 95 98			mva #$14 :STACKORIGIN,x
  2392 1733 E8				inx
  2393 1734 A0 06			ldy #$06 
  2394 1736 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2395 173B B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2396 1740 20 65 14			jsr PUTSTRING
  2397
  2398 				; optimize FAIL ('PUTSTRING', intro.pas), line = 203
  2399 1743 E8				inx
  2400 1744 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2401 1748 E8				inx
  2402 1749 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2403 174D E8				inx
  2404 174E A0 08			ldy #$08 
  2405 1750 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2406 1755 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2407 175A 20 65 14			jsr PUTSTRING
  2408
  2409 				; optimize OK (intro.pas), line = 204
  2410
  2411 175D A9 90 8D 4A 1E		mva #$90 LINE
  2412 1762 A9 CB 8D 4B 1E		mva #$CB LINE+1
  2413
  2414 				; optimize OK (intro.pas), line = 205
  2415
  2416 1767 AD 4A 1E			lda LINE
  2417 176A 85 86			sta :edx
  2418 176C AD 4B 1E			lda LINE+1
  2419 176F 85 87			sta :edx+1
  2420 1771 A9 50			lda #$50
  2421 1773 85 8A			sta :ecx
  2422 1775 A9 00			lda #$00
  2423 1777 85 8B			sta :ecx+1
  2424 1779 85 82			sta :eax
  2425 177B 20 BE 1D			jsr @fill
  2426
  2427 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 206
  2428 177E 20 84 11			jsr GFX_FADEIN
  2429
  2430 				; IfThenEpilog
  2431 1781			l_069D
  2432
  2433 				; optimize OK (intro.pas), line = 209
  2434
  2435 1781 A9 00 8D 4E 1E		mva #$00 COUNT
  2436 1786 8D 4F 1E			sta COUNT+1
  2437
  2438 				; --- RepeatUntilProlog
  2439 1789			l_06C9
  2440
  2441 				; optimize FAIL (0, intro.pas), line = 211
  2442 1789 EE 4E 1E D0 03 EE + 	inw COUNT
  2443
  2444 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 212
  2445 1791 20 28 10			jsr B_SYSTEM.WAITFRAME
  2446
  2447 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 213
  2448 1794 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2449 					.ifdef IFTMP_58
  2450 					lda :STACKORIGIN,x
  2451 					sta IFTMP_58
  2452 					eif
  2453 1797 CA				dex
  2454 1798 B5 99			lda :STACKORIGIN+1,x
  2455 179A D0 03			bne *+5
  2456 179C 4C A4 17			jmp l_06D8
  2457
  2458 				; optimize OK (intro.pas), line = 213
  2459
  2460 179F A9 01 8D 4C 1E		mva #$01 SKIP
  2461
  2462 				; IfThenEpilog
  2463 17A4			l_06D8
  2464
  2465 				; optimize OK (intro.pas), line = 214
  2466
  2467 17A4 A0 01			ldy #1
  2468 17A6 AD 4F 1E			lda COUNT+1
  2469 17A9 C9 01			cmp #$01
  2470 17AB D0 05			bne @+
  2471 17AD AD 4E 1E			lda COUNT
  2472 17B0 C9 C2			cmp #$C2
  2473 17B2			@
  2474 17B2 F0 02			seq
  2475 17B4 B0 01			bcs @+
  2476 17B6 88				dey
  2477 17B7			@
  2478 17B7 84 A2			sty :STACKORIGIN+10
  2479 17B9 AD 4C 1E			lda SKIP
  2480 17BC 05 A2			ora :STACKORIGIN+10
  2481 17BE D0 03			bne *+5
  2482 17C0			c_06C9
  2483 17C0 4C 89 17			jmp l_06C9
  2484 17C3			b_06C9
  2485
  2486 				; optimize OK (intro.pas), line = 216
  2487
  2488 17C3 A0 01			ldy #1
  2489 17C5 AD 4C 1E			lda SKIP
  2490 17C8 F0 01			beq @+
  2491 17CA 88				dey
  2492 17CB			@
  2493 					.ifdef IFTMP_59
  2494 					sty IFTMP_59
  2495 					eif
  2496 17CB 98				tya
  2497 17CC D0 03			bne *+5
  2498 17CE 4C 47 18			jmp l_0703
  2499
  2500 				; optimize OK (intro.pas), line = 219
  2501
  2502 17D1 A9 C0 8D 4A 1E		mva #$C0 LINE
  2503 17D6 A9 C8 8D 4B 1E		mva #$C8 LINE+1
  2504
  2505 				; optimize OK (intro.pas), line = 220
  2506
  2507 17DB AD 4A 1E			lda LINE
  2508 17DE 85 86			sta :edx
  2509 17E0 AD 4B 1E			lda LINE+1
  2510 17E3 85 87			sta :edx+1
  2511 17E5 A9 50			lda #$50
  2512 17E7 85 8A			sta :ecx
  2513 17E9 A9 00			lda #$00
  2514 17EB 85 8B			sta :ecx+1
  2515 17ED 85 82			sta :eax
  2516 17EF 20 BE 1D			jsr @fill
  2517
  2518 				; optimize FAIL ('PUTSTRING', intro.pas), line = 221
  2519 17F2 E8				inx
  2520 17F3 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2521 17F7 E8				inx
  2522 17F8 A9 14 95 98			mva #$14 :STACKORIGIN,x
  2523 17FC E8				inx
  2524 17FD A0 0A			ldy #$0A 
  2525 17FF B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2526 1804 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2527 1809 20 65 14			jsr PUTSTRING
  2528
  2529 				; optimize FAIL ('PUTSTRING', intro.pas), line = 222
  2530 180C E8				inx
  2531 180D A9 00 95 98			mva #$00 :STACKORIGIN,x
  2532 1811 E8				inx
  2533 1812 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2534 1816 E8				inx
  2535 1817 A0 0C			ldy #$0C 
  2536 1819 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2537 181E B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2538 1823 20 65 14			jsr PUTSTRING
  2539
  2540 				; optimize OK (intro.pas), line = 223
  2541
  2542 1826 A9 90 8D 4A 1E		mva #$90 LINE
  2543 182B A9 CB 8D 4B 1E		mva #$CB LINE+1
  2544
  2545 				; optimize OK (intro.pas), line = 224
  2546
  2547 1830 AD 4A 1E			lda LINE
  2548 1833 85 86			sta :edx
  2549 1835 AD 4B 1E			lda LINE+1
  2550 1838 85 87			sta :edx+1
  2551 183A A9 50			lda #$50
  2552 183C 85 8A			sta :ecx
  2553 183E A9 00			lda #$00
  2554 1840 85 8B			sta :ecx+1
  2555 1842 85 82			sta :eax
  2556 1844 20 BE 1D			jsr @fill
  2557
  2558 				; IfThenEpilog
  2559 1847			l_0703
  2560
  2561 				; optimize OK (intro.pas), line = 227
  2562
  2563 1847 A9 00 8D 4E 1E		mva #$00 COUNT
  2564 184C 8D 4F 1E			sta COUNT+1
  2565
  2566 				; --- RepeatUntilProlog
  2567 184F			l_0729
  2568
  2569 				; optimize FAIL (0, intro.pas), line = 229
  2570 184F EE 4E 1E D0 03 EE + 	inw COUNT
  2571
  2572 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 230
  2573 1857 20 28 10			jsr B_SYSTEM.WAITFRAME
  2574
  2575 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 231
  2576 185A 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2577 					.ifdef IFTMP_60
  2578 					lda :STACKORIGIN,x
  2579 					sta IFTMP_60
  2580 					eif
  2581 185D CA				dex
  2582 185E B5 99			lda :STACKORIGIN+1,x
  2583 1860 D0 03			bne *+5
  2584 1862 4C 6A 18			jmp l_0738
  2585
  2586 				; optimize OK (intro.pas), line = 231
  2587
  2588 1865 A9 01 8D 4C 1E		mva #$01 SKIP
  2589
  2590 				; IfThenEpilog
  2591 186A			l_0738
  2592
  2593 				; optimize OK (intro.pas), line = 232
  2594
  2595 186A A0 01			ldy #1
  2596 186C AD 4F 1E			lda COUNT+1
  2597 186F C9 01			cmp #$01
  2598 1871 D0 05			bne @+
  2599 1873 AD 4E 1E			lda COUNT
  2600 1876 C9 C2			cmp #$C2
  2601 1878			@
  2602 1878 F0 02			seq
  2603 187A B0 01			bcs @+
  2604 187C 88				dey
  2605 187D			@
  2606 187D 84 A2			sty :STACKORIGIN+10
  2607 187F AD 4C 1E			lda SKIP
  2608 1882 05 A2			ora :STACKORIGIN+10
  2609 1884 D0 03			bne *+5
  2610 1886			c_0729
  2611 1886 4C 4F 18			jmp l_0729
  2612 1889			b_0729
  2613
  2614 				; optimize OK (intro.pas), line = 234
  2615
  2616 1889 A0 01			ldy #1
  2617 188B AD 4C 1E			lda SKIP
  2618 188E F0 01			beq @+
  2619 1890 88				dey
  2620 1891			@
  2621 					.ifdef IFTMP_61
  2622 					sty IFTMP_61
  2623 					eif
  2624 1891 98				tya
  2625 1892 D0 03			bne *+5
  2626 1894 4C 2E 19			jmp l_0763
  2627
  2628 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 235
  2629 1897 20 99 12			jsr GFX_FADEOUT
  2630
  2631 				; optimize OK (intro.pas), line = 236
  2632
  2633 189A A9 B0			lda #$B0
  2634 189C 85 86			sta :edx
  2635 189E A9 54			lda #$54
  2636 18A0 85 87			sta :edx+1
  2637 18A2 A9 10			lda #$10
  2638 18A4 85 8A			sta :ecx
  2639 18A6 A9 B0			lda #$B0
  2640 18A8 85 8B			sta :ecx+1
  2641 18AA A9 04			lda #$04
  2642 18AC 85 82			sta :eax
  2643 18AE A9 1E			lda #$1E
  2644 18B0 85 83			sta :eax+1
  2645 18B2 20 69 1D			jsr @move
  2646
  2647 				; optimize OK (intro.pas), line = 239
  2648
  2649 18B5 A9 C0 8D 4A 1E		mva #$C0 LINE
  2650 18BA A9 C8 8D 4B 1E		mva #$C8 LINE+1
  2651
  2652 				; optimize OK (intro.pas), line = 240
  2653
  2654 18BF AD 4A 1E			lda LINE
  2655 18C2 85 86			sta :edx
  2656 18C4 AD 4B 1E			lda LINE+1
  2657 18C7 85 87			sta :edx+1
  2658 18C9 A9 50			lda #$50
  2659 18CB 85 8A			sta :ecx
  2660 18CD A9 00			lda #$00
  2661 18CF 85 8B			sta :ecx+1
  2662 18D1 85 82			sta :eax
  2663 18D3 20 BE 1D			jsr @fill
  2664
  2665 				; optimize FAIL ('PUTSTRING', intro.pas), line = 241
  2666 18D6 E8				inx
  2667 18D7 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2668 18DB E8				inx
  2669 18DC A9 14 95 98			mva #$14 :STACKORIGIN,x
  2670 18E0 E8				inx
  2671 18E1 A0 0E			ldy #$0E 
  2672 18E3 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2673 18E8 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2674 18ED 20 65 14			jsr PUTSTRING
  2675
  2676 				; optimize FAIL ('PUTSTRING', intro.pas), line = 242
  2677 18F0 E8				inx
  2678 18F1 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2679 18F5 E8				inx
  2680 18F6 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2681 18FA E8				inx
  2682 18FB A0 10			ldy #$10 
  2683 18FD B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2684 1902 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2685 1907 20 65 14			jsr PUTSTRING
  2686
  2687 				; optimize OK (intro.pas), line = 243
  2688
  2689 190A A9 90 8D 4A 1E		mva #$90 LINE
  2690 190F A9 CB 8D 4B 1E		mva #$CB LINE+1
  2691
  2692 				; optimize OK (intro.pas), line = 244
  2693
  2694 1914 AD 4A 1E			lda LINE
  2695 1917 85 86			sta :edx
  2696 1919 AD 4B 1E			lda LINE+1
  2697 191C 85 87			sta :edx+1
  2698 191E A9 50			lda #$50
  2699 1920 85 8A			sta :ecx
  2700 1922 A9 00			lda #$00
  2701 1924 85 8B			sta :ecx+1
  2702 1926 85 82			sta :eax
  2703 1928 20 BE 1D			jsr @fill
  2704
  2705 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 245
  2706 192B 20 84 11			jsr GFX_FADEIN
  2707
  2708 				; IfThenEpilog
  2709 192E			l_0763
  2710
  2711 				; optimize OK (intro.pas), line = 247
  2712
  2713 192E A9 00 8D 4E 1E		mva #$00 COUNT
  2714 1933 8D 4F 1E			sta COUNT+1
  2715
  2716 				; --- RepeatUntilProlog
  2717 1936			l_078F
  2718
  2719 				; optimize FAIL (0, intro.pas), line = 249
  2720 1936 EE 4E 1E D0 03 EE + 	inw COUNT
  2721
  2722 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 250
  2723 193E 20 28 10			jsr B_SYSTEM.WAITFRAME
  2724
  2725 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 251
  2726 1941 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2727 					.ifdef IFTMP_62
  2728 					lda :STACKORIGIN,x
  2729 					sta IFTMP_62
  2730 					eif
  2731 1944 CA				dex
  2732 1945 B5 99			lda :STACKORIGIN+1,x
  2733 1947 D0 03			bne *+5
  2734 1949 4C 51 19			jmp l_079E
  2735
  2736 				; optimize OK (intro.pas), line = 251
  2737
  2738 194C A9 01 8D 4C 1E		mva #$01 SKIP
  2739
  2740 				; IfThenEpilog
  2741 1951			l_079E
  2742
  2743 				; optimize OK (intro.pas), line = 252
  2744
  2745 1951 A0 01			ldy #1
  2746 1953 AD 4C 1E			lda SKIP
  2747 1956 C9 01			cmp #$01
  2748 1958 F0 01			beq @+
  2749 195A 88				dey
  2750 195B			@
  2751 195B 84 A1			sty :STACKORIGIN+9
  2752 195D A0 01			ldy #1
  2753 195F AD 4F 1E			lda COUNT+1
  2754 1962 C9 01			cmp #$01
  2755 1964 D0 05			bne @+
  2756 1966 AD 4E 1E			lda COUNT
  2757 1969 C9 C2			cmp #$C2
  2758 196B			@
  2759 196B F0 02			seq
  2760 196D B0 01			bcs @+
  2761 196F 88				dey
  2762 1970			@
  2763 1970 98				tya
  2764 1971 05 A1			ora :STACKORIGIN+9
  2765 1973 D0 03			bne *+5
  2766 1975			c_078F
  2767 1975 4C 36 19			jmp l_078F
  2768 1978			b_078F
  2769
  2770 				; optimize OK (intro.pas), line = 254
  2771
  2772 1978 A0 01			ldy #1
  2773 197A AD 4C 1E			lda SKIP
  2774 197D F0 01			beq @+
  2775 197F 88				dey
  2776 1980			@
  2777 					.ifdef IFTMP_63
  2778 					sty IFTMP_63
  2779 					eif
  2780 1980 98				tya
  2781 1981 D0 03			bne *+5
  2782 1983 4C 16 1A			jmp l_07CF
  2783
  2784 				; optimize OK (intro.pas), line = 257
  2785
  2786 1986 A9 C0 8D 4A 1E		mva #$C0 LINE
  2787 198B A9 C8 8D 4B 1E		mva #$C8 LINE+1
  2788
  2789 				; optimize OK (intro.pas), line = 258
  2790
  2791 1990 AD 4A 1E			lda LINE
  2792 1993 85 86			sta :edx
  2793 1995 AD 4B 1E			lda LINE+1
  2794 1998 85 87			sta :edx+1
  2795 199A A9 50			lda #$50
  2796 199C 85 8A			sta :ecx
  2797 199E A9 00			lda #$00
  2798 19A0 85 8B			sta :ecx+1
  2799 19A2 85 82			sta :eax
  2800 19A4 20 BE 1D			jsr @fill
  2801
  2802 				; optimize FAIL ('PUTSTRING', intro.pas), line = 259
  2803 19A7 E8				inx
  2804 19A8 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2805 19AC E8				inx
  2806 19AD A9 14 95 98			mva #$14 :STACKORIGIN,x
  2807 19B1 E8				inx
  2808 19B2 A0 12			ldy #$12 
  2809 19B4 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2810 19B9 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2811 19BE 20 65 14			jsr PUTSTRING
  2812
  2813 				; optimize FAIL ('PUTSTRING', intro.pas), line = 260
  2814 19C1 E8				inx
  2815 19C2 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2816 19C6 E8				inx
  2817 19C7 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2818 19CB E8				inx
  2819 19CC A0 14			ldy #$14 
  2820 19CE B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2821 19D3 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2822 19D8 20 65 14			jsr PUTSTRING
  2823
  2824 				; optimize FAIL ('PUTSTRING', intro.pas), line = 261
  2825 19DB E8				inx
  2826 19DC A9 00 95 98			mva #$00 :STACKORIGIN,x
  2827 19E0 E8				inx
  2828 19E1 A9 16 95 98			mva #$16 :STACKORIGIN,x
  2829 19E5 E8				inx
  2830 19E6 A0 16			ldy #$16 
  2831 19E8 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2832 19ED B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2833 19F2 20 65 14			jsr PUTSTRING
  2834
  2835 				; optimize OK (intro.pas), line = 262
  2836
  2837 19F5 A9 D0 8D 4A 1E		mva #$D0 LINE
  2838 19FA A9 CC 8D 4B 1E		mva #$CC LINE+1
  2839
  2840 				; optimize OK (intro.pas), line = 263
  2841
  2842 19FF AD 4A 1E			lda LINE
  2843 1A02 85 86			sta :edx
  2844 1A04 AD 4B 1E			lda LINE+1
  2845 1A07 85 87			sta :edx+1
  2846 1A09 A9 50			lda #$50
  2847 1A0B 85 8A			sta :ecx
  2848 1A0D A9 00			lda #$00
  2849 1A0F 85 8B			sta :ecx+1
  2850 1A11 85 82			sta :eax
  2851 1A13 20 BE 1D			jsr @fill
  2852
  2853 				; IfThenEpilog
  2854 1A16			l_07CF
  2855
  2856 				; optimize OK (intro.pas), line = 266
  2857
  2858 1A16 A9 00 8D 4E 1E		mva #$00 COUNT
  2859 1A1B 8D 4F 1E			sta COUNT+1
  2860
  2861 				; --- RepeatUntilProlog
  2862 1A1E			l_07FB
  2863
  2864 				; optimize FAIL (0, intro.pas), line = 268
  2865 1A1E EE 4E 1E D0 03 EE + 	inw COUNT
  2866
  2867 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 269
  2868 1A26 20 28 10			jsr B_SYSTEM.WAITFRAME
  2869
  2870 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 270
  2871 1A29 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  2872 					.ifdef IFTMP_64
  2873 					lda :STACKORIGIN,x
  2874 					sta IFTMP_64
  2875 					eif
  2876 1A2C CA				dex
  2877 1A2D B5 99			lda :STACKORIGIN+1,x
  2878 1A2F D0 03			bne *+5
  2879 1A31 4C 39 1A			jmp l_080A
  2880
  2881 				; optimize OK (intro.pas), line = 270
  2882
  2883 1A34 A9 01 8D 4C 1E		mva #$01 SKIP
  2884
  2885 				; IfThenEpilog
  2886 1A39			l_080A
  2887
  2888 				; optimize OK (intro.pas), line = 271
  2889
  2890 1A39 A0 01			ldy #1
  2891 1A3B AD 4F 1E			lda COUNT+1
  2892 1A3E C9 01			cmp #$01
  2893 1A40 D0 05			bne @+
  2894 1A42 AD 4E 1E			lda COUNT
  2895 1A45 C9 C2			cmp #$C2
  2896 1A47			@
  2897 1A47 F0 02			seq
  2898 1A49 B0 01			bcs @+
  2899 1A4B 88				dey
  2900 1A4C			@
  2901 1A4C 84 A2			sty :STACKORIGIN+10
  2902 1A4E AD 4C 1E			lda SKIP
  2903 1A51 05 A2			ora :STACKORIGIN+10
  2904 1A53 D0 03			bne *+5
  2905 1A55			c_07FB
  2906 1A55 4C 1E 1A			jmp l_07FB
  2907 1A58			b_07FB
  2908
  2909 				; optimize OK (intro.pas), line = 273
  2910
  2911 1A58 A0 01			ldy #1
  2912 1A5A AD 4C 1E			lda SKIP
  2913 1A5D F0 01			beq @+
  2914 1A5F 88				dey
  2915 1A60			@
  2916 					.ifdef IFTMP_65
  2917 					sty IFTMP_65
  2918 					eif
  2919 1A60 98				tya
  2920 1A61 D0 03			bne *+5
  2921 1A63 4C FD 1A			jmp l_0835
  2922
  2923 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 274
  2924 1A66 20 99 12			jsr GFX_FADEOUT
  2925
  2926 				; optimize OK (intro.pas), line = 275
  2927
  2928 1A69 A9 B4			lda #$B4
  2929 1A6B 85 86			sta :edx
  2930 1A6D A9 72			lda #$72
  2931 1A6F 85 87			sta :edx+1
  2932 1A71 A9 10			lda #$10
  2933 1A73 85 8A			sta :ecx
  2934 1A75 A9 B0			lda #$B0
  2935 1A77 85 8B			sta :ecx+1
  2936 1A79 A9 04			lda #$04
  2937 1A7B 85 82			sta :eax
  2938 1A7D A9 1E			lda #$1E
  2939 1A7F 85 83			sta :eax+1
  2940 1A81 20 69 1D			jsr @move
  2941
  2942 				; optimize OK (intro.pas), line = 278
  2943
  2944 1A84 A9 C0 8D 4A 1E		mva #$C0 LINE
  2945 1A89 A9 C8 8D 4B 1E		mva #$C8 LINE+1
  2946
  2947 				; optimize OK (intro.pas), line = 279
  2948
  2949 1A8E AD 4A 1E			lda LINE
  2950 1A91 85 86			sta :edx
  2951 1A93 AD 4B 1E			lda LINE+1
  2952 1A96 85 87			sta :edx+1
  2953 1A98 A9 50			lda #$50
  2954 1A9A 85 8A			sta :ecx
  2955 1A9C A9 00			lda #$00
  2956 1A9E 85 8B			sta :ecx+1
  2957 1AA0 85 82			sta :eax
  2958 1AA2 20 BE 1D			jsr @fill
  2959
  2960 				; optimize FAIL ('PUTSTRING', intro.pas), line = 280
  2961 1AA5 E8				inx
  2962 1AA6 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2963 1AAA E8				inx
  2964 1AAB A9 14 95 98			mva #$14 :STACKORIGIN,x
  2965 1AAF E8				inx
  2966 1AB0 A0 18			ldy #$18 
  2967 1AB2 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2968 1AB7 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2969 1ABC 20 65 14			jsr PUTSTRING
  2970
  2971 				; optimize FAIL ('PUTSTRING', intro.pas), line = 281
  2972 1ABF E8				inx
  2973 1AC0 A9 00 95 98			mva #$00 :STACKORIGIN,x
  2974 1AC4 E8				inx
  2975 1AC5 A9 15 95 98			mva #$15 :STACKORIGIN,x
  2976 1AC9 E8				inx
  2977 1ACA A0 1A			ldy #$1A 
  2978 1ACC B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  2979 1AD1 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  2980 1AD6 20 65 14			jsr PUTSTRING
  2981
  2982 				; optimize OK (intro.pas), line = 282
  2983
  2984 1AD9 A9 90 8D 4A 1E		mva #$90 LINE
  2985 1ADE A9 CB 8D 4B 1E		mva #$CB LINE+1
  2986
  2987 				; optimize OK (intro.pas), line = 283
  2988
  2989 1AE3 AD 4A 1E			lda LINE
  2990 1AE6 85 86			sta :edx
  2991 1AE8 AD 4B 1E			lda LINE+1
  2992 1AEB 85 87			sta :edx+1
  2993 1AED A9 50			lda #$50
  2994 1AEF 85 8A			sta :ecx
  2995 1AF1 A9 00			lda #$00
  2996 1AF3 85 8B			sta :ecx+1
  2997 1AF5 85 82			sta :eax
  2998 1AF7 20 BE 1D			jsr @fill
  2999
  3000 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 284
  3001 1AFA 20 84 11			jsr GFX_FADEIN
  3002
  3003 				; IfThenEpilog
  3004 1AFD			l_0835
  3005
  3006 				; optimize OK (intro.pas), line = 287
  3007
  3008 1AFD A9 00 8D 4E 1E		mva #$00 COUNT
  3009 1B02 8D 4F 1E			sta COUNT+1
  3010
  3011 				; --- RepeatUntilProlog
  3012 1B05			l_0861
  3013
  3014 				; optimize FAIL (0, intro.pas), line = 289
  3015 1B05 EE 4E 1E D0 03 EE + 	inw COUNT
  3016
  3017 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 290
  3018 1B0D 20 28 10			jsr B_SYSTEM.WAITFRAME
  3019
  3020 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 291
  3021 1B10 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  3022 					.ifdef IFTMP_66
  3023 					lda :STACKORIGIN,x
  3024 					sta IFTMP_66
  3025 					eif
  3026 1B13 CA				dex
  3027 1B14 B5 99			lda :STACKORIGIN+1,x
  3028 1B16 D0 03			bne *+5
  3029 1B18 4C 20 1B			jmp l_0870
  3030
  3031 				; optimize OK (intro.pas), line = 291
  3032
  3033 1B1B A9 01 8D 4C 1E		mva #$01 SKIP
  3034
  3035 				; IfThenEpilog
  3036 1B20			l_0870
  3037
  3038 				; optimize OK (intro.pas), line = 292
  3039
  3040 1B20 A0 01			ldy #1
  3041 1B22 AD 4F 1E			lda COUNT+1
  3042 1B25 C9 01			cmp #$01
  3043 1B27 D0 05			bne @+
  3044 1B29 AD 4E 1E			lda COUNT
  3045 1B2C C9 C2			cmp #$C2
  3046 1B2E			@
  3047 1B2E F0 02			seq
  3048 1B30 B0 01			bcs @+
  3049 1B32 88				dey
  3050 1B33			@
  3051 1B33 84 A2			sty :STACKORIGIN+10
  3052 1B35 AD 4C 1E			lda SKIP
  3053 1B38 05 A2			ora :STACKORIGIN+10
  3054 1B3A D0 03			bne *+5
  3055 1B3C			c_0861
  3056 1B3C 4C 05 1B			jmp l_0861
  3057 1B3F			b_0861
  3058
  3059 				; optimize OK (intro.pas), line = 294
  3060
  3061 1B3F A0 01			ldy #1
  3062 1B41 AD 4C 1E			lda SKIP
  3063 1B44 F0 01			beq @+
  3064 1B46 88				dey
  3065 1B47			@
  3066 					.ifdef IFTMP_67
  3067 					sty IFTMP_67
  3068 					eif
  3069 1B47 98				tya
  3070 1B48 D0 03			bne *+5
  3071 1B4A 4C DD 1B			jmp l_089B
  3072
  3073 				; optimize OK (intro.pas), line = 297
  3074
  3075 1B4D A9 C0 8D 4A 1E		mva #$C0 LINE
  3076 1B52 A9 C8 8D 4B 1E		mva #$C8 LINE+1
  3077
  3078 				; optimize OK (intro.pas), line = 298
  3079
  3080 1B57 AD 4A 1E			lda LINE
  3081 1B5A 85 86			sta :edx
  3082 1B5C AD 4B 1E			lda LINE+1
  3083 1B5F 85 87			sta :edx+1
  3084 1B61 A9 50			lda #$50
  3085 1B63 85 8A			sta :ecx
  3086 1B65 A9 00			lda #$00
  3087 1B67 85 8B			sta :ecx+1
  3088 1B69 85 82			sta :eax
  3089 1B6B 20 BE 1D			jsr @fill
  3090
  3091 				; optimize FAIL ('PUTSTRING', intro.pas), line = 299
  3092 1B6E E8				inx
  3093 1B6F A9 00 95 98			mva #$00 :STACKORIGIN,x
  3094 1B73 E8				inx
  3095 1B74 A9 14 95 98			mva #$14 :STACKORIGIN,x
  3096 1B78 E8				inx
  3097 1B79 A0 1C			ldy #$1C 
  3098 1B7B B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3099 1B80 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3100 1B85 20 65 14			jsr PUTSTRING
  3101
  3102 				; optimize FAIL ('PUTSTRING', intro.pas), line = 300
  3103 1B88 E8				inx
  3104 1B89 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3105 1B8D E8				inx
  3106 1B8E A9 15 95 98			mva #$15 :STACKORIGIN,x
  3107 1B92 E8				inx
  3108 1B93 A0 1E			ldy #$1E 
  3109 1B95 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3110 1B9A B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3111 1B9F 20 65 14			jsr PUTSTRING
  3112
  3113 				; optimize FAIL ('PUTSTRING', intro.pas), line = 301
  3114 1BA2 E8				inx
  3115 1BA3 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3116 1BA7 E8				inx
  3117 1BA8 A9 16 95 98			mva #$16 :STACKORIGIN,x
  3118 1BAC E8				inx
  3119 1BAD A0 20			ldy #$20 
  3120 1BAF B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3121 1BB4 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3122 1BB9 20 65 14			jsr PUTSTRING
  3123
  3124 				; optimize OK (intro.pas), line = 302
  3125
  3126 1BBC A9 D0 8D 4A 1E		mva #$D0 LINE
  3127 1BC1 A9 CC 8D 4B 1E		mva #$CC LINE+1
  3128
  3129 				; optimize OK (intro.pas), line = 303
  3130
  3131 1BC6 AD 4A 1E			lda LINE
  3132 1BC9 85 86			sta :edx
  3133 1BCB AD 4B 1E			lda LINE+1
  3134 1BCE 85 87			sta :edx+1
  3135 1BD0 A9 50			lda #$50
  3136 1BD2 85 8A			sta :ecx
  3137 1BD4 A9 00			lda #$00
  3138 1BD6 85 8B			sta :ecx+1
  3139 1BD8 85 82			sta :eax
  3140 1BDA 20 BE 1D			jsr @fill
  3141
  3142 				; IfThenEpilog
  3143 1BDD			l_089B
  3144
  3145 				; optimize OK (intro.pas), line = 306
  3146
  3147 1BDD A9 00 8D 4E 1E		mva #$00 COUNT
  3148 1BE2 8D 4F 1E			sta COUNT+1
  3149
  3150 				; --- RepeatUntilProlog
  3151 1BE5			l_08C7
  3152
  3153 				; optimize FAIL (0, intro.pas), line = 308
  3154 1BE5 EE 4E 1E D0 03 EE + 	inw COUNT
  3155
  3156 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 309
  3157 1BED 20 28 10			jsr B_SYSTEM.WAITFRAME
  3158
  3159 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 310
  3160 1BF0 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  3161 					.ifdef IFTMP_68
  3162 					lda :STACKORIGIN,x
  3163 					sta IFTMP_68
  3164 					eif
  3165 1BF3 CA				dex
  3166 1BF4 B5 99			lda :STACKORIGIN+1,x
  3167 1BF6 D0 03			bne *+5
  3168 1BF8 4C 00 1C			jmp l_08D6
  3169
  3170 				; optimize OK (intro.pas), line = 310
  3171
  3172 1BFB A9 01 8D 4C 1E		mva #$01 SKIP
  3173
  3174 				; IfThenEpilog
  3175 1C00			l_08D6
  3176
  3177 				; optimize OK (intro.pas), line = 311
  3178
  3179 1C00 A0 01			ldy #1
  3180 1C02 AD 4F 1E			lda COUNT+1
  3181 1C05 C9 01			cmp #$01
  3182 1C07 D0 05			bne @+
  3183 1C09 AD 4E 1E			lda COUNT
  3184 1C0C C9 C2			cmp #$C2
  3185 1C0E			@
  3186 1C0E F0 02			seq
  3187 1C10 B0 01			bcs @+
  3188 1C12 88				dey
  3189 1C13			@
  3190 1C13 84 A2			sty :STACKORIGIN+10
  3191 1C15 AD 4C 1E			lda SKIP
  3192 1C18 05 A2			ora :STACKORIGIN+10
  3193 1C1A D0 03			bne *+5
  3194 1C1C			c_08C7
  3195 1C1C 4C E5 1B			jmp l_08C7
  3196 1C1F			b_08C7
  3197
  3198 				; optimize OK (intro.pas), line = 313
  3199
  3200 1C1F A0 01			ldy #1
  3201 1C21 AD 4C 1E			lda SKIP
  3202 1C24 F0 01			beq @+
  3203 1C26 88				dey
  3204 1C27			@
  3205 					.ifdef IFTMP_69
  3206 					sty IFTMP_69
  3207 					eif
  3208 1C27 98				tya
  3209 1C28 D0 03			bne *+5
  3210 1C2A 4C 7E 1C			jmp l_0901
  3211
  3212 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 314
  3213 1C2D 20 99 12			jsr GFX_FADEOUT
  3214
  3215 				; optimize OK (intro.pas), line = 316
  3216
  3217 1C30 A9 10			lda #$10
  3218 1C32 85 86			sta :edx
  3219 1C34 A9 B0			lda #$B0
  3220 1C36 85 87			sta :edx+1
  3221 1C38 A9 04			lda #$04
  3222 1C3A 85 8A			sta :ecx
  3223 1C3C A9 1E			lda #$1E
  3224 1C3E 85 8B			sta :ecx+1
  3225 1C40 A9 00			lda #$00
  3226 1C42 85 82			sta :eax
  3227 1C44 20 BE 1D			jsr @fill
  3228
  3229 				; optimize FAIL ('PUTSTRING', intro.pas), line = 319
  3230 1C47 E8				inx
  3231 1C48 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3232 1C4C E8				inx
  3233 1C4D A9 14 95 98			mva #$14 :STACKORIGIN,x
  3234 1C51 E8				inx
  3235 1C52 A0 22			ldy #$22 
  3236 1C54 B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3237 1C59 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3238 1C5E 20 65 14			jsr PUTSTRING
  3239
  3240 				; optimize FAIL ('PUTSTRING', intro.pas), line = 320
  3241 1C61 E8				inx
  3242 1C62 A9 00 95 98			mva #$00 :STACKORIGIN,x
  3243 1C66 E8				inx
  3244 1C67 A9 15 95 98			mva #$15 :STACKORIGIN,x
  3245 1C6B E8				inx
  3246 1C6C A0 24			ldy #$24 
  3247 1C6E B9 50 1E 95 98		mva adr.STRINGS,y :STACKORIGIN,x
  3248 1C73 B9 51 1E 95 A8		mva adr.STRINGS+1,y :STACKORIGIN+STACKWIDTH,x
  3249 1C78 20 65 14			jsr PUTSTRING
  3250
  3251 				; optimize FAIL ('GFX_FADEIN', intro.pas), line = 321
  3252 1C7B 20 84 11			jsr GFX_FADEIN
  3253
  3254 				; IfThenEpilog
  3255 1C7E			l_0901
  3256
  3257 				; optimize OK (intro.pas), line = 324
  3258
  3259 1C7E A9 00 8D 4E 1E		mva #$00 COUNT
  3260 1C83 8D 4F 1E			sta COUNT+1
  3261
  3262 				; --- RepeatUntilProlog
  3263 1C86			l_091B
  3264
  3265 				; optimize FAIL (0, intro.pas), line = 326
  3266 1C86 EE 4E 1E D0 03 EE + 	inw COUNT
  3267
  3268 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 327
  3269 1C8E 20 28 10			jsr B_SYSTEM.WAITFRAME
  3270
  3271 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', intro.pas), line = 328
  3272 1C91 20 58 10			jsr B_CRT.CRT_KEYPRESSED
  3273 					.ifdef IFTMP_70
  3274 					lda :STACKORIGIN,x
  3275 					sta IFTMP_70
  3276 					eif
  3277 1C94 CA				dex
  3278 1C95 B5 99			lda :STACKORIGIN+1,x
  3279 1C97 D0 03			bne *+5
  3280 1C99 4C A1 1C			jmp l_092A
  3281
  3282 				; optimize OK (intro.pas), line = 328
  3283
  3284 1C9C A9 01 8D 4C 1E		mva #$01 SKIP
  3285
  3286 				; IfThenEpilog
  3287 1CA1			l_092A
  3288
  3289 				; optimize OK (intro.pas), line = 329
  3290
  3291 1CA1 A0 01			ldy #1
  3292 1CA3 AD 4F 1E			lda COUNT+1
  3293 1CA6 C9 01			cmp #$01
  3294 1CA8 D0 05			bne @+
  3295 1CAA AD 4E 1E			lda COUNT
  3296 1CAD C9 C2			cmp #$C2
  3297 1CAF			@
  3298 1CAF F0 02			seq
  3299 1CB1 B0 01			bcs @+
  3300 1CB3 88				dey
  3301 1CB4			@
  3302 1CB4 84 A2			sty :STACKORIGIN+10
  3303 1CB6 AD 4C 1E			lda SKIP
  3304 1CB9 05 A2			ora :STACKORIGIN+10
  3305 1CBB D0 03			bne *+5
  3306 1CBD			c_091B
  3307 1CBD 4C 86 1C			jmp l_091B
  3308 1CC0			b_091B
  3309
  3310 				; optimize FAIL ('GFX_FADEOUT', intro.pas), line = 331
  3311 1CC0 20 99 12			jsr GFX_FADEOUT
  3312
  3313 				; optimize OK (intro.pas), line = 332
  3314
  3315 1CC3 A9 00 8D 4D 1E		mva #$00 MUSIC
  3316
  3317 				; optimize FAIL ('B_SYSTEM.WAITFRAME', intro.pas), line = 333
  3318 1CC8 20 28 10			jsr B_SYSTEM.WAITFRAME
  3319
  3320 				; optimize FAIL ('CMC.TCMC.STOP', intro.pas), line = 334
  3321 1CCB AD FC 1C			lda MSX
  3322 1CCE AC FD 1C			ldy MSX+1
  3323 1CD1 20 04 11			jsr CMC.TCMC.STOP
  3324
  3325 				; optimize FAIL ('B_SYSTEM.DISABLEDLI', intro.pas), line = 335
  3326 1CD4 20 19 10			jsr B_SYSTEM.DISABLEDLI
  3327
  3328 				; optimize FAIL ('B_SYSTEM.DISABLEVBLI', intro.pas), line = 336
  3329 1CD7 20 CD 0F			jsr B_SYSTEM.DISABLEVBLI
  3330
  3331 				; optimize OK (intro.pas), line = 337
  3332
  3333 1CDA A9 00 8D 0E D4		mva #$00 ATARI.NMIEN
  3334
  3335 				; optimize OK (intro.pas), line = 338
  3336
  3337 1CDF 8D 00 D4			sta ATARI.DMACTL
  3338
  3339 				; ---------------------  ASM Block 081  ---------------------
  3340
  3341
  3342 1CE2 18			      clc
  3343 1CE3 60			      rts
  3344 				  
  3345
  3346 				; -----------------------------------------------------------
  3347
  3348 = 2000			FREE_TOP	= $2000
  3349 = 2000			DISPLAY_LIST_ADDRESS_TITLE	= $2000
  3350 = 2400			PLAYER_ADDRESS	= $2400
  3351 = 2C00			MODULE_ADDRESS	= $2C00
  3352 = 36AC			PIC1_ADDRESS	= $36AC
  3353 = 54B0			PIC2_ADDRESS	= $54B0
  3354 = 72B4			PIC3_ADDRESS	= $72B4
  3355 = B010			GFX_ADDRESS	= $B010
  3356 = E400			CHARSET_ADDRESS	= $E400
  3357 = 1E3E			adr.GFXCOLORS	= DATAORIGIN+$0038
  3358 1CE4			.var GFXCOLORS	= adr.GFXCOLORS .word
  3359 = 1E42			adr.PICCOLORS	= DATAORIGIN+$003C
  3360 1CE4			.var PICCOLORS	= adr.PICCOLORS .word
  3361 = 1E46			adr.MSX	= DATAORIGIN+$0040
  3362 1CE4			.var MSX	= adr.MSX .word
  3363 = 1E46			MSX.PLAYER	= DATAORIGIN+$0040
  3364 = 1E48			MSX.MODUL	= DATAORIGIN+$0042
  3365 = 1E4A			LINE	= DATAORIGIN+$0044
  3366 = 1E4C			SKIP	= DATAORIGIN+$0046
  3367 = 1E4D			MUSIC	= DATAORIGIN+$0047
  3368 = 1E4E			COUNT	= DATAORIGIN+$0048
  3369 = 1E50			adr.STRINGS	= DATAORIGIN+$004A
  3370 1CE4			.var STRINGS	= adr.STRINGS .word
  3371
  3372 1CE4			@exit
  3373
  3374 1CE4 A2 00		@halt	ldx #0
  3375 1CE6 9A				txs
  3376
  3377 1CE7 60				rts
  3378
  3379 1CE8 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  3380
  3381 1CF8			.local	@DEFINES
  3382 1CF8			ATARI
  3383 				.endl
  3384
  3385 = 1CF8 3E 1E		GFXCOLORS
  3385 = 1CFA 42 1E		PICCOLORS
  3385 = 1CFC 46 1E		MSX
  3385 = 1CFE 50 1E		STRINGS
  3385 				.endl
  3386
  3387 				; -----------------------------------------------------------
  3388
  3389 1D00				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   227 					opt l+
   228
   229 				/* ----------------------------------------------------------------------- */
   230
   231
   232 1D00			.proc	hiBYTE
   233 					lda :STACKORIGIN,x
   234 1D00				:4 lsr @
   235 					sta :STACKORIGIN,x
   236 					rts
   237 				.endp
   238
   239 1D00			.proc	hiWORD
   240 					lda :STACKORIGIN+STACKWIDTH,x
   241 					sta :STACKORIGIN,x
   242 					rts
   243 				.endp
   244
   245 1D00			.proc	hiCARD
   246 					lda :STACKORIGIN+STACKWIDTH*3,x
   247 					sta :STACKORIGIN+STACKWIDTH,x
   248
   249 					lda :STACKORIGIN+STACKWIDTH*2,x
   250 					sta :STACKORIGIN,x
   251 					rts
   252 				.endp
   253
   254
   255 1D00			.proc	movaBX_EAX		; mov [BX], EAX
   256 1D00				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   257 					rts
   258 				.endp
   259
   260 				/*
   261 				.proc	@pushBYTE
   262 					adc :STACKORIGIN+STACKWIDTH,x
   263 					sta bp+1
   264
   265 					mva (bp),y :STACKORIGIN,x
   266
   267 				;	lda #$00
   268 				;	sta :STACKORIGIN+STACKWIDTH,x
   269 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   270 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   271
   272 					rts
   273 				.endp
   274
   275
   276 				.proc	@pullWORD (.word ya) .reg
   277 					add :STACKORIGIN-1,x
   278 					sta bp2
   279 					tya
   280 					adc :STACKORIGIN-1+STACKWIDTH,x
   281 					sta bp2+1
   282
   283 					ldy #$00
   284
   285 					mva :STACKORIGIN,x (bp2),y
   286 					iny
   287 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   288
   289 					rts
   290 				.endp
   291
   292
   293 				.proc	@pullCARD (.word ya) .reg
   294 					add :STACKORIGIN-1,x
   295 					sta bp2
   296 					tya
   297 					adc :STACKORIGIN-1+STACKWIDTH,x
   298 					sta bp2+1
   299
   300 					ldy #$00
   301
   302 					mva :STACKORIGIN,x (bp2),y
   303 					iny
   304 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   305 					iny
   306 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   307 					iny
   308 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   309
   310 					rts
   311 				.endp
   312
   313
   314 				.proc	@pushWORD (.word ya) .reg
   315 					add :STACKORIGIN,x
   316 					sta bp2
   317 					tya
   318 					adc :STACKORIGIN+STACKWIDTH,x
   319 					sta bp2+1
   320
   321 					ldy #$00
   322
   323 					mva (bp2),y :STACKORIGIN,x
   324 					iny
   325 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   326
   327 					rts
   328 				.endp
   329
   330
   331 				.proc	@pushCARD (.word ya) .reg
   332 					add :STACKORIGIN,x
   333 					sta bp2
   334 					tya
   335 					adc :STACKORIGIN+STACKWIDTH,x
   336 					sta bp2+1
   337
   338 					ldy #$00
   339
   340 					mva (bp2),y :STACKORIGIN,x
   341 					iny
   342 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   343 					iny
   344 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   345 					iny
   346 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   347
   348 					rts
   349 				.endp
   350 				*/
   350
   351
   352 1D00			.proc	shlEAX_CL
   353
   354 				;SHORT	jsr @expandToCARD1.SHORT
   355 				;	jmp CARD
   356
   357 				;SMALL	jsr @expandToCARD1.SMALL
   358 				;	jmp CARD
   359
   360 1D00			BYTE	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH,x
   362
   363 1D00			WORD	lda #0
   364 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   365 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   366
   367 1D00			CARD	clc
   368 					ldy :STACKORIGIN,x	; cl
   369 					beq stop
   370 1D00			@	asl :STACKORIGIN-1,x	; eax
   371 					rol :STACKORIGIN-1+STACKWIDTH,x
   372 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   373 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   374 					dey
   375 					bne @-
   376
   377 1D00			stop	rts
   378 				.endp
   379
   380
   381 1D00			.proc	shrAL_CL
   382
   383 				;SHORT	jsr @expandToCARD1.SHORT
   384 				;	jmp shrEAX_CL
   385
   386 1D00 B4 98		BYTE	ldy :STACKORIGIN,x	; cl
   387 1D02 F0 05			beq stop
   388 1D04 56 97		@	lsr :STACKORIGIN-1,x
   389 1D06 88				dey
   390 1D07 D0 FB			bne @-
   391
   392 1D09 A9 00		stop	lda #0
   393 1D0B 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   394 1D0D 95 B7			sta :STACKORIGIN-1+STACKWIDTH*2,x
   395 1D0F 95 C7			sta :STACKORIGIN-1+STACKWIDTH*3,x
   396
   397 1D11 60				rts
   398 				.endp
   399
   400 1D12			.proc	shrAX_CL
   401
   402 				;SMALL	jsr @expandToCARD1.SMALL
   403 				;	jmp shrEAX_CL
   404
   405 1D12			WORD	ldy :STACKORIGIN,x	; cl
   406 					beq stop
   407 1D12			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   408 					ror :STACKORIGIN-1,x
   409 					dey
   410 					bne @-
   411
   412 1D12			stop	lda #0
   413 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   414 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   415
   416 					rts
   417 				.endp
   418
   419 1D12			.proc	shrEAX_CL
   420
   421 					ldy :STACKORIGIN,x	; cl
   422 					beq stop
   423 1D12			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   424 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   425 					ror :STACKORIGIN-1+STACKWIDTH,x
   426 					ror :STACKORIGIN-1,x
   427 					dey
   428 					bne @-
   429
   430 1D12			stop	rts
   431 				.endp
   432
   433 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   434 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   435 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   436
   437 1D12			.proc	addAL_CL
   438
   439 					ldy #0
   440
   441 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   442 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   443
   444 					lda :STACKORIGIN-1,x
   445 					add :STACKORIGIN,x
   446 					sta :STACKORIGIN-1,x
   447 					scc
   448 					iny
   449
   450 					sty :STACKORIGIN-1+STACKWIDTH,x
   451
   452 					rts
   453 				.endp
   454
   455 1D12			.proc	addAX_CX
   456
   457 					ldy #0
   458
   459 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   460
   461 					lda :STACKORIGIN-1,x
   462 					add :STACKORIGIN,x
   463 					sta :STACKORIGIN-1,x
   464
   465 					lda :STACKORIGIN-1+STACKWIDTH,x
   466 					adc :STACKORIGIN+STACKWIDTH,x
   467 					sta :STACKORIGIN-1+STACKWIDTH,x
   468 					scc
   469 					iny
   470
   471 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   472
   473 					rts
   474 				.endp
   475
   476
   477 1D12			.proc	addEAX_ECX
   478 				/*
   479 				SHORT	jsr @expandToCARD.SHORT
   480 					jsr @expandToCARD1.SHORT
   481 					jmp CARD
   482
   483 				SMALL	jsr @expandToCARD.SMALL
   484 					jsr @expandToCARD1.SMALL
   485 				*/
   485
   486 1D12			CARD	lda :STACKORIGIN-1,x
   487 					add :STACKORIGIN,x
   488 					sta :STACKORIGIN-1,x
   489
   490 					lda :STACKORIGIN-1+STACKWIDTH,x
   491 					adc :STACKORIGIN+STACKWIDTH,x
   492 					sta :STACKORIGIN-1+STACKWIDTH,x
   493
   494 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   495 					adc :STACKORIGIN+STACKWIDTH*2,x
   496 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   497
   498 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   499 					adc :STACKORIGIN+STACKWIDTH*3,x
   500 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   501
   502 					rts
   503 				.endp
   504
   505
   506 1D12			.proc	subAL_CL
   507
   508 					ldy #0
   509
   510 					lda :STACKORIGIN-1,x
   511 					sub :STACKORIGIN,x
   512 					sta :STACKORIGIN-1,x
   513 					scs
   514 					dey
   515
   516 					sty :STACKORIGIN-1+STACKWIDTH,x
   517 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   518 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   519
   520 					rts
   521 				.endp
   522
   523 1D12			.proc	subAX_CX
   524
   525 					ldy #0
   526
   527 					lda :STACKORIGIN-1,x		; ax
   528 					sub :STACKORIGIN,x		; cx
   529 					sta :STACKORIGIN-1,x
   530
   531 					lda :STACKORIGIN-1+STACKWIDTH,x
   532 					sbc :STACKORIGIN+STACKWIDTH,x
   533 					sta :STACKORIGIN-1+STACKWIDTH,x
   534 					scs
   535 					dey
   536
   537 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   538 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   539
   540 					rts
   541 				.endp
   542
   543 1D12			.proc	subEAX_ECX
   544
   545 					lda :STACKORIGIN-1,x
   546 					sub :STACKORIGIN,x
   547 					sta :STACKORIGIN-1,x
   548
   549 					lda :STACKORIGIN-1+STACKWIDTH,x
   550 					sbc :STACKORIGIN+STACKWIDTH,x
   551 					sta :STACKORIGIN-1+STACKWIDTH,x
   552
   553 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   554 					sbc :STACKORIGIN+STACKWIDTH*2,x
   555 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   556
   557 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   558 					sbc :STACKORIGIN+STACKWIDTH*3,x
   559 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   560
   561 					rts
   562 				.endp
   563
   564
   565 1D12			.proc	@expandSHORT2SMALL
   566 					ldy #$00
   567 					lda :STACKORIGIN,x
   568 					spl
   569 					dey
   570 					sty :STACKORIGIN+STACKWIDTH,x
   571
   572 					rts
   573 				.endp
   574
   575 1D12			.proc	@expandSHORT2SMALL1
   576 					ldy #$00
   577 					lda :STACKORIGIN-1,x
   578 					spl
   579 					dey
   580 					sty :STACKORIGIN-1+STACKWIDTH,x
   581
   582 					rts
   583 				.endp
   584
   585
   586 1D12			.proc	@expandToCARD
   587
   588 1D12			SMALL	lda :STACKORIGIN+STACKWIDTH,x
   589 					bpl WORD
   590
   591 					lda #$ff
   592 					bne _wo
   593
   594 1D12			WORD	lda #$00
   595 					beq _wo
   596
   597 1D12			SHORT	lda :STACKORIGIN,x
   598 					bpl BYTE
   599
   600 					lda #$ff
   601 					bne _by
   602
   603 1D12			BYTE	lda #$00
   604
   605 1D12			_by	sta :STACKORIGIN+STACKWIDTH,x
   606 1D12			_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   607 1D12			_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   608 					rts
   609 				.endp
   610
   611
   612 1D12			.proc	@expandToCARD1
   613
   614 1D12			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   615 					bpl WORD
   616
   617 					lda #$ff
   618 					bne _wo
   619
   620 1D12			WORD	lda #$00
   621 					beq _wo
   622
   623 1D12			SHORT	lda :STACKORIGIN-1,x
   624 					bpl BYTE
   625
   626 					lda #$ff
   627 					bne _by
   628
   629 1D12			BYTE	lda #$00
   630
   631 1D12			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   632 1D12			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   633 1D12			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   634 					rts
   635 				.endp
   636
   637 				/*
   638 				.proc	@cmpFor_WORD (.word ya) .reg
   639 					sta ztmp
   640 					sty ztmp+1
   641
   642 					ldy #1
   643 					lda (ztmp),y
   644 					cmp :STACKORIGIN+1+STACKWIDTH,x
   645 					bne stop
   646 					dey
   647 					lda (ztmp),y
   648 					cmp :STACKORIGIN+1,x
   649 				stop	rts
   650 				.endp
   651
   652
   653 				.proc	@cmpFor_CARD (.word ya) .reg
   654 					sta ztmp
   655 					sty ztmp+1
   656
   657 					ldy #3
   658 					lda (ztmp),y
   659 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   660 					bne stop
   661 					dey
   662 					lda (ztmp),y
   663 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   664 					bne stop
   665 					dey
   666 					lda (ztmp),y
   667 					cmp :STACKORIGIN+1+STACKWIDTH,x
   668 					bne stop
   669 					dey
   670 					lda (ztmp),y
   671 					cmp :STACKORIGIN+1,x
   672
   673 				stop	rts
   674 				.endp
   675
   676
   677 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   678 					sta ztmp
   679 					sty ztmp+1
   680
   681 					ldy	#0
   682 					lda	(ztmp),y
   683 					sec
   684 					sbc	:STACKORIGIN+1,x
   685 					bne	@cmpFor_INT.L4
   686
   687 					jmp	@cmpFor_INT.L1
   688 				.endp
   689
   690
   691 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   692 					sta ztmp
   693 					sty ztmp+1
   694
   695 					ldy	#1
   696 					lda	(ztmp),y
   697 					sec
   698 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   699 					bne	@cmpFor_INT.L4
   700
   701 					dey
   702 					lda	(ztmp),y
   703 					cmp	:STACKORIGIN+1,x
   704
   705 					jmp	@cmpFor_INT.L1
   706 				.endp
   707
   708
   709 				.proc	@cmpFor_INT(.word ya) .reg
   710 					sta ztmp
   711 					sty ztmp+1
   712
   713 					ldy	#3
   714 					lda	(ztmp),y
   715 					sec
   716 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   717 					bne	L4
   718
   719 					dey
   720 					lda	(ztmp),y
   721 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   722 					bne	L1
   723
   724 					dey
   725 					lda	(ztmp),y
   726 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   727 					bne	L1
   728
   729 					dey
   730 					lda	(ztmp),y
   731 					cmp	:STACKORIGIN+1,x
   732
   733 				L1	beq	L2
   734 					bcs	L3
   735
   736 					lda	#$FF	; Set the N flag
   737 				L2	rts
   738
   739 				L3	lda	#$01	; Clear the N flag
   740 					rts
   741
   742 				L4	bvc	L5
   743 					eor	#$FF	; Fix the N flag if overflow
   744 					ora	#$01	; Clear the Z flag
   745 				L5	rts
   746 				.endp
   747 				*/
   747
   748
   749 				; Piotr Fusik, 15.04.2002
   750 				; originally by Ullrich von Bassewitz
   751
   752 1D12			.proc	cmpSHORTINT
   753 					lda	:STACKORIGIN-1,x
   754 					clv:sec
   755 					sbc	:STACKORIGIN,x
   756 					bne	cmpINT.L4
   757
   758 					jmp	cmpINT.L1
   759 				.endp
   760
   761
   762 1D12			.proc	cmpSMALLINT
   763 					lda	:STACKORIGIN-1+STACKWIDTH,x
   764 					clv:sec
   765 					sbc	:STACKORIGIN+STACKWIDTH,x
   766 					bne	cmpINT.L4
   767
   768 					lda	:STACKORIGIN-1,x
   769 					cmp	:STACKORIGIN,x
   770
   771 					jmp	cmpINT.L1
   772 				.endp
   773
   774
   775 1D12			.proc	cmpINT
   776 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   777 					clv:sec
   778 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   779 					bne	L4
   780
   781 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   782 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   783 					bne	L1
   784
   785 					lda	:STACKORIGIN-1+STACKWIDTH,x
   786 					cmp	:STACKORIGIN+STACKWIDTH,x
   787 					bne	L1
   788
   789 					lda	:STACKORIGIN-1,x
   790 					cmp	:STACKORIGIN,x
   791
   792 1D12			L1	beq	L2
   793 					bcs	L3
   794
   795 					lda	#$FF	; Set the N flag
   796 1D12			L2	rts
   797
   798 1D12			L3	lda	#$01	; Clear the N flag
   799 					rts
   800
   801 1D12			L4	bvc	L5
   802 					eor	#$FF	; Fix the N flag if overflow
   803 					ora	#$01	; Clear the Z flag
   804 1D12			L5	rts
   805 				.endp
   806
   807
   808 1D12			.proc	cmpEAX_ECX
   809 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   810 					cmp :STACKORIGIN+STACKWIDTH*3,x
   811 					bne _done
   812 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   813 					cmp :STACKORIGIN+STACKWIDTH*2,x
   814 					bne _done
   815 1D12			AX_CX
   816 					lda :STACKORIGIN-1+STACKWIDTH,x
   817 					cmp :STACKORIGIN+STACKWIDTH,x
   818 					bne _done
   819 					lda :STACKORIGIN-1,x
   820 					cmp :STACKORIGIN,x
   821
   822 1D12			_done	rts
   823 				.endp
   824
   825
   826 1D12			.proc	cmpSTRING2CHAR
   827
   828 					lda :STACKORIGIN-1,x
   829 					sta ztmp8
   830 					lda :STACKORIGIN-1+STACKWIDTH,x
   831 					sta ztmp8+1
   832
   833 					lda :STACKORIGIN,x
   834 					sta ztmp10
   835
   836 					ldy #0
   837
   838 					lda (ztmp8),y		; if length <> 1
   839 					cmp #1
   840 					bne fail
   841
   842 					iny
   843
   844 1D12			loop	lda (ztmp8),y
   845 					cmp ztmp10
   846 					bne fail
   847
   848 					lda #0
   849 					seq
   850
   851 1D12			fail	lda #$ff
   852
   853 					ldy #1
   854
   855 					cmp #0
   856 					rts
   857 				.endp
   858
   859
   860
   861 1D12			.proc	cmpCHAR2STRING
   862
   863 					lda :STACKORIGIN-1,x
   864 					sta ztmp8
   865
   866 					lda :STACKORIGIN,x
   867 					sta ztmp10
   868 					lda :STACKORIGIN+STACKWIDTH,x
   869 					sta ztmp10+1
   870
   871 					ldy #0
   872
   873 					lda (ztmp10),y		; if length <> 1
   874 					cmp #1
   875 					bne fail
   876
   877 					iny
   878
   879 1D12			loop	lda (ztmp10),y
   880 					cmp ztmp8
   881 					bne fail
   882
   883 					lda #0
   884 					seq
   885
   886 1D12			fail	lda #$ff
   887
   888 					ldy #1
   889
   890 					cmp #0
   891 					rts
   892 				.endp
   893
   894
   895 1D12			.proc	cmpSTRING
   896
   897 					lda :STACKORIGIN-1,x
   898 					sta ztmp8
   899 					lda :STACKORIGIN-1+STACKWIDTH,x
   900 					sta ztmp8+1
   901
   902 					lda :STACKORIGIN,x
   903 					sta ztmp10
   904 					lda :STACKORIGIN+STACKWIDTH,x
   905 					sta ztmp10+1
   906
   907 					ldy #0
   908
   909 					lda (ztmp8),y		; if length1 = 0
   910 					beq fail
   911 					lda (ztmp10),y		; if length2 = 0
   912 					beq fail
   913
   914 					lda (ztmp8),y		; if length1 <> length2
   915 					cmp (ztmp10),y
   916 					bne fail
   917
   918 					sta max
   919
   920 					inw ztmp8
   921 					inw ztmp10
   922
   923 1D12			loop	lda (ztmp8),y
   924 					cmp (ztmp10),y
   925 					bne fail
   926
   927 					iny
   928
   929 					cpy #0
   930 1D12			max	equ *-1
   931 					bne loop
   932
   933 					lda #0
   934 					seq
   935
   936 1D12			fail	lda #$ff
   937
   938 					ldy #1
   939
   940 					cmp #0
   941 					rts
   942 				.endp
   943
   944
   945 1D12			.proc	notaBX
   946
   947 					.rept MAXSIZE
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   949 					EOR #$FF
   950 					STA :STACKORIGIN+#*STACKWIDTH,X
   951 					.ENDR
   951 					.endr
Source: REPT
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   952
   953 					rts
   954 				.endp
   955
   956
   957 1D12			.proc	notBOOLEAN
   958 					lda :STACKORIGIN,x
   959 					bne _0
   960
   961 					lda #true
   962 					sne
   963
   964 1D12			_0	lda #false
   965 					sta :STACKORIGIN,x
   966
   967 					rts
   968 				.endp
   969
   970
   971 1D12			.proc	negBYTE
   972 					lda #$00
   973 					sub :STACKORIGIN,x
   974 					sta :STACKORIGIN,x
   975
   976 					lda #$00
   977 					sbc #$00
   978 					sta :STACKORIGIN+STACKWIDTH,x
   979
   980 					lda #$00
   981 					sbc #$00
   982 					sta :STACKORIGIN+STACKWIDTH*2,x
   983
   984 					lda #$00
   985 					sbc #$00
   986 					sta :STACKORIGIN+STACKWIDTH*3,x
   987
   988 					rts
   989 				.endp
   990
   991 1D12			.proc	negWORD
   992 					lda #$00
   993 					sub :STACKORIGIN,x
   994 					sta :STACKORIGIN,x
   995
   996 					lda #$00
   997 					sbc :STACKORIGIN+STACKWIDTH,x
   998 					sta :STACKORIGIN+STACKWIDTH,x
   999
  1000 					lda #$00
  1001 					sbc #$00
  1002 					sta :STACKORIGIN+STACKWIDTH*2,x
  1003
  1004 					lda #$00
  1005 					sbc #$00
  1006 					sta :STACKORIGIN+STACKWIDTH*3,x
  1007
  1008 					rts
  1009 				.endp
  1010
  1011 1D12			.proc	negCARD
  1012 					lda #$00
  1013 					sub :STACKORIGIN,x
  1014 					sta :STACKORIGIN,x
  1015
  1016 					lda #$00
  1017 					sbc :STACKORIGIN+STACKWIDTH,x
  1018 					sta :STACKORIGIN+STACKWIDTH,x
  1019
  1020 					lda #$00
  1021 					sbc :STACKORIGIN+STACKWIDTH*2,x
  1022 					sta :STACKORIGIN+STACKWIDTH*2,x
  1023
  1024 					lda #$00
  1025 					sbc :STACKORIGIN+STACKWIDTH*3,x
  1026 					sta :STACKORIGIN+STACKWIDTH*3,x
  1027
  1028 					rts
  1029 				.endp
  1030
  1031
  1032 1D12			.proc	negBYTE1
  1033 					lda #$00
  1034 					sub :STACKORIGIN-1,x
  1035 					sta :STACKORIGIN-1,x
  1036
  1037 					lda #$00
  1038 					sbc #$00
  1039 					sta :STACKORIGIN-1+STACKWIDTH,x
  1040
  1041 					lda #$00
  1042 					sbc #$00
  1043 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1044
  1045 					lda #$00
  1046 					sbc #$00
  1047 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1048
  1049 					rts
  1050 				.endp
  1051
  1052 1D12			.proc	negWORD1
  1053 					lda #$00
  1054 					sub :STACKORIGIN-1,x
  1055 					sta :STACKORIGIN-1,x
  1056
  1057 					lda #$00
  1058 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1059 					sta :STACKORIGIN-1+STACKWIDTH,x
  1060
  1061 					lda #$00
  1062 					sbc #$00
  1063 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1064
  1065 					lda #$00
  1066 					sbc #$00
  1067 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1068
  1069 					rts
  1070 				.endp
  1071
  1072 1D12			.proc	negCARD1
  1073 					lda #$00
  1074 					sub :STACKORIGIN-1,x
  1075 					sta :STACKORIGIN-1,x
  1076
  1077 					lda #$00
  1078 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1079 					sta :STACKORIGIN-1+STACKWIDTH,x
  1080
  1081 					lda #$00
  1082 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1083 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1084
  1085 					lda #$00
  1086 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1087 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1088
  1089 					rts
  1090 				.endp
  1091
  1092
  1093 1D12			.proc	andAL_CL
  1094
  1095 1D12 B5 97			lda :STACKORIGIN-1,x
  1096 1D14 35 98			and :STACKORIGIN,x
  1097 1D16 95 97			sta :STACKORIGIN-1,x
  1098
  1099 1D18 60				rts
  1100 				.endp
  1101
  1102 1D19			.proc	andAX_CX
  1103
  1104 					.rept 2
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1106 					AND :STACKORIGIN+#*STACKWIDTH,X
  1107 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1108 					.ENDR
  1108 					.endr
Source: REPT
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1109
  1110 					rts
  1111 				.endp
  1112
  1113 1D19			.proc	andEAX_ECX
  1114
  1115 					.rept MAXSIZE
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1117 					AND :STACKORIGIN+#*STACKWIDTH,X
  1118 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1119 					.ENDR
  1119 					.endr
Source: REPT
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1120
  1121 					rts
  1122 				.endp
  1123
  1124
  1125 1D19			.proc	orAL_CL
  1126
  1127 					lda :STACKORIGIN-1,x
  1128 					ora :STACKORIGIN,x
  1129 					sta :STACKORIGIN-1,x
  1130
  1131 					rts
  1132 				.endp
  1133
  1134 1D19			.proc	orAX_CX
  1135
  1136 					.rept 2
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1138 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1139 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1140 					.ENDR
  1140 					.endr
Source: REPT
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1141
  1142 					rts
  1143 				.endp
  1144
  1145 1D19			.proc	orEAX_ECX
  1146
  1147 					.rept MAXSIZE
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1149 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1150 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1151 					.ENDR
  1151 					.endr
Source: REPT
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1152
  1153 					rts
  1154 				.endp
  1155
  1156
  1157 1D19			.proc	xorAL_CL
  1158
  1159 					lda :STACKORIGIN-1,x
  1160 					eor :STACKORIGIN,x
  1161 					sta :STACKORIGIN-1,x
  1162
  1163 					rts
  1164 				.endp
  1165
  1166 1D19			.proc	xorAX_CX
  1167
  1168 					.rept 2
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1170 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1171 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1172 					.ENDR
  1172 					.endr
Source: REPT
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1173
  1174 					rts
  1175 				.endp
  1176
  1177 1D19			.proc	xorEAX_ECX
  1178
  1179 					.rept MAXSIZE
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1181 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1182 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1183 					.ENDR
  1183 					.endr
Source: REPT
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1184
  1185 					rts
  1186 				.endp
  1187
  1188
  1189 				/*
  1190 				.proc	iniEAX_ECX_BYTE
  1191
  1192 					mva :STACKORIGIN,x ecx
  1193 					mva :STACKORIGIN-1,x eax
  1194
  1195 					rts
  1196 				.endp
  1197 				*/
  1197
  1198
  1199
  1200 1D19			.proc	iniEAX_ECX_WORD
  1201
  1202 					mva :STACKORIGIN,x ecx
  1203 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1204
  1205 					mva :STACKORIGIN-1,x eax
  1206 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1207
  1208 					mva #$00 ecx+2
  1209 					sta ecx+3
  1210
  1211 					sta eax+2
  1212 					sta eax+3
  1213
  1214 					rts
  1215 				.endp
  1216
  1217
  1218 1D19			.proc	iniEAX_ECX_CARD
  1219 					mva :STACKORIGIN,x ecx
  1220 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1221 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1222 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1223
  1224 					mva :STACKORIGIN-1,x eax
  1225 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1226 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1227 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1228
  1229 					rts
  1230 				.endp
  1231
  1232 1D19			.proc	movZTMP_aBX
  1233 					mva ZTMP8 :STACKORIGIN-1,x
  1234 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1235 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1236 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1237
  1238 					rts
  1239 				.endp
  1240
  1241
  1242 1D19				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 1D19			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 1D19			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 1D19			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 1D19			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 1D19			lsector	:8 dta l(256)
    55 1D19			hsector	:8 dta h(256)
    56
    57 				.endp
  1243 1D19				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 1D19			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 1D19			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 1D19			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 1D19			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 1D19			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 1D19			msg	lda #true
    64 1D19			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 1D19			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 1D19			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 1D19			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 1D19			lookup	ldx #$00
   110 					ldy #$01
   111 1D19			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 1D19			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 1D19			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 1D19			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 1D19			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 1D19			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 1D19			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 1D19			done	jsr eof
   247
   248 1D19			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 1D19			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 1D19			quit	rts
   265
   266 1D19			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 1D19			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 1D19			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 1D19			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 1D19			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 1D19			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 1D19			stp2
   336 					dey
   337 					tya
   338 1D19			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 1D19			attr	equ *-1
   343 					rts
   344
   345 1D19			cpName	sta ln
   346 1D19			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 1D19			ln	equ *-1
   354 					bne cp
   355 1D19			stp	rts
   356 				.endp
   357
  1244
  1245 1D19				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 1D19			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 1D19			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 1D19			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 1D19			.proc	divmulSHORTINT
    31
    32 1D19			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 1D19			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 1D19			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 1D19			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 1D19			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 1D19			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 1D19			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1246 1D19				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 1D19			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 1D19			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 1D19			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 1D19			.proc	divmulSMALLINT
    37
    38 1D19			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 1D19			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 1D19			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 1D19			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 1D19			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 1D19			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 1D19			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 1D19			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1247 1D19				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 1D19			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 1D19			.proc	divmulINT
    16
    17 1D19			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 1D19			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 1D19			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 1D19			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 1D19			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 1D19			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 1D19			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 1D19			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1248
  1249 1D19				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 1D19			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 1D19			sm1:		lda square1_lo,x
    49 1D19			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 1D19			sm3:		lda square1_hi,x
    52 1D19			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 1D19			.proc	imulCL
    75
    76 					lda #$00
    77
    78 					LDY #$09
    79 					CLC
    80 1D19			LOOP	ROR @
    81 					ROR eax
    82 					BCC MUL2
    83 					CLC		;DEC AUX above to remove CLC
    84 					ADC ecx
    85 1D19			MUL2	DEY
    86 					BNE LOOP
    87
    88 					STA eax+1
    89
    90 					RTS
    91 				.endp
    92
    93
    94 1D19			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 1D19			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 1D19			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 1D19			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 1D19			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1250 1D19				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 1D19			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 1D19			sm1a:		lda square1_lo,x
    78 1D19			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 1D19			sm3a:		lda square1_hi,x
    81 1D19			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 1D19			sm1b:		lda square1_lo,x
    88 1D19			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 1D19			sm3b:		lda square1_hi,x
    91 1D19			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 1D19			sm5a:		lda square1_lo,x
    98 1D19			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 1D19			sm7a:		lda square1_hi,x
   101 1D19			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 1D19			sm5b:		lda square1_lo,x
   107 1D19			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 1D19			sm7b:		lda square1_hi,x
   110 1D19			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 1D19			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 1D19			_BB_:		lda #0
   122 1D19			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 1D19			@
   129 						tya
   130 1D19			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 1D19			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 1D19			.proc	imulCX
   162
   163 1D19 A9 00			lda #$00
   164 1D1B 85 85			sta eax+3
   165
   166 1D1D A0 11			LDY #$11			; A = 0 !
   167 1D1F 18				CLC
   168 1D20 66 85		LOOP	ROR eax+3
   169 1D22 6A				ROR @
   170 1D23 66 83			ROR eax+1
   171 1D25 66 82			ROR eax
   172 1D27 90 0B			BCC MUL2
   173 1D29 18				CLC
   174 1D2A 65 8A			ADC ecx
   175 1D2C 48				PHA
   176 1D2D A5 8B			LDA ecx+1
   177 1D2F 65 85			ADC eax+3
   178 1D31 85 85			STA eax+3
   179 1D33 68				PLA
   180 1D34 88			MUL2	DEY
   181 1D35 D0 E9			BNE LOOP
   182
   183 1D37 85 84			STA eax+2
   184
   185 1D39 60				rts
   186 				.endp
   187
   188
   189 1D3A			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 1D3A			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 1D3A			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 1D3A			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 1D3A			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 1D3A			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1251 1D3A				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 1D3A			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 1D3A			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 1D3A			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 1D3A			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 1D3A			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 1D3A			.proc	idivEAX_ECX
    74
    75 1D3A			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 1D3A			CARD	;jsr iniEAX_ECX_CARD
    81
    82 1D3A			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 1D3A			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 1D3A			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1252
  1253 1D3A				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 1D3A			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 1D3A			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 1D3A			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 1D3A			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1254 1D3A				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 1D3A			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 1D3A			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 1D3A			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 1D3A			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 1D3A			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 1D3A			ecx3	equ *-1
    59 1D3A			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 1D3A			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 1D3A			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 1D3A			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 1D3A			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 1D3A			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 1D3A			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 1D3A			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 1D3A			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 1D3A			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 1D3A			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 1D3A			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 1D3A			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1255 1D3A				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 1D3A			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 1D3A			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 1D3A			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 1D3A			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 1D3A			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 1D3A			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 1D3A			FADD:	LDA	#$00
   159 1D3A			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 1D3A			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 1D3A			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 1D3A			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 1D3A			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 1D3A			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 1D3A			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 1D3A			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 1D3A			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 1D3A			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 1D3A			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 1D3A			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 1D3A			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 1D3A			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 1D3A			FPNORMLEFT1:	BMI	FPNORMDONE
   367 1D3A			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 1D3A			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 1D3A			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 1D3A			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 1D3A			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 1D3A			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 1D3A			@	EOR	#$FF
   480 					LDX	#$08
   481 1D3A			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 1D3A			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 1D3A			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 1D3A			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 1D3A			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 1D3A			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 1D3A			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 1D3A			.proc	FCMPL
   605 1D3A			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 1D3A			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 1D3A			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 1D3A			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 1D3A			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 1D3A			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 1D3A			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 1D3A			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 1D3A			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 1D3A			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 1D3A			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 1D3A			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 1D3A			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 1D3A			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 1D3A			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 1D3A			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 1D3A			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 1D3A			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 1D3A			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 1D3A			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 1D3A			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 1D3A			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 1D3A			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 1D3A			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1256
  1257
  1258 1D3A			.proc	@printCHAR
  1259 					ldy :STACKORIGIN,x
  1260 					jmp @print
  1261 				.endp
  1262
  1263
  1264 1D3A			.proc	@printEOL
  1265 					ldy #eol
  1266 					jmp @print
  1267 				.endp
  1268
  1269
  1270 1D3A			.proc	@print (.byte y) .reg
  1271 					txa:pha
  1272
  1273 					tya
  1274 					jsr @putchar
  1275
  1276 					pla:tax
  1277 					rts
  1278 				.endp
  1279
  1280
  1281 1D3A			.proc	@printPCHAR (.word ya) .reg
  1282
  1283 					cpy #0
  1284 					beq empty
  1285
  1286 					sta ztmp
  1287 					sty ztmp+1
  1288
  1289 					stx @sp
  1290
  1291 					lda #0
  1292 					sta loop+1
  1293
  1294 1D3A			loop	ldy #0
  1295 					lda (ztmp),y
  1296 					beq stop
  1297
  1298 					inc loop+1
  1299 					beq stop
  1300
  1301 					jsr @putchar
  1302
  1303 					jmp loop
  1304
  1305 1D3A			stop	ldx #0
  1306 1D3A			@sp	equ *-1
  1307
  1308 1D3A			empty	rts
  1309 				.endp
  1310
  1311
  1312 1D3A			.proc	@printSTRING (.word ya) .reg
  1313
  1314 					cpy #0
  1315 					beq empty
  1316
  1317 					sta ztmp
  1318 					sty ztmp+1
  1319
  1320 					stx @sp
  1321
  1322 					ldy #0
  1323 					sty loop+1
  1324 					lda (ztmp),y
  1325 					sta ln
  1326
  1327 					inw ztmp
  1328
  1329 1D3A			loop	ldy #0
  1330 					lda (ztmp),y
  1331 				;	beq stop
  1332
  1333 					cpy #0
  1334 1D3A			ln	equ *-1
  1335 					beq stop
  1336
  1337 					inc loop+1
  1338
  1339 					jsr @putchar
  1340
  1341 					jmp loop
  1342
  1343 1D3A			stop	ldx #0
  1344 1D3A			@sp	equ *-1
  1345
  1346 1D3A			empty	rts
  1347 				.endp
  1348
  1349
  1350 1D3A			.proc	@printBOOLEAN
  1351 					lda :STACKORIGIN,x
  1352 					beq _0
  1353
  1354 1D3A			_1	lda <_true
  1355 					ldy >_true
  1356 					jmp @printSTRING
  1357
  1358 1D3A			_0	lda <_false
  1359 					ldy >_false
  1360 					jmp @printSTRING
  1361
  1362 1D3A			_true	dta 4,c'TRUE'
  1363 1D3A			_false	dta 5,c'FALSE'
  1364 				.endp
  1365
  1366
  1367 1D3A			.proc	mov_BYTE_DX
  1368 					mva :STACKORIGIN,x dx
  1369 					mva #$00 dx+1
  1370 					sta dx+2
  1371 					sta dx+3
  1372
  1373 					rts
  1374 				.endp
  1375
  1376 1D3A			.proc	mov_WORD_DX
  1377 					mva :STACKORIGIN,x dx
  1378 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1379 					mva #$00 dx+2
  1380 					sta dx+3
  1381
  1382 					rts
  1383 				.endp
  1384
  1385 1D3A			.proc	mov_CARD_DX
  1386 					mva :STACKORIGIN,x dx
  1387 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1388 					mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1389 					mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1390
  1391 					rts
  1392 				.endp
  1393
  1394
  1395 1D3A			.proc	@printMINUS
  1396 					ldy #'-'
  1397 					jsr @printVALUE.pout
  1398
  1399 					jmp negCARD
  1400 				.endp
  1401
  1402
  1403 1D3A			.proc	@printSHORTREAL
  1404 					jsr @expandToCARD.SMALL
  1405 					jmp @printREAL
  1406 				.endp
  1407
  1408
  1409 1D3A			.proc	@FTOA
  1410
  1411 = 0086			i	= edx
  1412 = 008A			fra	= ecx
  1413 = 0082			hlp	= eax
  1414
  1415 = 0092			exp	= ztmp
  1416 = 0093			b	= ztmp+1
  1417 = 0094			sht	= ztmp+2
  1418
  1419 = 0440			bit	= @buf+64
  1420
  1421 					stx @sp
  1422
  1423 					mva :STACKORIGIN,x I
  1424 					sta :STACKORIGIN+9
  1425 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1426 					sta :STACKORIGIN+STACKWIDTH+9
  1427 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1428 					sta :STACKORIGIN+STACKWIDTH*2+9
  1429 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1430 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1431
  1432 					bpl skp
  1433
  1434 					ldy #'-'
  1435 					jsr @printVALUE.pout
  1436
  1437 1D3A			skp
  1438 				; optimize OK (test_3.pas), line = 32
  1439
  1440 					lda :STACKORIGIN+STACKWIDTH*3+9
  1441 					asl :STACKORIGIN+9
  1442 					rol :STACKORIGIN+STACKWIDTH+9
  1443 					rol :STACKORIGIN+STACKWIDTH*2+9
  1444 					rol @
  1445 					sta EXP				; Exponent
  1446
  1447 				; optimize OK (test_3.pas), line = 33
  1448
  1449 					lda I
  1450 					sta FRA
  1451 					lda I+1
  1452 					sta FRA+1
  1453 					lda I+2
  1454 					sta FRA+2
  1455 					lda I+3
  1456 					sta FRA+3
  1457 					asl FRA
  1458 					rol FRA+1
  1459 					rol FRA+2
  1460 					rol FRA+3
  1461
  1462 				; optimize OK (test_3.pas), line = 35
  1463
  1464 					lda EXP
  1465 					sub #$7F
  1466 					sta SHT
  1467
  1468 				; optimize OK (test_3.pas), line = 37
  1469
  1470 					ldx #$3f
  1471 					lda #0
  1472 					sta:rpl bit,x-
  1473
  1474 				; For
  1475
  1476 				; optimize OK (test_3.pas), line = 39
  1477
  1478 				;	sta B
  1479 					tax
  1480
  1481 				; optimize OK (test_3.pas), line = 39
  1482
  1483 1D3A			l_01D4
  1484 				;	lda B
  1485 				;	cmp #$17
  1486 					cpx #$17
  1487 					bcc *+7
  1488 					beq *+5
  1489
  1490 				; ForToDoProlog
  1491 					jmp l_01EE
  1492
  1493 				; optimize OK (test_3.pas), line = 40
  1494
  1495 				;	lda #$20
  1496 				;	add B
  1497 				;	tax
  1498
  1499 					lda FRA+2
  1500 					sta BIT+$20,x
  1501
  1502 				; optimize OK (test_3.pas), line = 41
  1503
  1504 					asl FRA
  1505 					rol FRA+1
  1506 					rol FRA+2
  1507 					rol FRA+3
  1508
  1509 				; ForToDoEpilog
  1510 1D3A			c_01D4
  1511 				;	inc B
  1512 					inx
  1513
  1514 					seq
  1515
  1516 				; WhileDoEpilog
  1517 					jmp l_01D4
  1518 1D3A			l_01EE
  1519 1D3A			b_01D4
  1520
  1521 				; optimize OK (test_3.pas), line = 44
  1522
  1523 					mva #$80 BIT+$1f
  1524
  1525 				; optimize OK (test_3.pas), line = 46
  1526
  1527 					mva #$00 I
  1528 					sta I+1
  1529 					sta I+2
  1530 					sta I+3
  1531
  1532 				; optimize OK (test_3.pas), line = 47
  1533
  1534 					sta FRA+1
  1535 					sta FRA+2
  1536 					sta FRA+3
  1537
  1538 					mva #$01 FRA
  1539
  1540 				; For
  1541
  1542 				; optimize OK (test_3.pas), line = 49
  1543
  1544 					lda SHT
  1545 					add #$1F
  1546 					sta B
  1547
  1548 				; optimize OK (test_3.pas), line = 49
  1549
  1550 					tay
  1551
  1552 1D3A			l_035B
  1553 				;	lda B
  1554 				;	cmp #$00
  1555 				;	bcs *+5
  1556
  1557 				; ForToDoProlog
  1558 				;	jmp l_0375
  1559
  1560 				; optimize OK (test_3.pas), line = 50
  1561
  1562 				;	ldy B
  1563 					lda BIT,y
  1564 					bpl l_03D7
  1565
  1566 				; optimize OK (test_3.pas), line = 50
  1567
  1568 					lda I				; Mantissa
  1569 					add FRA
  1570 					sta I
  1571 					lda I+1
  1572 					adc FRA+1
  1573 					sta I+1
  1574 					lda I+2
  1575 					adc FRA+2
  1576 					sta I+2
  1577 					lda I+3
  1578 					adc FRA+3
  1579 					sta I+3
  1580
  1581 				; IfThenEpilog
  1582 1D3A			l_03D7
  1583
  1584 				; optimize OK (test_3.pas), line = 52
  1585
  1586 					asl FRA
  1587 					rol FRA+1
  1588 					rol FRA+2
  1589 					rol FRA+3
  1590
  1591 				; ForToDoEpilog
  1592 1D3A			c_035B
  1593 				;	dec B
  1594 					dey
  1595
  1596 				;	lda B
  1597 				;	cmp #$ff
  1598 					cpy #$ff
  1599 					seq
  1600
  1601 				; WhileDoEpilog
  1602 					jmp l_035B
  1603 1D3A			l_0375
  1604 1D3A			b_035B
  1605
  1606 				; optimize OK (test_3.pas), line = 55
  1607
  1608 					mva #$00 FRA
  1609 					sta FRA+1
  1610 					sta FRA+2
  1611 					sta FRA+3
  1612
  1613 				; optimize OK (test_3.pas), line = 56
  1614
  1615 					sta EXP
  1616
  1617 					sta hlp
  1618 					sta hlp+1
  1619
  1620 					lda #$80
  1621 					sta hlp+2
  1622 				; For
  1623
  1624 				; optimize OK (test_3.pas), line = 58
  1625
  1626 					lda SHT
  1627 					add #$20
  1628 				;	sta B
  1629
  1630 					tay
  1631
  1632 				; optimize OK (test_3.pas), line = 58
  1633
  1634 					add #23
  1635 					sta FORTMP_1273
  1636 				; To
  1637 1D3A			l_0508
  1638
  1639 				; ForToDoCondition
  1640
  1641 				; optimize OK (test_3.pas), line = 58
  1642
  1643 				;	lda B
  1644 				;	cmp #0
  1645 					cpy #0
  1646 1D3A			FORTMP_1273	equ *-1
  1647 					bcc *+7
  1648 					beq *+5
  1649
  1650 				; ForToDoProlog
  1651 					jmp l_0534
  1652
  1653 				; optimize OK (test_3.pas), line = 59
  1654
  1655 				;	ldy B
  1656 					lda BIT,y
  1657 					bpl l_0596
  1658
  1659 				; optimize OK (test_3.pas), line = 59
  1660
  1661 					lda FRA
  1662 					add hlp
  1663 					sta FRA
  1664 					lda FRA+1
  1665 					adc hlp+1
  1666 					sta FRA+1
  1667 					lda FRA+2
  1668 					adc hlp+2
  1669 					sta FRA+2
  1670
  1671 				; IfThenEpilog
  1672 1D3A			l_0596
  1673
  1674 					lsr hlp+2
  1675 					ror hlp+1
  1676 					ror hlp
  1677
  1678 				; ForToDoEpilog
  1679 1D3A			c_0508
  1680 				;	inc B						; inc ptr byte [CounterAddress]
  1681 					iny
  1682
  1683 					seq
  1684
  1685 				; WhileDoEpilog
  1686 					jmp l_0508
  1687 1D3A			l_0534
  1688 1D3A			b_0508
  1689 1D3A				:3 mva fra+# fracpart+#
  1690
  1691 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1692 					@float #500000
  1693
  1694 					ldx #0
  1695 1D3A			@sp	equ *-1
  1696
  1697 					rts
  1698 				.endp
  1699
  1700
  1701 1D3A			.proc	@printREAL
  1702
  1703 					stx @sp
  1704
  1705 					lda :STACKORIGIN+STACKWIDTH*3,x
  1706 					spl
  1707 					jsr @printMINUS
  1708
  1709 					jsr mov_CARD_DX
  1710
  1711 					mva dx+1 intpart		; intpart := uvalue shr 8
  1712 					mva dx+2 intpart+1
  1713 					mva dx+3 intpart+2
  1714 					mva #$00 intpart+3
  1715
  1716 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1717 					sta dx+2
  1718 					sta dx+1
  1719
  1720 					sta fracpart
  1721 					sta fracpart+1
  1722
  1723 					lda dx
  1724 					sta fracpart+2
  1725
  1726 1D3A				:4 mva intpart+# dx+#		; integer part
  1727
  1728 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1729 					@float #5000
  1730
  1731 					ldx #0
  1732 1D3A			@sp	equ *-1
  1733 					rts
  1734
  1735 1D3A 00 00 00 00		intpart		.dword
  1736
  1737 				.endp
  1738
  1739
  1740 1D3E			.proc	@float (.long axy) .reg
  1741
  1742 					sty cx
  1743 					stx cx+1
  1744 					sta cx+2
  1745
  1746 					lda @printVALUE.pout		; print integer part
  1747 					pha
  1748 					jsr @printVALUE
  1749 					pla
  1750 					sta @printVALUE.pout
  1751
  1752 					lda #0
  1753 					sta dx
  1754 					sta dx+1
  1755 					sta dx+2
  1756 					sta dx+3
  1757
  1758 1D3E			loop	lda fracpart+2
  1759 					bpl skp
  1760
  1761 					clc
  1762 				;	lda cx
  1763 				;	spl
  1764 				;	sec
  1765
  1766 					lda dx
  1767 					adc cx
  1768 					sta dx
  1769 					lda dx+1
  1770 					adc cx+1
  1771 					sta dx+1
  1772 					lda dx+2
  1773 					adc cx+2
  1774 					sta dx+2
  1775 				;	lda dx+3
  1776 				;	adc #0
  1777 				;	sta dx+3
  1778
  1779 1D3E			skp	lsr cx+2
  1780 					ror cx+1
  1781 					ror cx
  1782
  1783 					asl fracpart
  1784 					rol fracpart+1
  1785 					rol fracpart+2
  1786
  1787 					lda cx
  1788 					ora cx+1
  1789 					ora cx+2
  1790
  1791 					bne loop
  1792
  1793 					ldy #'.'
  1794 					jsr @printVALUE.pout
  1795
  1796 1D3E				:4 mva dx+# fracpart+#
  1797
  1798 					lda @printVALUE.pout
  1799 					pha
  1800
  1801 					lda #{rts}
  1802 					sta @printVALUE.pout
  1803 					jsr @printVALUE			; floating part length
  1804
  1805 					sta cnt
  1806
  1807 					pla
  1808 					sta @printVALUE.pout
  1809
  1810 1D3E			lp	lda #0
  1811 1D3E			cnt	equ *-1
  1812 					cmp #4				; N miejsc po przecinku
  1813 1D3E			afterpoint equ *-1
  1814 					bcs ok
  1815
  1816 					ldy #'0'
  1817 					jsr @printVALUE.pout
  1818
  1819 					inc cnt
  1820 					bne lp
  1821
  1822 1D3E			ok	:4 mva fracpart+# dx+#
  1823 					jmp @printVALUE			; print floating part
  1824
  1825 				.endp
  1826
  1827
  1828 1D3E			.proc	@printSHORTINT
  1829
  1830 					lda :STACKORIGIN,x
  1831 					spl
  1832 					jsr @printMINUS
  1833
  1834 					jmp @printBYTE
  1835 				.endp
  1836
  1837
  1838 1D3E			.proc	@printSMALLINT
  1839
  1840 					lda :STACKORIGIN+STACKWIDTH,x
  1841 					spl
  1842 					jsr @printMINUS
  1843
  1844 					jmp @printWORD
  1845 				.endp
  1846
  1847
  1848 1D3E			.proc	@printINT
  1849
  1850 					lda :STACKORIGIN+STACKWIDTH*3,x
  1851 					spl
  1852 					jsr @printMINUS
  1853
  1854 					jmp @printCARD
  1855 				.endp
  1856
  1857
  1858 1D3E			.proc	@printCARD
  1859 					jsr mov_CARD_DX
  1860 					jmp @printVALUE
  1861 				.endp
  1862
  1863
  1864 1D3E			.proc	@printWORD
  1865 					jsr mov_WORD_DX
  1866 					jmp @printVALUE
  1867 				.endp
  1868
  1869
  1870 1D3E			.proc	@printBYTE
  1871 					jsr mov_BYTE_DX
  1872 					jmp @printVALUE
  1873 				.endp
  1874
  1875
  1876 1D3E			.proc	@printVALUE
  1877
  1878 					lda dx+3
  1879 					bne _32bit
  1880
  1881 					lda dx+2
  1882 					bne _24bit
  1883
  1884 					lda dx+1
  1885 					bne _16bit
  1886
  1887 1D3E			_8bit	lda #3
  1888 					bne l3
  1889
  1890 1D3E			_16bit	lda #5
  1891 					bne l3
  1892
  1893 1D3E			_24bit	lda #8
  1894 					bne l3
  1895
  1896 					; prints a 32 bit value to the screen (Graham)
  1897
  1898 1D3E			_32bit	lda #10
  1899
  1900 1D3E			l3	sta limit
  1901
  1902 					stx @sp
  1903
  1904 					ldx #0
  1905 					stx cnt
  1906
  1907 1D3E			lp	jsr div10
  1908
  1909 					sta tmp,x
  1910 					inx
  1911 					cpx #10
  1912 1D3E			limit	equ *-1
  1913 					bne lp
  1914
  1915 					;ldx #9
  1916 					dex
  1917
  1918 1D3E			l1	lda tmp,x
  1919 					bne l2
  1920 					dex		; skip leading zeros
  1921 					bne l1
  1922
  1923 1D3E			l2	lda tmp,x
  1924 					ora #$30
  1925 					tay
  1926
  1927 					jsr pout
  1928 					inc cnt
  1929
  1930 					dex
  1931 					bpl l2
  1932
  1933 					mva #{jmp*} pout
  1934
  1935 					lda #0
  1936 1D3E			cnt	equ *-1
  1937
  1938 					ldx #0
  1939 1D3E			@sp	equ *-1
  1940 					rts
  1941
  1942 1D3E			pout	jmp @print
  1943
  1944 					sty @buf+1
  1945 1D3E			pbuf	equ *-2
  1946 					inc pbuf
  1947
  1948 					rts
  1949
  1950 1D3E			tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1951
  1952 				.endp
  1953
  1954
  1955 				; divides a 32 bit value by 10
  1956 				; remainder is returned in akku
  1957
  1958 1D3E			.proc	div10
  1959 				        ldy #32		; 32 bits
  1960 				        lda #0
  1961 				        clc
  1962 1D3E			l4      rol @
  1963 				        cmp #10
  1964 				        bcc skip
  1965 				        sbc #10
  1966 1D3E			skip    rol dx
  1967 				        rol dx+1
  1968 				        rol dx+2
  1969 				        rol dx+3
  1970 				        dey
  1971 				        bpl l4
  1972
  1973 					rts
  1974 				.endp
  1975
  1976
  1977 1D3E			.proc	@hexStr
  1978
  1979 = 0086			Value	= edx
  1980 = 008A			Digits	= ecx
  1981
  1982 					ldx Digits
  1983 					cpx #32
  1984 					scc
  1985 					ldx #32
  1986
  1987 					stx Digits
  1988
  1989 					lda Value
  1990 					jsr hex
  1991 					lda Value+1
  1992 					jsr hex
  1993 					lda Value+2
  1994 					jsr hex
  1995 					lda Value+3
  1996 					jsr hex
  1997
  1998 					lda Digits
  1999 					sta @buf
  2000 					rts
  2001
  2002 1D3E			hex	pha
  2003 					and #$f
  2004 					jsr put
  2005 					pla
  2006 1D3E				:4 lsr @
  2007 1D3E			put	tay
  2008 					lda thex,y
  2009 					sta @buf,x
  2010 					dex
  2011 					rts
  2012
  2013 1D3E			thex	dta c'0123456789ABCDEF'
  2014 				.endp
  2015
  2016
  2017 1D3E			.proc	@ValueToStr (.word ya) .reg
  2018
  2019 					sta adr
  2020 					sty adr+1
  2021
  2022 					mva #{bit*} @printVALUE.pout
  2023 					mva <@buf+1 @printVALUE.pbuf
  2024
  2025 					jsr $ffff
  2026 1D3E			adr	equ *-2
  2027
  2028 					ldy @printVALUE.pbuf
  2029 					dey
  2030 					sty @buf
  2031
  2032 					rts
  2033 				.endp
  2034
  2035
  2036 				;	ecx	isSign
  2037 				;	edx	Result
  2038
  2039 1D3E			.proc	@StrToInt (.word ya) .reg
  2040
  2041 					sta bp2
  2042 					sty bp2+1
  2043
  2044 					ldy #0
  2045 					sty MAIN.SYSTEM.IOResult
  2046 					sty edx
  2047 					sty edx+1
  2048 					sty edx+2
  2049 					sty edx+3
  2050
  2051 					lda (bp2),y
  2052 					beq stop
  2053 					sta len
  2054
  2055 					inw bp2
  2056
  2057 					lda (bp2),y
  2058 					cmp #'-'
  2059 					sne
  2060 					iny
  2061
  2062 					sty ecx
  2063
  2064 1D3E			l1	lda (bp2),y
  2065
  2066 					CLC
  2067 					ADC #$FF-'9'	; make m = $FF
  2068 					ADC #'9'-'0'+1	; carry set if in range n to m
  2069 					bcs ok
  2070
  2071 					lda #106	; Invalid numeric format
  2072 					sta MAIN.SYSTEM.IOResult
  2073
  2074 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2075
  2076 1D3E			ok	jsr fmul10
  2077
  2078 					lda (bp2),y
  2079 					sub #$30
  2080 					sta ztmp
  2081
  2082 					lda #$00
  2083 					sta ztmp+1
  2084 					sta ztmp+2
  2085 					sta ztmp+3
  2086
  2087 					jsr fmul10.add32bit
  2088
  2089 					iny
  2090 					cpy #0
  2091 1D3E			len	equ *-1
  2092 					bne l1
  2093
  2094 					lda ecx
  2095 					beq stop
  2096
  2097 					jsr negEDX
  2098
  2099 1D3E			stop	ldy #0		; reg Y = 0 conversion successful
  2100 					rts
  2101 				.endp
  2102
  2103
  2104 1D3E			.proc	negEDX
  2105 					lda #$00	; minus
  2106 					sub edx
  2107 					sta edx
  2108
  2109 					lda #$00
  2110 					sbc edx+1
  2111 					sta edx+1
  2112
  2113 					lda #$00
  2114 					sbc edx+2
  2115 					sta edx+2
  2116
  2117 					lda #$00
  2118 					sbc edx+3
  2119 					sta edx+3
  2120
  2121 					rts
  2122 				.endp
  2123
  2124
  2125 1D3E			.proc	fmul10
  2126 					asl edx		;multiply by 2
  2127 					rol edx+1	;temp store in ZTMP
  2128 					rol edx+2
  2129 					rol edx+3
  2130
  2131 					lda edx
  2132 					sta ztmp
  2133 					lda edx+1
  2134 					sta ztmp+1
  2135 					lda edx+2
  2136 					sta ztmp+2
  2137 					lda edx+3
  2138 					sta ztmp+3
  2139
  2140 					asl edx
  2141 					rol edx+1
  2142 					rol edx+2
  2143 					rol edx+3
  2144
  2145 					asl edx
  2146 					rol edx+1
  2147 					rol edx+2
  2148 					rol edx+3
  2149
  2150 1D3E			add32bit
  2151 					lda edx
  2152 					add ztmp
  2153 					sta edx
  2154 					lda edx+1
  2155 					adc ztmp+1
  2156 					sta edx+1
  2157 					lda edx+2
  2158 					adc ztmp+2
  2159 					sta edx+2
  2160 					lda edx+3
  2161 					adc ztmp+3
  2162 					sta edx+3
  2163
  2164 					rts
  2165 				.endp
  2166
  2167
  2168 1D3E			.proc	@trunc
  2169
  2170 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2171 					spl
  2172 					jsr negCARD
  2173
  2174 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2175 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2176 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2177 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2178
  2179 					tya
  2180 					spl
  2181 					jsr negCARD
  2182
  2183 					rts
  2184 				.endp
  2185
  2186
  2187 1D3E			.proc	@round
  2188
  2189 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2190 					spl
  2191 					jsr negCARD
  2192
  2193 					lda :STACKORIGIN,x
  2194 				//	add #$80
  2195 					cmp #$80
  2196 					lda :STACKORIGIN+STACKWIDTH,x
  2197 					adc #0
  2198 					sta :STACKORIGIN,x
  2199 					lda :STACKORIGIN+STACKWIDTH*2,x
  2200 					adc #0
  2201 					sta :STACKORIGIN+STACKWIDTH,x
  2202 					lda :STACKORIGIN+STACKWIDTH*3,x
  2203 					adc #0
  2204 					sta :STACKORIGIN+STACKWIDTH*2,x
  2205
  2206 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2207
  2208 					tya
  2209 					spl
  2210 					jsr negCARD
  2211
  2212 					rts
  2213 				.endp
  2214
  2215
  2216 1D3E			.proc	@frac
  2217
  2218 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2219 					spl
  2220 					jsr negCARD
  2221
  2222 					lda #$00
  2223 					sta :STACKORIGIN+STACKWIDTH,x
  2224 					sta :STACKORIGIN+STACKWIDTH*2,x
  2225 					sta :STACKORIGIN+STACKWIDTH*3,x
  2226
  2227 					tya
  2228 					spl
  2229 					jsr negCARD
  2230
  2231 					rts
  2232 				.endp
  2233
  2234
  2235 1D3E			.proc	@int
  2236
  2237 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2238 					spl
  2239 					jsr negCARD
  2240
  2241 					lda #$00
  2242 					sta :STACKORIGIN,x
  2243
  2244 					tya
  2245 					spl
  2246 					jsr negCARD
  2247
  2248 					rts
  2249 				.endp
  2250
  2251
  2252 				;----------------------------;
  2253 				; Biblioteka procedur        ;
  2254 				; graficznych                ;
  2255 				;----------------------------;
  2256 				; Autorzy:                   ;
  2257 				;  Slawomir 'SERO' Ritter,   ;
  2258 				;  Jakub Cebula,             ;
  2259 				;  Winfried Hofacker         ;
  2260 				;----------------------------;
  2261 				; Wersja:1.1 DATA:09.01.2008 ;
  2262 				;----------------------------;
  2263
  2264 = 0003			@open	= $03		; Otworz kanal
  2265 = 000C			@close	= $0c		; Zamknij kanal
  2266
  2267 = 0007			@IDget	= $07		; Narysuj punkt
  2268 = 0009			@IDput	= $09		; Narysuj punkt
  2269 = 0011			@IDdraw	= $11		; Narysuj linie
  2270 = 0012			@IDfill	= $12		; Wypelnij obszar
  2271
  2272
  2273 				;------------------------;
  2274 				;Wy:.Y-numer bledu (1-OK);
  2275 				;   f(N)=1-wystapil blad ;
  2276 				;------------------------;
  2277 1D3E			.proc	@COMMAND
  2278
  2279 					ldx	#$00
  2280 1D3E			scrchn	equ *-1
  2281
  2282 					sta	iocom,x
  2283
  2284 					lda	#$00
  2285 1D3E			colscr	equ *-1
  2286 					sta	atachr
  2287
  2288 					jmp	ciov
  2289 				.endp
  2290
  2291 				;------------------------;
  2292 				; Ustaw tryb ekranu      ;
  2293 				;------------------------;
  2294 				;We:.X-numer kanalu      ;
  2295 				;      (normalnie 0)     ;
  2296 				;   .Y-numer trybu (O.S.);
  2297 				;   .A-Ustawiony bit nr :;
  2298 				;     5-Nie kasowanie    ;
  2299 				;       pamieci ekranu   ;
  2300 				;     4-Obecnosc okna    ;
  2301 				;       tekstowego       ;
  2302 				;     2-Odczyt z ekranu  ;
  2303 				;------------------------;
  2304 				;Wy:SCRCHN-numer kanalu  ;
  2305 				;  .Y-numer bledu (1-OK) ;
  2306 				;   f(N)=1 wystapil blad ;
  2307 				;------------------------;
  2308 1D3E			@GRAPHICS .proc (.byte x,y,a) .reg
  2309
  2310 					sta	byte1
  2311 					sty	byte2
  2312
  2313 					stx	@COMMAND.scrchn
  2314
  2315 					lda	#@close
  2316 					jsr	xcio
  2317
  2318 					lda	#0		; =opcje
  2319 1D3E			byte1	equ	*-1
  2320 					ora	#8		; +zapis na ekranie
  2321 					sta	ioaux1,x
  2322
  2323 					lda	#0
  2324 1D3E			byte2	equ	*-1
  2325 					sta	ioaux2,x	;=nr.trybu
  2326
  2327 					mwa	#sname	ioadr,x
  2328
  2329 					lda	#@open
  2330
  2331 1D3E			xcio	sta iocom,x
  2332 					jmp ciov
  2333
  2334 1D3E			sname	dta c'S:',$9b
  2335
  2336 					.endp
  2337
  2338
  2339 1D3E			.proc	@ata2int
  2340 				        asl
  2341 				        php
  2342 				        cmp #2*$60
  2343 				        bcs @+
  2344 				        sbc #2*$20-1
  2345 				        bcs @+
  2346 				        adc #2*$60
  2347 1D3E			@       plp
  2348 				        ror
  2349 					rts
  2350 				.endp
  2351
  2352
  2353 				/*
  2354 				  PUT CHAR
  2355
  2356 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2357 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2358 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2359
  2360 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2361 				  JSR PUTCHR.
  2362 				*/
  2362
  2363
  2364 1D3E			.proc	@putchar (.byte a) .reg
  2365
  2366 1D3E			vbxe	bit *
  2367
  2368 					ldx #$00
  2369 					.ifdef MAIN.CRT.TextAttr
  2370 					ora MAIN.CRT.TextAttr
  2371 					.endif
  2372 					tay
  2373 					lda icputb+1,x
  2374 					pha
  2375 					lda icputb,x
  2376 					pha
  2377 					tya
  2378
  2379 					rts
  2380
  2381 				.endp
  2382
  2383
  2384 				/*
  2385 				  GETLINE
  2386
  2387 				  Program czeka, az uzytkownik wpisze ciag znak�w z klawiatury i nacisnie klawisz RETURN.
  2388 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2389 				  (odczyt jest robiony z edytora ekranowego).
  2390
  2391 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2392 				  do rejestr�w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2393
  2394 				*/
  2394
  2395
  2396 1D3E			.proc	@GetLine
  2397
  2398 					stx @sp
  2399
  2400 					ldx #0
  2401
  2402 					stx MAIN.SYSTEM.EoLn
  2403
  2404 					mwa	#@buf+1	icbufa,x
  2405
  2406 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2407
  2408 					mva	#$05	iccmd,x
  2409
  2410 					jsr	ciov
  2411
  2412 					dew icbufl
  2413 					mva icbufl @buf			; length
  2414
  2415 					ldx @buf+1
  2416 					cpx #EOL
  2417 					bne skp
  2418
  2419 					ldx #TRUE
  2420 					stx MAIN.SYSTEM.EoLn
  2421 1D3E			skp
  2422 					ldx #0
  2423 1D3E			@sp	equ *-1
  2424
  2425 					rts
  2426 				.endp
  2427
  2428
  2429 1D3E			.proc	@GetKey
  2430
  2431 1D3E			getk	lda kbcodes	; odczytaj kbcodes
  2432 					cmp #255		; czy jest znak?
  2433 					beq getk	; nie: czekaj
  2434 					ldy #255		; daj zna�, �e klawisz
  2435 					sty kbcodes	; zosta� odebrany
  2436 					tay		; kod klawisza jako indeks
  2437 					lda (keydef),y	; do tablicy w ROM-ie
  2438
  2439 					rts
  2440 				.endp
  2441
  2442
  2443 1D3E			.proc	@moveSTRING (.word ya) .reg
  2444
  2445 					sta @move.dst
  2446 					sty @move.dst+1
  2447
  2448 					mva :STACKORIGIN,x @move.src
  2449 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2450
  2451 					ldy #$00
  2452 					lda (@move.src),y
  2453 					add #1
  2454 					sta @move.cnt
  2455 					scc
  2456 					iny
  2457 					sty @move.cnt+1
  2458
  2459 					jmp @move
  2460 				.endp
  2461
  2462
  2463 1D3E			.proc	@moveSTRING_1 (.word ya) .reg
  2464
  2465 					sta @move.dst
  2466 					sty @move.dst+1
  2467
  2468 					mva :STACKORIGIN,x @move.src
  2469 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2470
  2471 					ldy #$00
  2472 					lda (@move.src),y
  2473 				;	add #1
  2474 					sta @move.cnt
  2475 					sty @move.cnt+1
  2476
  2477 					inw @move.src
  2478
  2479 					jmp @move
  2480 				.endp
  2481
  2482
  2483 				; Ullrich von Bassewitz, 2003-08-20
  2484 				; Performance increase (about 20%) by
  2485 				; Christian Krueger, 2009-09-13
  2486
  2487 1D3E			.proc	@moveu		; assert Y = 0
  2488
  2489 = 0086			ptr1	= edx
  2490 = 008A			ptr2	= ecx
  2491 = 0082			ptr3	= eax
  2492
  2493 1D3E 8E 67 1D			stx @sp
  2494
  2495 1D41 A0 00			ldy	#0
  2496
  2497 1D43 A6 83			ldx     ptr3+1		; Get high byte of n
  2498 1D45 F0 13			beq     L2		; Jump if zero
  2499
  2500 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2501 					LDA     (PTR1),Y	
  2502 					STA     (PTR2),Y
  2503 					INY
  2504 					.ENDR
  2504 					.endr
Source: REPT
  2501 1D47 B1 86			LDA     (PTR1),Y	
  2501 1D49 91 8A			STA     (PTR2),Y
  2501 1D4B C8				INY
  2501 1D4C B1 86			LDA     (PTR1),Y	
  2501 1D4E 91 8A			STA     (PTR2),Y
  2501 1D50 C8				INY
Source: cpu6502.asm
  2505
  2506 1D51 D0 F4			bne     L1
  2507 1D53 E6 87			inc     ptr1+1
  2508 1D55 E6 8B			inc     ptr2+1
  2509 1D57 CA				dex			; Next 256 byte block
  2510 1D58 D0 ED			bne	L1		; Repeat if any
  2511
  2512 					; the following section could be 10% faster if we were able to copy
  2513 					; back to front - unfortunately we are forced to copy strict from
  2514 					; low to high since this function is also used for
  2515 					; memmove and blocks could be overlapping!
  2516 					; {
  2517 1D5A			L2:				; assert Y = 0
  2518 1D5A A6 82			ldx     ptr3		; Get the low byte of n
  2519 1D5C F0 08			beq     done		; something to copy
  2520
  2521 1D5E B1 86		L3:     lda     (ptr1),Y	; copy a byte
  2522 1D60 91 8A			sta     (ptr2),Y
  2523 1D62 C8				iny
  2524 1D63 CA				dex
  2525 1D64 D0 F8			bne     L3
  2526
  2527 					; }
  2528
  2529 1D66 A2 00		done	ldx #0
  2530 = 1D67			@sp	equ *-1
  2531 1D68 60				rts
  2532 				.endp
  2533
  2534
  2535 1D69			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2536
  2537 = 0086			ptr1	= edx
  2538 = 008A			ptr2	= ecx
  2539 = 0082			ptr3	= eax
  2540
  2541 = 0086			src	= ptr1
  2542 = 008A			dst	= ptr2
  2543 = 0082			cnt	= ptr3
  2544
  2545 1D69 A5 8B C5 87 D0 04 + 	cpw ptr2 ptr1
  2546 1D73 B0 03			scs
  2547 1D75 4C 3E 1D			jmp @moveu
  2548
  2549 1D78 8E BC 1D			stx @sp
  2550
  2551 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2552
  2553 1D7B A5 87			lda     ptr1+1
  2554 1D7D 18 65 83			add     ptr3+1
  2555 1D80 85 87			sta     ptr1+1
  2556
  2557 1D82 A5 8B			lda     ptr2+1
  2558 1D84 18 65 83			add     ptr3+1
  2559 1D87 85 8B			sta     ptr2+1
  2560
  2561 				; handle fractions of a page size first
  2562
  2563 1D89 A4 82			ldy     ptr3		; count, low byte
  2564 1D8B D0 06			bne     @entry		; something to copy?
  2565 1D8D F0 0B			beq     PageSizeCopy	; here like bra...
  2566
  2567 1D8F			@copyByte:
  2568 1D8F B1 86			lda     (ptr1),y
  2569 1D91 91 8A			sta     (ptr2),y
  2570 1D93			@entry:
  2571 1D93 88				dey
  2572 1D94 D0 F9			bne     @copyByte
  2573 1D96 B1 86			lda     (ptr1),y	; copy remaining byte
  2574 1D98 91 8A			sta     (ptr2),y
  2575
  2576 1D9A			PageSizeCopy:			; assert Y = 0
  2577 1D9A A6 83			ldx     ptr3+1		; number of pages
  2578 1D9C F0 1D			beq     done		; none? -> done
  2579
  2580 1D9E			@initBase:
  2581 1D9E C6 87			dec     ptr1+1		; adjust base...
  2582 1DA0 C6 8B			dec     ptr2+1
  2583 1DA2 88				dey			; in entry case: 0 -> FF
  2584 1DA3 B1 86			lda     (ptr1),y	; need to copy this 'intro byte'
  2585 1DA5 91 8A			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2586 1DA7 88				dey			; FF ->FE
  2587 1DA8			@copyBytes:
  2588 					.rept 2		; Unroll this a bit to make it faster...
  2589 					LDA     (PTR1),Y
  2590 					STA     (PTR2),Y
  2591 					DEY
  2592 					.ENDR
  2592 					.endr
Source: REPT
  2589 1DA8 B1 86			LDA     (PTR1),Y
  2589 1DAA 91 8A			STA     (PTR2),Y
  2589 1DAC 88				DEY
  2589 1DAD B1 86			LDA     (PTR1),Y
  2589 1DAF 91 8A			STA     (PTR2),Y
  2589 1DB1 88				DEY
Source: cpu6502.asm
  2593 1DB2			@copyEntry:			; in entry case: 0 -> FF
  2594 1DB2 D0 F4			bne     @copyBytes
  2595 1DB4 B1 86			lda     (ptr1),y	; Y = 0, copy last byte
  2596 1DB6 91 8A			sta     (ptr2),y
  2597 1DB8 CA				dex			; one page to copy less
  2598 1DB9 D0 E3			bne     @initBase	; still a page to copy?
  2599
  2600 1DBB A2 00		done	ldx #0
  2601 = 1DBC			@sp	equ *-1
  2602 1DBD 60				rts
  2603 				.endp
  2604
  2605
  2606 				; Ullrich von Bassewitz, 29.05.1998
  2607 				; Performance increase (about 20%) by
  2608 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2609
  2610 1DBE			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2611
  2612 = 0086			ptr1 = edx
  2613 = 008A			ptr3 = ecx
  2614 = 0082			ptr2 = eax
  2615
  2616 1DBE 8A 48			txa:pha
  2617
  2618 1DC0 A6 82			ldx ptr2
  2619
  2620 1DC2 A0 00			ldy #0
  2621
  2622 1DC4 46 8B		        lsr	ptr3+1          ; divide number of
  2623 1DC6 66 8A		        ror	ptr3            ; bytes by two to increase
  2624 1DC8 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2625 1DCA			oddCount:
  2626 								; y is still 0 here
  2627 1DCA 8A			        txa			; restore fill value
  2628 1DCB 91 86		        sta	(ptr1),y	; save value and increase
  2629 1DCD E6 86		        inc	ptr1		; dest. pointer
  2630 1DCF D0 02		        bne	evenCount
  2631 1DD1 E6 87		        inc	ptr1+1
  2632 1DD3			evenCount:
  2633 1DD3 A5 86			lda	ptr1		; build second pointer section
  2634 1DD5 18				clc
  2635 1DD6 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2636 1DD8 85 82			sta     ptr2
  2637 1DDA A5 87			lda     ptr1+1
  2638 1DDC 65 8B			adc     ptr3+1
  2639 1DDE 85 83			sta     ptr2+1
  2640
  2641 1DE0 8A			        txa			; restore fill value
  2642 1DE1 A6 8B		        ldx	ptr3+1		; Get high byte of n
  2643 1DE3 F0 13		        beq	L2		; Jump if zero
  2644
  2645 				; Set 256/512 byte blocks
  2646 								; y is still 0 here
  2647 				L1:	.rept 2		; Unroll this a bit to make it faster
  2648 					STA	(PTR1),Y	
  2649 					STA	(PTR2),Y	
  2650 					INY
  2651 					.ENDR
  2651 					.endr
Source: REPT
  2648 1DE5 91 86			STA	(PTR1),Y	
  2648 1DE7 91 82			STA	(PTR2),Y	
  2648 1DE9 C8				INY
  2648 1DEA 91 86			STA	(PTR1),Y	
  2648 1DEC 91 82			STA	(PTR2),Y	
  2648 1DEE C8				INY
Source: cpu6502.asm
  2652 1DEF D0 F4		        bne	L1
  2653 1DF1 E6 87		        inc	ptr1+1
  2654 1DF3 E6 83		        inc	ptr2+1
  2655 1DF5 CA			        dex                     ; Next 256 byte block
  2656 1DF6 D0 ED		        bne	L1              ; Repeat if any
  2657
  2658 				; Set the remaining bytes if any
  2659
  2660 1DF8 A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2661 1DFA F0 07			beq	leave           ; something to set? No -> leave
  2662
  2663 1DFC 88			L3:	dey
  2664 1DFD 91 86			sta	(ptr1),y	; set bytes in low
  2665 1DFF 91 82			sta	(ptr2),y	; and high section
  2666 1E01 D0 F9			bne     L3		; flags still up to date from dey!
  2667
  2668 1E03 68 AA		leave	pla:tax
  2669 1E05 60				rts			; return
  2670 				.endp
  2671
  2672
  2673 				/*
  2674 				 add strings
  2675 				 result -> @buf
  2676 				*/
  2676
  2677 1E06			.proc	@addString(.word ya) .reg
  2678
  2679 					sta ztmp
  2680 					sty ztmp+1
  2681
  2682 					stx @sp
  2683
  2684 					ldx @buf
  2685 					inx
  2686 					beq stop
  2687
  2688 					ldy #0
  2689 					lda (ztmp),y
  2690 					sta ile
  2691 					beq stop
  2692
  2693 					iny
  2694
  2695 1E06			load	lda (ztmp),y
  2696 					sta @buf,x
  2697
  2698 					iny
  2699 					inx
  2700 					beq stop
  2701 					dec ile
  2702 					bne load
  2703
  2704 1E06			stop	dex
  2705 					stx @buf
  2706
  2707 					ldx #0
  2708 1E06			@sp	equ *-1
  2709 					rts
  2710
  2711 1E06			ile	brk
  2712 				.endp
  2713
  2714
  2715 				/* ----------------------------------------------------------------------- */
  2716
  2717
  2718 1E06			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2719
  2720 					jsr swap
  2721
  2722 					adw spoint ztmp+2
  2723
  2724 					rts
  2725
  2726 1E06			swap	txa:pha
  2727
  2728 					mwa spoint bp2
  2729
  2730 					ldx #0
  2731 					ldy #0
  2732
  2733 1E06			loop	cpy ztmp+2
  2734 					bne @+
  2735 					cpx ztmp+3
  2736 					beq stop
  2737
  2738 1E06			@	lda (bp2),y
  2739 					pha
  2740
  2741 					lda (ztmp),y
  2742 					sta (bp2),y
  2743
  2744 					pla
  2745 					sta (ztmp),y
  2746
  2747 					iny
  2748 					bne loop
  2749
  2750 					inc ztmp+1
  2751 					inc bp2+1
  2752 					inx
  2753
  2754 					jmp loop
  2755
  2756 1E06			stop	pla:tax
  2757
  2758 					rts
  2759
  2760 1E06			spoint	dta a(PROGRAMSTACK)
  2761 				.endp
  2762
  2763
  2764 1E06			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2765
  2766 					sbw @AllocMem.spoint ztmp+2
  2767
  2768 					jmp @AllocMem.swap
  2769 				.endp
  2770
  2771
  2772 				/* ----------------------------------------------------------------------- */
  2773
  2774
  2775 1E06			.proc	@vbxe_detect
  2776
  2777 					ldy #.sizeof(detect)-1
  2778 					mva:rpl copy,y detect,y-
  2779
  2780 					jmp detect
  2781
  2782 1E06			copy
  2783 0400				.local	detect,@buf
  2784 				;
  2785 				; 2009 by KMK/DLT
  2786 				;
  2787 					lda #0
  2788 					sta fxptr
  2789
  2790 				        lda #$d6
  2791 				        sta fxptr+1
  2792 				        ldy #FX_MEMB
  2793 				        jsr ?clr
  2794
  2795 				        jsr ?try
  2796 				        bcc ok
  2797
  2798 				        inc fxptr+1
  2799
  2800 					jsr ?try
  2801 					bcc ok
  2802
  2803 					lda #0
  2804 					sta fxptr+1
  2805 					rts
  2806
  2807 0400			?try    ldx $4000
  2808 				        jsr ?chk
  2809 				        bcc ?ret
  2810 				        inx
  2811 				        stx $4000
  2812 				        jsr ?chk
  2813 				        dec $4000
  2814 0400			?ret    rts
  2815
  2816 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2817 					lda	(fxptr),y
  2818 					rts
  2819
  2820 0400			?chk    lda #$80
  2821 				        jsr _vbxe_write
  2822 				        cpx $4000
  2823 				        bne ?fnd
  2824 				        sec
  2825 0400			        .byte $24
  2826 0400			?fnd    clc
  2827 0400			?clr    lda #$00
  2828 0400			_vbxe_write
  2829 				        sta (fxptr),y
  2830 				        rts
  2831
  2832 				/*
  2833 					lda	#0
  2834 					ldx	#0xd6
  2835 					sta	0xd640			; make sure it isn't coincidence
  2836 					lda	0xd640
  2837 					cmp	#0x10			; do we have major version here?
  2838 					beq	VBXE_Detected		; if so, then VBXE is detected
  2839 					lda	#0
  2840 					inx
  2841 					sta	0xd740			; no such luck, try other location
  2842 					lda	0xd740
  2843 					cmp	#0x10
  2844 					beq	VBXE_Detected
  2845 					ldx 	#0  			; not here, so not present or FX core version too low
  2846 					stx	fxptr+1
  2847 					stx	fxptr
  2848
  2849 					sec
  2850 					rts
  2851
  2852 				VBXE_Detected
  2853 					stx	fxptr+1
  2854 					lda	#0
  2855 					sta	fxptr
  2856
  2857 					ldy	#VBXE_MINOR		; get core minor version
  2858 					lda	(fxptr),y
  2859
  2860 					clc
  2861 					rts	 			; x - page of vbxe
  2862 				*/
  2862
  2863
  2864 					.endl
  2865
  2866 				.endp
  2867
  2868
  2869 1E06			.proc	@setxdl(.byte a) .reg
  2870
  2871 					asl @
  2872 					sta idx
  2873
  2874 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2875
  2876 					ldy #0
  2877 1E06			idx	equ *-1
  2878
  2879 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2880 					and msk,y
  2881 					ora val,y
  2882 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2883
  2884 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2885 					and msk+1,y
  2886 					ora val+1,y
  2887 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2888
  2889 					fxs FX_MEMS #0
  2890 					rts
  2891
  2892 1E06			msk	.array [6] .word
  2893 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2894 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2895 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2896 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2897 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2898 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2899 					.enda
  2900
  2901 1E06			val	.array [6] .word
  2902 					[e@xdl.mapon]  = XDLC_MAPON
  2903 					[e@xdl.mapoff] = XDLC_MAPOFF
  2904 					[e@xdl.ovron]  = XDLC_GMON
  2905 					[e@xdl.ovroff] = XDLC_OVOFF
  2906 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2907 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2908 					.enda
  2909
  2910 				.endp
  2911
  2912
  2913 1E06			.proc	@vbxe_init
  2914
  2915 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2916 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2917
  2918 					ldx #.sizeof(s@xdl)-1
  2919 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2920
  2921 					jsr cmapini		; init color map
  2922
  2923 					fxsa FX_P1		; A = 0
  2924 					fxsa FX_P2
  2925 					fxsa FX_P3
  2926
  2927 					fxsa FX_IRQ_CONTROL
  2928 					fxsa FX_BLITTER_START
  2929
  2930 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2931 					fxsa FX_XDL_ADR1
  2932 					fxsa FX_XDL_ADR2
  2933
  2934 					sta colpf0s
  2935
  2936 					fxs FX_P0 #$ff
  2937
  2938 					mwa #@vbxe_cmap @putchar.vbxe+1
  2939 					mva #{jsr*} @putchar.vbxe
  2940
  2941 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2942
  2943 					rts
  2944
  2945 1E06			cmapini	lda colpf1s
  2946 					and #$0f
  2947 					sta colpf1s
  2948
  2949 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2950 					sta ztmp
  2951
  2952 					mva #4 ztmp+1
  2953
  2954 1E06			loop	fxs FX_MEMS ztmp
  2955
  2956 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2957 					sta bp+1
  2958
  2959 					ldx #16
  2960 					ldy #0
  2961
  2962 1E06			lop	mva #$00	(bp),y+
  2963 					mva colpf1s	(bp),y+
  2964 					mva colpf2s	(bp),y+
  2965 					mva #%00010000	(bp),y+		; overlay palette #1
  2966 					bne lop
  2967
  2968 					inc bp+1
  2969 					dex
  2970 					bne lop
  2971
  2972 					inc ztmp
  2973
  2974 					dec ztmp+1
  2975 					bne loop
  2976
  2977 					fxs FX_MEMS #$00		; disable VBXE BANK
  2978 					rts
  2979
  2980 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2981 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2982 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2983 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2984 					0, 0, 7, 7, %00010001, $ff)
  2984 1E06			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2985 				.endp
  2986
  2987
  2988 1E06			.proc	@vbxe_cmap
  2989
  2990 					pha
  2991
  2992 					cmp #eol
  2993 					beq stop
  2994
  2995 					cmp #$7d		; clrscr
  2996 					bne skp
  2997
  2998 					jsr @vbxe_init.cmapini
  2999 					jmp stop
  3000
  3001 1E06			skp	lda rowcrs
  3002 					pha
  3003 1E06				:4 lsr @
  3004 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  3005 					fxsa FX_MEMS
  3006
  3007 					pla
  3008 					and #$0f
  3009 					add >MAIN.SYSTEM.VBXE_WINDOW
  3010 					sta bp+1
  3011
  3012 					lda colcrs
  3013 					asl @
  3014 					asl @
  3015 					tay
  3016 					mva colpf0s (bp),y
  3017 					iny
  3018 					mva colpf1s (bp),y
  3019 					iny
  3020 					mva colpf2s (bp),y
  3021
  3022 					fxs FX_MEMS #$00
  3023
  3024 1E06			stop	pla
  3025
  3026 					rts
  3027 				.endp
  3028
  3029
  3030 				/* ----------------------------------------------------------------------- */
  3031
  3032
  3033 				/*
  3034 				.proc	@cmdline (.byte a) .reg
  3035
  3036 					stx @sp
  3037
  3038 					sta idpar
  3039
  3040 					lda #0
  3041 					sta parno
  3042
  3043 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3044 					lsr
  3045 					bcc _no_command_line
  3046
  3047 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3048 					cmp #$c0
  3049 					bcs _no_command_line
  3050
  3051 					ldy #$03
  3052 					lda (dosvec),y
  3053 					cmp #{jmp}
  3054 					bne _no_command_line
  3055
  3056 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3057 					lda (dosvec),y
  3058 					sta lbuf
  3059 					iny
  3060 					lda (dosvec),y
  3061 					sta hbuf
  3062
  3063 					adw dosvec #3 zcr
  3064
  3065 				loop	lda #0
  3066 					sta @buf
  3067
  3068 					jsr $ffff
  3069 				zcr	equ *-2
  3070 					beq stop
  3071
  3072 					lda idpar
  3073 					bne skp
  3074
  3075 					ldy #33			; ParamStr(0)
  3076 				_par0	lda (dosvec),y
  3077 					sta @buf-33+1,y
  3078 					iny
  3079 					cpy #36
  3080 					bne _par0
  3081
  3082 					lda #3
  3083 					sta @buf
  3084 					bne stop
  3085
  3086 				skp	ldy #36
  3087 				_cp	lda (dosvec),y
  3088 					sta @buf-36+1,y
  3089 					iny
  3090 					cmp #$9b
  3091 					bne _cp
  3092
  3093 					tya
  3094 					sub #37
  3095 					sta @buf
  3096
  3097 					inc parno
  3098 					lda #0
  3099 				parno	equ *-1
  3100 					cmp #0
  3101 				idpar	equ *-1
  3102
  3103 					bne loop
  3104
  3105 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3106 					lda #0
  3107 				lbuf	equ *-1
  3108 					sta (dosvec),y
  3109 					iny
  3110 					lda #0
  3111 				hbuf	equ *-1
  3112 					sta (dosvec),y
  3113
  3114 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3115
  3116 					lda parno
  3117
  3118 					ldx #0
  3119 				@sp	equ *-1
  3120 					rts
  3121 				.endp
  3122 				*/
  3122
  3123
  3124
  3125 1E06			.proc	@CmdLine (.byte a) .reg
  3126
  3127 					stx @sp
  3128
  3129 					sta idpar
  3130
  3131 					lda #0
  3132 					sta parno
  3133 					sta loop+1
  3134
  3135 					lda	#{jsr*}
  3136 					sta	res
  3137
  3138 				; Get filename from SpartaDOS...
  3139 1E06			get_param
  3140 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3141 					lsr
  3142 					bcc no_sparta
  3143
  3144 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3145 					cmp #$c0
  3146 					bcs no_sparta
  3147
  3148 					ldy #$03
  3149 					lda (dosvec),y
  3150 					cmp #{jmp}
  3151 					bne no_sparta
  3152
  3153 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3154 					lda (dosvec),y
  3155 					sta lbuf
  3156 					iny
  3157 					lda (dosvec),y
  3158 					sta hbuf
  3159
  3160 					adw dosvec #33 tmp
  3161
  3162 					ldy #0
  3163 1E06			fnm	lda (tmp),y
  3164 					iny
  3165 					cmp #$9b
  3166 					bne fnm
  3167
  3168 					tya			; remove .COM
  3169 					sub #5
  3170 					tay
  3171 					lda #0
  3172 					sta (tmp),y
  3173 					tay
  3174
  3175 					lda	#3
  3176 					sta	loop+1
  3177 					add	dosvec
  3178 					sta	get_adr
  3179 					lda	#0
  3180 					adc	dosvec+1
  3181 					sta	get_adr+1
  3182
  3183 					jmp	_ok
  3184
  3185 1E06			no_sparta
  3186 					mwa #next get_adr
  3187
  3188 					lda	#{bit*}
  3189 					sta	res
  3190
  3191 				; ... or channel #0
  3192 					lda	MAIN.IOCB@COPY+2	; command
  3193 					cmp	#5			; read line
  3194 					bne	_no_command_line
  3195 					lda	MAIN.IOCB@COPY+3	; status
  3196 					bmi	_no_command_line
  3197 				; don't assume the line is EOL-terminated
  3198 				; DOS II+/D overwrites the EOL with ".COM"
  3199 				; that's why we rely on the length
  3200 					lda	MAIN.IOCB@COPY+9	; length hi
  3201 					bne	_no_command_line
  3202 					ldx	MAIN.IOCB@COPY+8	; length lo
  3203 					beq	_no_command_line
  3204 					inx:inx
  3205 					stx	arg_len
  3206 				; give access to three bytes before the input buffer
  3207 				; in DOS II+/D the device prompt ("D1:") is there
  3208 					lda	MAIN.IOCB@COPY+4
  3209 					sub	#3
  3210 					sta	tmp
  3211 					lda	MAIN.IOCB@COPY+5
  3212 					sbc	#0
  3213 					sta	tmp+1
  3214
  3215 					lda	#0
  3216 					ldy	#0
  3217 1E06			arg_len	equ *-1
  3218 					sta	(tmp),y
  3219
  3220
  3221 1E06			loop	ldy	#0
  3222
  3223 1E06			_ok	ldx	#0
  3224
  3225 1E06			lprea	lda	(tmp),y
  3226 					sta	@buf+1,x
  3227
  3228 					beq	stop
  3229
  3230 					cmp	#$9b
  3231 					beq	stop
  3232 					cmp	#' '
  3233 					beq	stop
  3234
  3235 					iny
  3236 					inx
  3237 					cpx #32
  3238 					bne lprea
  3239
  3240 1E06			stop	lda #0
  3241 1E06			parno	equ *-1
  3242 					cmp #0
  3243 1E06			idpar	equ *-1
  3244 					beq found
  3245
  3246 					jsr $ffff		; sty loop+1
  3247 1E06			get_adr	equ *-2
  3248 					beq found
  3249
  3250 					inc parno
  3251 					bne loop
  3252
  3253 1E06			found	lda #0	;+$9b
  3254 					sta @buf+1,x
  3255 					stx @buf
  3256
  3257 1E06			res	jsr sdxres
  3258
  3259 1E06			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3260
  3261 					lda parno
  3262
  3263 					ldx #0
  3264 1E06			@sp	equ *-1
  3265 					rts
  3266
  3267
  3268 1E06			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3269 					lda #0
  3270 1E06			lbuf	equ *-1
  3271 					sta (dosvec),y
  3272 					iny
  3273 					lda #0
  3274 1E06			hbuf	equ *-1
  3275 					sta (dosvec),y
  3276 					rts
  3277
  3278
  3279 1E06			_next	iny
  3280 1E06			next	lda (tmp),y
  3281 					beq _eol
  3282 					cmp #' '
  3283 					beq _next
  3284
  3285 					cmp #$9b
  3286 					beq _eol
  3287
  3288 					sty loop+1
  3289 					rts
  3290
  3291 1E06			_eol	lda #0
  3292 					rts
  3293
  3294 				.endp
  3295
  3296
  3297 				/* ----------------------------------------------------------------------- */
  3298
  3299 				/*
  3300 				.proc	@rstsnd
  3301 					lda #0
  3302 					sta $d208
  3303 					sta $d218
  3304
  3305 					ldy #3
  3306 					sty $d20f
  3307 					sty $d21f
  3308 					rts
  3309 				.endp
  3310 				*/
  3310
  3311
  3312 				;	ert (*>$3fff) .and (*<$8000)
  3313
  3314
  3315 				/* ----------------------------------------------------------------------- */
  3316
  3317
  3318 1E06			.proc	@xmsBank
  3319
  3320 = 0082			ptr3 = eax			; position	(4)
  3321
  3322 					mva ptr3+3 ztmp+1	; position shr 14
  3323 					mva ptr3+2 ztmp
  3324 					lda ptr3+1
  3325
  3326 					.rept 6
  3327 					LSR ZTMP+1
  3328 					ROR ZTMP
  3329 					ROR @
  3330 					.ENDR
  3330 					.endr
Source: REPT
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
  3327 					LSR ZTMP+1
  3327 					ROR ZTMP
  3327 					ROR @
Source: cpu6502.asm
  3331
  3332 					tax			; index to bank
  3333
  3334 					lda portb
  3335 					and #1
  3336 					ora main.misc.adr.banks,x
  3337 					sta portb
  3338
  3339 					lda ptr3 		; offset
  3340 					sta ztmp
  3341 					lda ptr3+1
  3342 					and #$3f
  3343 					ora #$40
  3344 					sta ztmp+1
  3345
  3346 					rts
  3347 				.endp
  3348
  3349
  3350 1E06			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3351
  3352 = 0086			ptr1 = dx	; buffer	(2)
  3353
  3354 = 008A			ptr2 = cx	; count		(2)
  3355 = 008C			pos = cx+2	; position	(2) pointer
  3356
  3357 = 0082			ptr3 = eax	; position	(4)
  3358
  3359 					txa:pha
  3360
  3361 					ldy #0
  3362 					lda (pos),y
  3363 					sta ptr3
  3364 					iny
  3365 					lda (pos),y
  3366 					sta ptr3+1
  3367 					iny
  3368 					lda (pos),y
  3369 					sta ptr3+2
  3370 					iny
  3371 					lda (pos),y
  3372 					sta ptr3+3
  3373
  3374 					lda ptr2+1
  3375 					beq lp2
  3376
  3377 1E06			lp1	jsr @xmsBank
  3378
  3379 					lda ztmp+1
  3380 					cmp #$7f
  3381 					bne skp
  3382 					lda ztmp
  3383 					beq skp
  3384
  3385 					lda #0
  3386 					jsr nextBank
  3387 					jmp skp2
  3388
  3389 1E06			skp	ldy #0
  3390 					mva:rne (ztmp),y @buf,y+
  3391
  3392 1E06			skp2	lda portb
  3393 					and #1
  3394 					ora #$fe
  3395 					sta portb
  3396
  3397 					ldy #0
  3398 					mva:rne @buf,y (dx),y+
  3399
  3400 					inc dx+1	// inc(dx, $100)
  3401
  3402 					inl ptr3+1	// inc(position, $100)
  3403
  3404 					dec ptr2+1
  3405 					bne lp1
  3406
  3407 1E06			lp2	jsr @xmsBank
  3408
  3409 					lda ztmp+1		; zakonczenie kopiowania
  3410 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3411 					bne skp_
  3412
  3413 					lda ztmp
  3414 					add ptr2
  3415 					bcc skp_
  3416
  3417 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3418 					jsr nextBank
  3419 					jmp skp3
  3420
  3421 1E06			skp_	ldy #0
  3422 1E06			mv	lda (ztmp),y
  3423 					sta @buf,y
  3424 					iny
  3425 					cpy ptr2
  3426 					bne mv
  3427
  3428 1E06			skp3	lda portb
  3429 					and #1
  3430 					ora #$fe
  3431 					sta portb
  3432
  3433 					ldy #0
  3434 1E06			lp3	lda @buf,y
  3435 					sta (dx),y
  3436 					iny
  3437 					cpy ptr2
  3438 					bne lp3
  3439
  3440 					jmp @xmsUpdatePosition
  3441
  3442 1E06			.local	nextBank
  3443
  3444 					sta max
  3445
  3446 					mwa ztmp src
  3447
  3448 					ldy #0
  3449 1E06			mv0	lda $ffff,y
  3450 1E06			src	equ *-2
  3451 					sta @buf,y
  3452 					iny
  3453 					inc ztmp
  3454 					bne mv0
  3455
  3456 					lda portb
  3457 					and #1
  3458 					ora main.misc.adr.banks+1,x
  3459 					sta portb
  3460
  3461 					ldx #0
  3462 1E06			mv1	cpy #0
  3463 1E06			max	equ *-1
  3464 					beq stp
  3465 					lda $4000,x
  3466 					sta @buf,y
  3467 					inx
  3468 					iny
  3469 					bne mv1
  3470 1E06			stp	rts
  3471 				.endl
  3472
  3473 				.endp
  3474
  3475
  3476 1E06			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3477
  3478 = 0086			ptr1 = dx	; buffer	(2)
  3479
  3480 = 008A			ptr2 = cx	; count		(2)
  3481 = 008C			pos = cx+2	; position	(2) pointer
  3482
  3483 = 0082			ptr3 = eax	; position	(4)
  3484
  3485 					txa:pha
  3486
  3487 					ldy #0			; przepisz POSITION spod wskaznika
  3488 					lda (pos),y
  3489 					sta ptr3
  3490 					iny
  3491 					lda (pos),y
  3492 					sta ptr3+1
  3493 					iny
  3494 					lda (pos),y
  3495 					sta ptr3+2
  3496 					iny
  3497 					lda (pos),y
  3498 					sta ptr3+3
  3499
  3500 1E06			lp1	lda portb		; wylacz dodatkowe banki
  3501 					and #1
  3502 					ora #$fe
  3503 					sta portb
  3504
  3505 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3506 					mva:rne (dx),y @buf,y+
  3507
  3508 					jsr @xmsBank		; wlacz dodatkowy bank
  3509
  3510 					lda ptr2+1
  3511 					beq lp2
  3512
  3513 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3514 					cmp #$7f
  3515 					bne skp
  3516 					lda ztmp
  3517 					beq skp
  3518
  3519 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3520 					jsr nextBank
  3521 					jmp skp2
  3522
  3523 1E06			skp	mva:rne @buf,y (ztmp),y+
  3524
  3525 1E06			skp2	inc dx+1		// inc(dx, $100)
  3526
  3527 					inl ptr3+1		// inc(position, $100)
  3528
  3529 					dec ptr2+1
  3530 					bne lp1
  3531
  3532 1E06			lp2	lda ztmp+1		; zakonczenie kopiowania
  3533 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3534 					bne skp_
  3535
  3536 					lda ztmp
  3537 					add ptr2
  3538 					bcc skp_
  3539
  3540 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3541 					jsr nextBank
  3542 					jmp quit
  3543
  3544 1E06			skp_	ldy #0
  3545 1E06			lp3	lda @buf,y
  3546 					sta (ztmp),y
  3547
  3548 					iny
  3549 					cpy ptr2
  3550 					bne lp3
  3551
  3552 1E06			quit	lda portb
  3553 					and #1
  3554 					ora #$fe
  3555 					sta portb
  3556
  3557 					jmp @xmsUpdatePosition
  3558
  3559 1E06			.local	nextBank
  3560
  3561 					sta max
  3562
  3563 					mwa ztmp dst
  3564
  3565 					ldy #0
  3566 1E06			mv0	lda @buf,y
  3567 					sta $ffff,y
  3568 1E06			dst	equ *-2
  3569 					iny
  3570 					inc ztmp
  3571 					bne mv0
  3572
  3573 					lda portb
  3574 					and #1
  3575 					ora main.misc.adr.banks+1,x
  3576 					sta portb
  3577
  3578 					ldx #0
  3579 1E06			mv1	cpy #0
  3580 1E06			max	equ *-1
  3581 					beq stp
  3582 					lda @buf,y
  3583 					sta $4000,x
  3584 					inx
  3585 					iny
  3586 					bne mv1
  3587 1E06			stp	rts
  3588 				.endl
  3589
  3590 				.endp
  3591
  3592
  3593 1E06			.proc	@xmsAddPosition
  3594
  3595 1E06				.use @xmsReadBuf
  3596
  3597 					add ptr3
  3598 					sta ptr3
  3599 					lda #$00
  3600 					adc ptr3+1
  3601 					sta ptr3+1
  3602 					lda #$00
  3603 					adc ptr3+2
  3604 					sta ptr3+2
  3605 					lda #$00
  3606 					adc ptr3+3
  3607 					sta ptr3+3
  3608
  3609 					rts
  3610 				.endp
  3611
  3612
  3613 1E06			.proc	@xmsUpdatePosition
  3614
  3615 1E06				.use @xmsReadBuf
  3616
  3617 					tya
  3618 					jsr @xmsAddPosition
  3619
  3620 					ldy #0
  3621 					lda ptr3
  3622 					sta (pos),y
  3623 					iny
  3624 					lda ptr3+1
  3625 					sta (pos),y
  3626 					iny
  3627 					lda ptr3+2
  3628 					sta (pos),y
  3629 					iny
  3630 					lda ptr3+3
  3631 					sta (pos),y
  3632
  3633 					pla:tax
  3634 					rts
  3635 				.endp
  3636
  3637
  3638 				/* ----------------------------------------------------------------------- */
  3639
  3640
  3641 1E06			.proc	@ClrScr
  3642
  3643 					ldx #$00
  3644 					lda #$0c
  3645 					jsr xcio
  3646
  3647 					mwa #ename ioadr,x
  3648
  3649 					mva #$0c ioaux1,x
  3650 					mva #$00 ioaux2,x
  3651
  3652 					lda #$03
  3653
  3654 1E06			xcio	sta iocom,x
  3655 					jmp ciov
  3656
  3657 1E06			ename	.byte 'E:',$9b
  3658
  3659 				.endp
  3660
  3661
  3662 				/* ----------------------------------------------------------------------- */
  3663
  3664
  3665 					opt l+
  3390
  3391 				; -----------------------------------------------------------
  3392
  3393 				.macro UNITINITIALIZATION
  3394 				
  3395 					.ifdef MAIN.SYSTEM.@UnitInit
  3396 					jsr MAIN.SYSTEM.@UnitInit
  3397 					eif
  3398 				
  3399 					.ifdef MAIN.ATARI.@UnitInit
  3400 					jsr MAIN.ATARI.@UnitInit
  3401 					eif
  3402 				
  3403 					.ifdef MAIN.B_UTILS.@UnitInit
  3404 					jsr MAIN.B_UTILS.@UnitInit
  3405 					eif
  3406 				
  3407 					.ifdef MAIN.B_SYSTEM.@UnitInit
  3408 					jsr MAIN.B_SYSTEM.@UnitInit
  3409 					eif
  3410 				
  3411 					.ifdef MAIN.DOS.@UnitInit
  3412 					jsr MAIN.DOS.@UnitInit
  3413 					eif
  3414 				
  3415 					.ifdef MAIN.STRUTILS.@UnitInit
  3416 					jsr MAIN.STRUTILS.@UnitInit
  3417 					eif
  3418 				
  3419 					.ifdef MAIN.SYSUTILS.@UnitInit
  3420 					jsr MAIN.SYSUTILS.@UnitInit
  3421 					eif
  3422 				
  3423 					.ifdef MAIN.B_CRT.@UnitInit
  3424 					jsr MAIN.B_CRT.@UnitInit
  3425 					eif
  3426 				
  3427 					.ifdef MAIN.CMC.@UnitInit
  3428 					jsr MAIN.CMC.@UnitInit
  3429 					eif
  3430 				.endm
  3431
  3432 					ift .SIZEOF(MAIN.SYSTEM) > 0
  3433 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  3433 				SYSTEM: $0ED3..$0F41
  3434 					eif
  3435
  3436 					ift .SIZEOF(MAIN.ATARI) > 0
  3437 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  3438 					eif
  3439
  3440 					ift .SIZEOF(MAIN.B_UTILS) > 0
  3441 					.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
  3442 					eif
  3443
  3444 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  3445 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  3445 				B_SYSTEM: $0F42..$1057
  3446 					eif
  3447
  3448 					ift .SIZEOF(MAIN.DOS) > 0
  3449 					.print 'DOS: ',MAIN.DOS,'..',MAIN.DOS+.SIZEOF(MAIN.DOS)-1
  3450 					eif
  3451
  3452 					ift .SIZEOF(MAIN.STRUTILS) > 0
  3453 					.print 'STRUTILS: ',MAIN.STRUTILS,'..',MAIN.STRUTILS+.SIZEOF(MAIN.STRUTILS)-1
  3454 					eif
  3455
  3456 					ift .SIZEOF(MAIN.SYSUTILS) > 0
  3457 					.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
  3458 					eif
  3459
  3460 					ift .SIZEOF(MAIN.B_CRT) > 0
  3461 					.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
  3461 				B_CRT: $1058..$107A
  3462 					eif
  3463
  3464 					ift .SIZEOF(MAIN.CMC) > 0
  3465 					.print 'CMC: ',MAIN.CMC,'..',MAIN.CMC+.SIZEOF(MAIN.CMC)-1
  3465 				CMC: $107B..$1141
  3466 					eif
  3467
  3468 					.print 'CODE: ',CODEORIGIN,'..',*-1
  3468 				CODE: $0C00..$1E05
  3469
  3470 1E06			DATAORIGIN
  3471
  3472 1E06 28 00 18 00 2D 0C + .by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3473 1E1E 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  3474 1E36 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $04 $0A $0E $00 $04 $0A $0E $00  $00 $00 $00 $00 $00 $00 $00 $00
  3475 1E4E 00 00 0F 0C 1B 0C + .by  $00 $00 $0F $0C $1B $0C $31 $0C  $47 $0C $5D $0C $73 $0C $89 $0C  $9F $0C $B5 $0C $CB $0C $E1 $0C
  3476 1E66 F7 0C 0D 0D 23 0D + .by  $F7 $0C $0D $0D $23 $0D $39 $0D  $4F $0D $65 $0D $7B $0D $91 $0D
  3477
  3478 = 0070			VARINITSIZE	= *-DATAORIGIN
  3479 = 018E			VARDATASIZE	= 398
  3480
  3481 = 1F94			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  3482
  3483 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  3483 				DATA: $1E06..$1F94
  3484
  3485 02E0-02E1> A7 0E			run START
  3486
  3487 				; -----------------------------------------------------------
  3488
  3489 				.macro	STATICDATA
  3490 				.by  $04 $54 $52 $55 $45 $00 $05 $46  $41 $4C $53 $45 $00 $00 $00 $0A  $39 $65 $61 $72 $00 $12 $14 $11
  3491 				.by  $19 $0C $00 $14 $35 $6E $69 $74  $65 $64 $00 $25 $61 $72 $74 $68  $00 $25 $6D $70 $69 $72 $65 $00
  3492 				.by  $00 $14 $69 $73 $00 $73 $74 $69  $6C $6C $00 $66 $69 $67 $68 $74  $69 $6E $67 $0E $00 $00 $00 $14
  3493 				.by  $21 $66 $74 $65 $72 $00 $18 $00  $79 $65 $61 $72 $73 $00 $69 $6E  $00 $00 $00 $00 $00 $14 $6D $69
  3494 				.by  $6C $69 $74 $61 $72 $79 $0C $00  $79 $6F $75 $00 $68 $61 $76 $65  $00 $00 $00 $14 $66 $69 $6E $61
  3495 				.by  $6C $6C $79 $00 $66 $75 $6C $66  $69 $6C $6C $65 $64 $00 $00 $00  $00 $14 $79 $6F $75 $72 $00 $63
  3496 				.by  $6F $6E $74 $72 $61 $63 $74 $0E  $00 $00 $00 $00 $00 $00 $00 $14  $26 $6F $72 $00 $61 $00 $6C $6F
  3497 				.by  $6E $67 $00 $74 $69 $6D $65 $00  $79 $6F $75 $00 $00 $14 $68 $61  $76 $65 $00 $64 $72 $65 $61 $6D
  3498 				.by  $65 $64 $00 $61 $62 $6F $75 $74  $00 $00 $00 $14 $6F $77 $6E $00  $76 $65 $6E $74 $75 $72 $65 $00
  3499 				.by  $61 $6E $64 $00 $74 $6F $00 $00  $00 $14 $62 $65 $00 $61 $62 $6C  $65 $00 $74 $6F $00 $64 $6F $00
  3500 				.by  $00 $00 $00 $00 $00 $00 $00 $14  $77 $68 $61 $74 $65 $76 $65 $72  $00 $79 $6F $75 $00 $77 $61 $6E
  3501 				.by  $74 $0E $00 $00 $00 $14 $37 $69  $74 $68 $00 $72 $65 $63 $65 $69  $76 $65 $64 $00 $70 $61 $79 $00
  3502 				.by  $00 $00 $00 $14 $63 $68 $65 $63  $6B $00 $79 $6F $75 $00 $77 $65  $72 $65 $00 $61 $62 $6C $65 $00
  3503 				.by  $00 $14 $74 $6F $00 $62 $75 $79  $00 $63 $68 $65 $61 $70 $65 $73  $74 $00 $73 $68 $69 $70 $00 $14
  3504 				.by  $61 $6E $64 $00 $73 $74 $69 $6C  $6C $00 $68 $61 $76 $65 $00 $73  $6F $6D $65 $00 $00 $14 $63 $68
  3505 				.by  $61 $6E $67 $65 $00 $6C $65 $66  $74 $0E $00 $00 $00 $00 $00 $00  $00 $00 $00 $14 $29 $74 $00 $69
  3506 				.by  $73 $00 $75 $70 $00 $74 $6F $00  $79 $6F $75 $0C $00 $00 $00 $00  $00 $14 $77 $68 $65 $72 $65 $00
  3507 				.by  $74 $6F $00 $67 $6F $00 $6E $6F  $77 $0E $0E $0E $00 $00 $00 $6C  $6A $3B $FF $FF $6B $2B $2A $6F
  3508 				.by  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34  $FF $33 $36 $1B $35 $32 $31 $2C
  3509 				.by  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39  $FF $30 $37 $7E $38 $3E $FF $66
  3510 				.by  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F  $FF $50 $55 $FF $49 $5F $7C $56
  3511 				.by  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B  $3B $5D $4E $FF $4D $3F $FF $52
  3512 				.by  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46  $48 $44 $FF $FF $47 $53 $41 $FF
  3513 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3514 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3515 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3516 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3517 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  3518 				.by  $FF $FF $FF $FF $FF $FF $FF
  3519 				.endm
  3520
  3521 					end
